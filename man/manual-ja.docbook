<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN" "http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">
<book>
  <bookinfo>
    <title>Cppcheck 1.85</title>

    <date>2018-04-23</date>
  </bookinfo>

  <chapter>
    <title>イントロダクション</title>

    <para>Cppcheck は C/C++の静的解析ツールです。C/C++ コンパイラやその他の解析ツールとは異なり、シンタックスエラーを検出しません。	その代わりに、Cppcheckは、コンパイラが通常、検出に失敗するような種類のバグを検出します。このプロジェクトのゴールは、擬陽性 0 です。</para>

    <para>サポートしているプログラムのソースコードとプラットフォーム：</para>

    <itemizedlist>
      <listitem>
        <para>さまざまなコンパイラの拡張構文や、インラインアセンブル等を含む、非標準的なソースコードをチェックできます。</para>
      </listitem>

      <listitem>
        <para>Cppcheck は 最新のC++規格をサポートしている、あらゆるC++コンパイラでコンパイルできるようにしています。</para>
      </listitem>

      <listitem>
        <para>Cppcheck は 十分なCPUパワーとメモリーのある、あらゆるプラットフォームで動作するようにしています。</para>
      </listitem>
    </itemizedlist>

    <para>Cppcheckに限界があることをご理解ください。Cppcheckの報告しているエラーに稀に間違いのあることがあります。また、Cppcheck が検出しないバグが残っていることもあります。</para>

    <para>ソフトウェアを注意深くテストすれば、Cppcheckを使うより、より多くのバグを検出できるでしょう。ソフトウェアを注意深く実装すれば、Cppcheckを使うより、より多くのバグを検出できるでしょう。しかし、あなたのソフトウェアを実装するときやテストするときに見逃したバグのいくつかを Cppcheckが検出できるでしょう。</para>
  </chapter>

  <chapter>
    <title>GUIでのはじめ方</title>

    <para>GUIの起動</para>

    <section>
      <title>新しいプロジェクト(New Project)</title>

      <para>新しプロジェクトのファイルの作成は必要ではありませんが、最初のステップに最適です。ファイル（<literal>File</literal>）と新しいプロジェクトファイル（<literal>New project file</literal>）を通じて学べます。</para>
    </section>

    <section>
      <title>新しいプロジェクト（New Project） - パス（Paths）と定義（Defines）</title>

      <para>あなたのプロジェクトはどのようなプロジェクトでしょうか。あなたのプロジェクトがVisual Studioのプロジェクトの場合、または(cmake/qbs/等の)コンパイルデータベースqが精製できる場合、あなたはプロジェクトをインポート（import）できます。</para>

      <para>そうではない場合には、そのプロジェクトのパスと定義をマニュアルで調整します。次の図は、Visual Studio のプロジェクトファイルをインポートした場合のスクリーンショットです。</para>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/gui-newproject-pathsanddefines.png"/>
        </imageobject>
      </mediaobject>
    </section>

    <section>
      <title>新しいプロジェクト（New Project） - プロジェクト（Project）</title>

      <para>プロジェクトタブ(Project tab)では、ビルドディレクトリ(<literal>Cppcheck build dir</literal>)を設定しましょう。これはCppcheckが様々な分析する情報を保管するために使用します。プログラム全体の解析、インクリメンタル解析、統計などです。それぞれのプロジェクトは、それぞれのビルドディレクトリを持ちます。次のスクリーンショットはビルドディレクトリを<literal>cppcheck-build-dir</literal>と設定しています。このパスはプロジェクトファイルからの相対パスです。</para>

      <para>あなたは、あなた使用する全てのライブラリーを選択すべきです。次のスクリーンショットではmicrosoft_sal と windowsライブラリーを選択しています。ライブラリーについてはこのマニュアルを参照してして下さい。</para>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/gui-newproject-project.png"/>
        </imageobject>
      </mediaobject>
    </section>

    <section>
      <title>新しいプロジェクト（New Project） - アドオン（Addons）</title>

      <para>ここでは 除外タブ(<literal>Exclude</literal>)と抑制タブ（<literal>Suppressions</literal>）をスキップします。これは結果をあとで微調整するために使います。</para>

      <para>アドオンタブ(Addons)であなたは別の分析を追加できます。このアドオンにはpythonが必要です。</para>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/gui-newproject-addons.png"/>
        </imageobject>
      </mediaobject>
    </section>

    <section>
      <title>解析(Analyze)</title>

      <para>ダイアログの<literal>OK</literal>ボタンをクリックします。解析がすぐに始まります。</para>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/gui-results.png"/>
        </imageobject>
      </mediaobject>

      <para>全ての警告が有効になり、やや賑やかになります。あなたが注意しない様々な警告があり得ます。これは簡単に修正できます。メッセージを右クリックして、隠す（<literal>Hide</literal>）または抑制（ <literal>Suppress</literal>）を選びます。メッセージの隠しは永久ではありません。これは次の解析でまた表示されます。メッセージの抑制は、永久です。抑制されたidはプロジェクトファイルに保存されるので、これらは二度と表示されません。</para>
    </section>
  </chapter>

  <chapter>
    <title>コマンドラインでの始め方</title>

    <section>
      <title>最初のテスト</title>

      <para>これは単純なソースコードです。</para>

      <programlisting>int main()
{
    char a[10];
    a[10] = 0;
    return 0;
}</programlisting>

      <para>このソースコードを<filename>file1.c</filename>に保存して次のコマンドを実行します。</para>

      <programlisting>cppcheck file1.c</programlisting>

      <para>cppcheck は次のように出力するでしょう。</para>

      <programlisting>Checking file1.c...
[file1.c:4]: (error) Array 'a[10]' index 10 out of bounds</programlisting>
    </section>

    <section>
      <title>フォルダ内の全てのファイルをチェックする</title>

      <para>通常、プログラムは多くのソースファイルから構成されます。そして、それら全てをチェックしたいでしょう。Cppcheck は一つのディレクトリ以下の全てのソースファイルをチェックできます。</para>

      <programlisting>cppcheck path</programlisting>

      <para>ここで&quot;path&quot;はディレクトリのパスです。このようにすれば cppcheck はディレクトリ以下の全てのファイルを再帰的にチェックします。</para>

      <programlisting>Checking path/file1.cpp...
1/2 files checked 50% done
Checking path/file2.cpp...
2/2 files checked 100% done</programlisting>
    </section>

    <section>
      <title>マニュアルでファイルをチェックまたはプロジェクトファイルの使用</title>

      <para>Cppcheckでは、ファイルやパスを指定する事でファイルチェックを指定できます。一方ででプロジェクトファイル(cmake/visual studio)を使用できます。</para>

      <para>プロジェクトファイルの使用は早急に始められます、というのもあなたが設定してする項目が少なくなるからです。</para>

      <para>マニュアルでのファイルチェックは、解析をより細かく制御できます。</para>

      <para>どちらのアプローチが良い結果になるかはわかりません。両方の方法を試して下さい。両方のアプローチを使用するとより多くののバグを見つけられる結果が得られるかもしれません。</para>

      <para>以降の章でより詳細を説明します。</para>
    </section>

    <section>
      <title>チェックからファイルやフォルダを除外する</title>

      <para>ファイルやフォルダをチェック対象から除外する方法は二つあります。最初の方法は、あなたがチェックしたいファイルやフォルダだけをcppcheckに指定することです。</para>

      <programlisting>cppcheck src/a src/b</programlisting>

      <para><filename class="directory">src/a</filename> と <filename class="directory">src/b</filename> 以下の全てのファイルだけをチェックします。</para>

      <para>第二の方法は、<parameter class="command">-i</parameter>オプションと共に除外したいファイルやフォルダを指定することです。次のコマンドでは<filename class="directory">src/c</filename>以下のファイルをチェックしません。</para>

      <programlisting>cppcheck -isrc/c src</programlisting>

      <para>このオプションは現在<parameter class="command">--project</parameter>オプションと同時に使用できません。また、このオプションが有効なのは、インプットディレクトリが提供するされたときです。複数のディレクトリを無視するためには、<parameter class="command">-i</parameter>を複数回使用します。次のコマンドではsrc/b と src/c 以下のファイルをチェックしません。</para>

      <programlisting>cppcheck -isrc/b -isrc/c</programlisting>
    </section>

    <section>
      <title>Severities(厳格度)</title>

      <para>メッセージのseverities(厳格度)には次のものがあります。:</para>

      <variablelist>
        <varlistentry>
          <term>error(エラー)</term>

          <listitem>
            <para>バグが検出されたときに使用します。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>warning(警告)</term>

          <listitem>
            <para>防衛的プログラミングでバグを避けるための提案です。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>style</term>

          <listitem>
            <para>コードの可読性の向上に関連した、スタイル関連の指摘(未使用関数、冗長なコードなど)</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>performance</term>

          <listitem>
            <para>コードの高速化のための提案。これらの提案は、一般的な知識に基づいたものでしかありません。このメッセージの修正によって計測できるほど処理速度が向上するかどうかはわかりません。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>portability</term>

          <listitem>
            <para>移植性についての警告。64 bit CPUへの移植性。コンパイラ依存(独自拡張)ソースコードについての警告など。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>information</term>

          <listitem>
            <para>設定上の問題設定を変更している間だけ有効にすることをお勧めします。</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section>
      <title>メッセージの表示</title>

      <para>デフォルトでは<parameter class="command">error</parameter>のメッセージだけを表示します。<parameter class="command">--enable</parameter>を使用すると他のチェックを有効にできます。</para>

      <programlisting># warning のメッセージを有効にします。
cppcheck --enable=warning file.c

# performanceのメッセージを有効にします。
cppcheck --enable=performance file.c

# informationのメッセージを有効にします。
cppcheck --enable=information file.c

# 歴史的な理由により --enable=style を指定すると warning, performance,
# portability と styleのメッセージを有効にします。古いxml形式を使用しているときには、これらの厳格度を&quot;style&quot;として報告されます。
cppcheck --enable=style file.c

# warning と performance のメッセージを有効にします。
cppcheck --enable=warning,performance file.c

# unusedFunction のチェックを有効にします。今回は --enable=styleでは有効にできない。
# というのは、これではライブラリではうまく動作しないからです。
cppcheck --enable=unusedFunction file.c

# 全てのメッセージを有効にします。
cppcheck --enable=all</programlisting>

      <para><literal>--enable=unusedFunction</literal>はプログラム全体をチェックするときにだけ有効にしてください。また、<literal>--enable=all</literal>もプログラム全体をチェックするときにだけ有効にしてください。というのは、unusedFunction チェックは、関数が呼び出されなかったときに警告するチェックだからです。関数呼び出しがチェック範囲にみつからなかったという可能性のノイズになります。</para>

      <section>
        <title>疑いのあるチェック</title>

        <para>Cppcheckはデフォルトで解析に疑いのない場合にだけエラーメッセージを表示します。しかし、<parameter class="command">--inconclusive</parameter>オプションを使用すると、解析に疑いのある場合であってもエラーメッセージを表示します。</para>

        <programlisting>cppcheck --inconclusive path</programlisting>

        <para>これは、もちろん、実際に問題がないものに対しても、警告することになります。このオプションは、疑いのある警告を表示してもよい場合に限り、使用してください。</para>
      </section>
    </section>

    <section>
      <title>結果をファイルに保存</title>

      <para>多くの場合、チェックの結果をファイルに保存したいと考えるでしょう。通常のシェルのリダイレクション機能を使って、エラー出力をファイルに保存することができます。</para>

      <programlisting>cppcheck file1.c 2&gt; err.txt</programlisting>
    </section>

    <section>
      <title>マルチスレッドチェック</title>

      <para>オプションの<literal>-j</literal> を使用してスレッド数を指定することができます。例えば、4スレッドを使ってフォルダ以下の全てのファイルをチェックする場合は次のように実行します。</para>

      <programlisting>cppcheck -j 4 path</programlisting>

      <para>このチェックでは未使用関数の検出(unusedFunction checking)は無効になることに注意してください。</para>
    </section>

    <section>
      <title>プラットフォーム</title>

      <para>あなたがターゲットとするプラットフォームの設定を使用すべきです。</para>

      <para>デフォルトで、Cppcheckはネイティブのプラットフォームの設定を使用しますので、あなたのソースコードがローカルの環境でコンパイルし実行する場合には正常に動作するでしょう。</para>

      <para>Cppcheck にはビルトインのプラットフォーム設定として、<literal>unix</literal>と<literal>windows</literal>をターゲットにしたものがあります。コマンドラインオプションの<literal>--platform</literal>を使ってプラットフォーム設定を指定できます。</para>

      <para>XMLファイルで自身のプラットフォームにあった設定ファイルを作成することもできます。ここに例をあげます。:</para>

      <programlisting>&lt;?xml version=&quot;1&quot;?&gt;
&lt;platform&gt;
  &lt;char_bit&gt;8&lt;/char_bit&gt;
  &lt;default-sign&gt;signed&lt;/default-sign&gt;
  &lt;sizeof&gt;
    &lt;short&gt;2&lt;/short&gt;
    &lt;int&gt;4&lt;/int&gt;
    &lt;long&gt;4&lt;/long&gt;
    &lt;long-long&gt;8&lt;/long-long&gt;
    &lt;float&gt;4&lt;/float&gt;
    &lt;double&gt;8&lt;/double&gt;
    &lt;long-double&gt;12&lt;/long-double&gt;
    &lt;pointer&gt;4&lt;/pointer&gt;
    &lt;size_t&gt;4&lt;/size_t&gt;
    &lt;wchar_t&gt;2&lt;/wchar_t&gt;
  &lt;/sizeof&gt;
&lt;/platform&gt;</programlisting>
    </section>
  </chapter>

  <chapter>
    <title>Project(プロジェクト)</title>

    <para>CMakeやVisual Studioを使っているとき、あなたは<literal>--project</literal>を使ってプロジェクトを解析できます。</para>

    <para>これでカンタンにチェックでき、結果も得られます。あなたに必要な設定項目はありません。しかしこれが最も良い結果を得る方法とは限りません。私たちは、このプロジェクトファイルを利用する方法と、<literal>--project</literal>を利用しない方法を試してよいオプションを選ぶようにお勧めします。</para>

    <section>
      <title>CMake</title>

      <para>Cppcheckはコンパイルデータベースを理解します。あなたはこれをCMakeで生成できます。</para>

      <para>例:</para>

      <programlisting>$ cmake -DCMAKE_EXPORT_COMPILE_COMMANDS=ON .</programlisting>

      <para><literal>compile_commands.json</literal>ファイルが現在のディレクトリに生成されます。</para>

      <para>それからCppcheckをこのように実行します。:</para>

      <programlisting>$ cppcheck --project=compile_commands.json</programlisting>
    </section>

    <section>
      <title>Visual Studio</title>

      <para>あなたは個々にのプロジェクトファイル(*.vcxproj)でCppcheckを実行できますし、ソルーション全体(*.sln)でも実行できます。</para>

      <programlisting># run cppcheck on a whole solution
$ cppcheck --project=foobar.sln

# run cppcheck on a individual project
$ cppcheck --project=foobar.vcxproj</programlisting>

      <para>Visual Studio内でcppcheckを実行するための、Visual Studioプラグインもあります。</para>
    </section>
  </chapter>

  <chapter id="preprocessor-configurations">
    <title>プリプロセッサの設定</title>

    <para>あなたが <literal>--project</literal>を使用した場合、Cppcheckはプロジェクトファイルからプリプロセッサーの設定を読み取ります。</para>

    <para>そうでなければ、あなたはインクルードパスやディレクティブを設定したくなるでしょう。</para>

    <section>
      <title>ディレクティブ</title>

      <para>ここに2つの設定があるファイルがあります(Aが定義された場合と定義されていない場合):</para>

      <programlisting>#ifdef A
    x = y;
#else
    x = z;
#endif</programlisting>

      <para>Cppcheckはデフォルトでプリプロセッサのデファインのコンパイルスイッチ設定の組み合わせを全てチェックします。(ただし、これらのうち #error を除く)そのため上のコードは、Aが定義された場合とAが定義されていない場合の両方を解析します。</para>

      <para>これを変更するには -D を使います。また -D を使用した場合、cppcheckは与えられたコンパイルスイッチだけが有効でその他は設定されていないとしてチェックします。これは、コンパイラのように動作します。また、 <literal>--force</literal> や <literal>--max-configs</literal> を使用すると、コンパイルスイッチの組み合わせの上限を上書きしてチェックすることができます。</para>

      <programlisting># 全てのコンパイルスイッチの組み合わせをチェックする。
cppcheck file.c

# Aのコンパイルスイッチが有効になっている場合の組み合わせをチェックする
cppcheck -DA file.c

# check all configurations when macro A is defined
cppcheck -DA --force file.c</programlisting>

      <para>また、もう一つのオプションに-U があります。これはシンボルのundefとなります。使用例:</para>

      <programlisting>cppcheck -UX file.c</programlisting>

      <para>これはXが定義されていないことを意味します。Cppcheck は Xが定義されている組み合わせをチェックしません。</para>
    </section>

    <section>
      <title>インクルードパス指定</title>

      <para>インクルードパスを追加するには<parameter class="command">-I</parameter>オプションに続けてパスを指定します。</para>

      <para>Cppcheckのプリプロセッサは基本的に他のプリプロセッサと同様にインクルードを扱います。しかし、その他のプリプロセッサはヘッダファイルが見つからない場合に停止するのとは違って、cppcheckはただ単に、メッセージ情報を表示してソースコードの解析を続けます。</para>

      <para>cppcheckは常にソースコード全体を確認する必要がないので、このような仕様になっています。実際に、全てのインクルードパスを与えないことを推奨しています。もちろん、クラスのメンバーの実装を確認した上でクラスの宣言をCppcheckでチェックするのは有用ではありますが、標準ライブラリのヘッダーをCppcheckに確認させるのは有用ではありません。というのは、チェックにかかる時間が長くなり、あまりよくない結果が表示されるからです。そのような場合、.cfg ファイル (後述します)によってcppcheckに関数や型の実装の情報を提供する方がよいでしょう。</para>
    </section>
  </chapter>

  <chapter>
    <title>XML出力</title>

    <para>Cppcheckは出力を<literal>XML</literal>形式に変更できます。<parameter>--xml</parameter>  オプションでフォーマットを指定します。</para>

    <para>ファイルをチェックし、<literal>XML</literal>形式で出力するコマンドのサンプルです。:</para>

    <programlisting>cppcheck --xml file1.cpp</programlisting>

    <para>これが出力例です。:</para>

    <programlisting>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;results version=&quot;2&quot;&gt;
  &lt;cppcheck version=&quot;1.66&quot;&gt;
  &lt;errors&gt;
    &lt;error id=&quot;someError&quot; severity=&quot;error&quot; msg=&quot;short error text&quot;
           verbose=&quot;long error text&quot; inconclusive=&quot;true&quot; cwe=&quot;312&quot;&gt;
      &lt;location file0=&quot;file.c&quot; file=&quot;file.h&quot; line=&quot;1&quot;/&gt;
    &lt;/error&gt;
  &lt;/errors&gt;
&lt;/results&gt;</programlisting>

    <section>
      <title>&lt;error&gt; 要素</title>

      <para>それぞれのエラーは<literal>&lt;error&gt;</literal>要素に記載されます。属性:</para>

      <variablelist>
        <varlistentry>
          <term><sgmltag class="attribute">id</sgmltag></term>

          <listitem>
            <para>エラーのidこれは、妥当なシンボル名です。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><sgmltag class="attribute">severity</sgmltag></term>

          <listitem>
            <para>以下のいずれかです: <literal>error</literal>, <literal>warning</literal>, <literal>style</literal>, <literal>performance</literal>, <literal>portability</literal>, <literal>information</literal></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><sgmltag class="attribute">msg</sgmltag></term>

          <listitem>
            <para>短い形式のエラーメッセージ</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><sgmltag>verbose</sgmltag></term>

          <listitem>
            <para>長い形式のエラーメッセージ</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><sgmltag>inconclusive</sgmltag></term>

          <listitem>
            <para>この属性は、メッセージに疑いのある場合にのみ使用されます。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><sgmltag>cwe</sgmltag></term>

          <listitem>
            <para>メッセージのCWE ID。この属性は、メッセージのCWE IDが判明している場合のみ使用されます。</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section>
      <title>&lt;location&gt;要素</title>

      <para>エラーに関連する全ての位置情報は<literal>&lt;location&gt;</literal> 要素内にリストアップされます。主要な位置は、リストの最初の要素になります。</para>

      <para>属性:</para>

      <variablelist>
        <varlistentry>
          <term><sgmltag class="attribute">file</sgmltag></term>

          <listitem>
            <para>ファイル名相対パスまたは絶対パスのどちらかです。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><sgmltag class="attribute">file0</sgmltag></term>

          <listitem>
            <para>ソースファイルの名前（オプション）</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><sgmltag class="attribute">line</sgmltag></term>

          <listitem>
            <para>数</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><sgmltag class="attribute">info</sgmltag></term>

          <listitem>
            <para>オプションの、それぞれの位置につiての短い情報</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
  </chapter>

  <chapter>
    <title>出力の形式の変更</title>

    <para>もし、テンプレートを使用して、出力の形式を変更することができます。</para>

    <section>
      <title>事前定義した出力フォーマット</title>

      <para>Visual Studioに互換性のある形式が必要な場合には、<parameter class="command">--template=vs</parameter>を使用します。</para>

      <programlisting>cppcheck --template=vs samples/arrayIndexOutOfBounds/bad.c</programlisting>

      <para>このオプションは出力形式を次のように変更します。:</para>

      <programlisting>Checking samples/arrayIndexOutOfBounds/bad.c ...
samples/arrayIndexOutOfBounds/bad.c(6): error: Array 'a[2]' accessed at index 2, which is out of bounds.</programlisting>

      <para><literal>gcc</literal>に互換性のある出力が必要な場合には、<parameter class="command">--template=gcc</parameter>を使用します。:</para>

      <programlisting>cppcheck --template=gcc samples/arrayIndexOutOfBounds/bad.c</programlisting>

      <para>このオプションは出力形式を次のように変更します。:</para>

      <programlisting>Checking samples/arrayIndexOutOfBounds/bad.c ...
samples/arrayIndexOutOfBounds/bad.c:6:6: warning: Array 'a[2]' accessed at index 2, which is out of bounds. [arrayIndexOutOfBounds]
    a[2] = 0;
     ^</programlisting>
    </section>

    <section>
      <title>ユーザー定義出力形式(1行)</title>

      <para>自分で自身でパターンを作成できます。例えば古い<literal>gcc</literal> のよuな出力フォーマットで警告メッセージを出力してほしい場合次のように指定します。:</para>

      <programlisting>cppcheck --template=&quot;{file}:{line}: {severity}: {message}&quot; samples/arrayIndexOutOfBounds/bad.c</programlisting>

      <para>このオプションは出力形式を次のように変更します。:</para>

      <programlisting>Checking samples/arrayIndexOutOfBounds/bad.c ...
samples/arrayIndexOutOfBounds/bad.c:6: error: Array 'a[2]' accessed at index 2, which is out of bounds.</programlisting>

      <para>コンマ区切りフォーマット:</para>

      <programlisting>cppcheck --template=&quot;{file},{line},{severity},{id},{message}&quot; samples/arrayIndexOutOfBounds/bad.c</programlisting>

      <para>このオプションは出力形式を次のように変更します。:</para>

      <programlisting>Checking samples/arrayIndexOutOfBounds/bad.c ...
samples/arrayIndexOutOfBounds/bad.c,6,error,arrayIndexOutOfBounds,Array 'a[2]' accessed at index 2, which is out of bounds.</programlisting>
    </section>

    <section>
      <title>ユーザー定義出力形式(複数行)</title>

      <para>多くの警告は、複数の位置を指定します。サンプルコード:</para>

      <programlisting>void f(int *p)
{
    *p = 3;       // line 3
}

int main()
{
    int *p = 0;   // line 8
    f(p);         // line 9
    return 0;
}</programlisting>

      <para>3行目でヌルポインタのデリファレンスの可能性があります。Cppcheckは追加の位置情報を表示してその結論がどこから発生したかを示すことができます。そのためには、コマンドラインで<literal>--template</literal> と <literal>--template-location</literal>の両方を使用する必要があります。</para>

      <para>サンプルコマンド:</para>

      <programlisting>cppcheck --template=&quot;{file}:{line}: {severity}: {message}\n{code}&quot; --template-location=&quot;{file}:{line}: note: {info}\n{code}&quot; multiline.c</programlisting>

      <para>cppcheck は次のように出力します。</para>

      <programlisting>Checking multiline.c ...
multiline.c:3: warning: Possible null pointer dereference: p
    *p = 3;
     ^
multiline.c:8: note: Assignment 'p=0', assigned value is 0
    int *p = 0;
             ^
multiline.c:9: note: Calling function 'f', 1st argument 'p' value is 0
    f(p);
      ^
multiline.c:3: note: Null pointer dereference
    *p = 3;
     ^</programlisting>

      <para>この警告の最初の行は<literal>--template</literal> で指定したフォーマットです。</para>

      <para>この警告の残りの行は<literal>--template-location</literal>で指定したフォーマットです。</para>
    </section>

    <section>
      <title>--templateで指定するフォーマット</title>

      <para><literal>--template</literal> では以下の要素が利用できます。:</para>

      <variablelist>
        <varlistentry>
          <term>{file}</term>

          <listitem>
            <para>ファイル名</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>{line}</term>

          <listitem>
            <para>行数</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>{column}</term>

          <listitem>
            <para>カラム番号</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>{callstack}</term>

          <listitem>
            <para>全ての位置。それぞれの位置は[{file}:{line}]のフォーマットで記載され、また-&gt;で位置を区切ります。例えば次のようになります。: [multiline.c:8] -&gt; [multiline.c:9] -&gt; [multiline.c:3]</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>{inconclusive:text}</term>

          <listitem>
            <para>警告が確定的でない場合のメッセージを表示します。このメッセージは含まれていない場合もある、任意のテキストです。サンプル: {inconclusive:inconclusive,}</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>{severity}</term>

          <listitem>
            <para>エラー/警告/スタイル/性能/移植性/情報</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>{message}</term>

          <listitem>
            <para>警告メッセージ</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>{id}</term>

          <listitem>
            <para>警告id</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>{code}</term>

          <listitem>
            <para>実際のコード</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>\t</term>

          <listitem>
            <para>タブ</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>\n</term>

          <listitem>
            <para>改行</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>\r</term>

          <listitem>
            <para>キャリッジリターン</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section>
      <title>--template-location で指定するフォーマット</title>

      <para><literal>--template-location</literal>では以下の要素が利用できます。:</para>

      <variablelist>
        <varlistentry>
          <term>{file}</term>

          <listitem>
            <para>ファイル名</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>{line}</term>

          <listitem>
            <para>行数</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>{column}</term>

          <listitem>
            <para>カラム番号</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>{info}</term>

          <listitem>
            <para>現在位置についての情報メッセージ</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>{code}</term>

          <listitem>
            <para>実際のコード</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>\t</term>

          <listitem>
            <para>タブ</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>\t</term>

          <listitem>
            <para>改行</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>\r</term>

          <listitem>
            <para>キャリッジリターン</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
  </chapter>

  <chapter>
    <title>Misra</title>

    <para>Cppcheckは<literal>MISRA</literal> C 2012 向けのチェッカのアドオンを持っています。</para>

    <section>
      <title>要求事項</title>

      <para>必要なもの:</para>

      <itemizedlist>
        <listitem>
          <para>Python (2系 または 3系)</para>
        </listitem>

        <listitem>
          <para><literal>MISRA C 2012</literal>の PDFこのPDFは<uri>http://www.misra.org.uk</uri>で購入できます (15-20 ポンド)</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>MISRA テキストファイル</title>

      <para><literal>MISRA</literal>ルールテキストの公開は禁止されています。そのため<literal>MISRA</literal>ルールテキストはこのアドオンから直接利用できません。代わりにこのアドオンはテキストファイルからルールのテキストを読み込みます。MISRA PDFの ”Appendix A Summary of guidelines&quot;のテキストをコピーペーストした場合、それがルールのテキストになります。</para>

      <para>もしあなたが<literal>xpdf</literal>を持っているなら、テキストファイルはコマンドラインから簡単に生成できます。 (<literal>pdftotext</literal> は<literal>xpdf</literal>に含まれています。):</para>

      <programlisting>pdftotext misra-c-2012.pdf output.txt</programlisting>

      <para>この出力は100%完璧であるとは限りません。少し手直しする必要があることもあります。</para>

      <para>その他のpdfからtextに変換するソフトでもうまくいくでしょう。</para>

      <para>テキストファイルをマニュアルで作成してするには、MISRA PDFの Appendix A &quot;Summary of guidelines&quot; をコピーペーストします。フォーマット:</para>

      <programlisting>Appendix A Summary of guidelines
Rule 1.1
Rule text
Rule 1.2
Rule text
...</programlisting>

      <para>あなたが無効にしたいルールは、ルールテキストがなくても構いません。ルールテキストのないルールはアドオンによって抑制されます。</para>
    </section>
  </chapter>

  <chapter>
    <title>出力の抑制</title>

    <para>ある種のエラーをフィルタリングしたい場合、出力を抑制することができます。</para>

    <section>
      <title>プレーンテキスト抑制</title>

      <para>エラーの種類によって出力を抑制することができます。つぎのいずれかの形式で出力を抑制します。:</para>

      <programlisting>[error id]:[filename]:[line]
[error id]:[filename2]
[error id]</programlisting>

      <para>この<replaceable>error id</replaceable> は抑制したいエラーのidです。このエラーのIDを簡単に調べるには、<parameter class="command">--xml</parameter>オプションをコマンドラインで与えます。そのXML出力から、<replaceable>id</replaceable>の文字列が取得できます。このエラーのIDに<literal>*</literal>を指定して全ての種類のメッセージを抑制することができます。(これは指定したファイルに限ることができます。)</para>

      <para>また<replaceable>filename</replaceable>にはワイルドキャラクターである、<literal>*</literal> または <literal>?</literal>を含めることができます。前者には全ての文字列にマッチし、後者は任意の一文字にマッチします。またWindowsを含む全てのOSで、パス区切りに&quot;/&quot; を使うことをお勧めします。</para>

      <section>
        <title>コマンドライン抑制</title>

        <para><parameter class="command">--suppress=</parameter>のコマンドラインオプションを使用して、コマンドラインで抑制を指定することができます。例:</para>

        <programlisting>cppcheck --suppress=memleak:src/file1.cpp src/</programlisting>
      </section>

      <section>
        <title>ファイルで抑制リストを指定</title>

        <para>また、抑制ファイルを作成することもできます。例:</para>

        <programlisting>// src/file1.cppのmemleak と exceptNew の エラーを抑制
memleak:src/file1.cpp
exceptNew:src/file1.cpp

// 全てのファイルのuninitvarエラーを抑制する。
uninitvar</programlisting>

        <para>空行やコメント行を抑制ファイルに記載することができます。</para>

        <para>そして、この抑制ファイルは次のようにして使用します。:</para>

        <programlisting>cppcheck --suppressions-list=suppressions.txt src/</programlisting>
      </section>
    </section>

    <section>
      <title>XML 抑制</title>

      <para>XMLファイルで抑制を指定できます。サンプルファイル:</para>

      <programlisting>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;suppressions&gt;
  &lt;suppression&gt;
    &lt;id&gt;uninitvar&lt;/id&gt;
    &lt;fileName&gt;src/file1.c&lt;/fileName&gt;
    &lt;lineNumber&gt;10&lt;/lineNumber&gt;
    &lt;symbolName&gt;var&lt;/symbolName&gt;
  &lt;/suppression&gt;
&lt;/suppressions&gt;</programlisting>

      <para>このXMLフォーマットは拡張可能であり、将来さらなる属性を加えるかもしれません。</para>
    </section>

    <section>
      <title>インライン出力抑制</title>

      <para>エラー出力の抑制をソースコード中に直接、コメントの形で記載することもできます。このコメントには特別なキーワードを含めて記載します。ただし、インライン出力を抑制するコメントをソースコードに追加すると、ソースコードの可読性が少し悪くなってしまうかもしれません。</para>

      <para>このソースコードは通常エラメッセージを出力する例です。:</para>

      <programlisting>void f() {
    char arr[5];
    arr[10] = 0;
}</programlisting>

      <para>前のソースコードに対する出力は次のようになります。:</para>

      <programlisting># cppcheck test.c
Checking test.c...
[test.c:3]: (error) Array 'arr[5]' index 10 out of bounds</programlisting>

      <para>このエラーメッセージを抑制するには次のようなコメントを追加します。:</para>

      <programlisting>void f() {
    char arr[5];

    // cppcheck-suppress arrayIndexOutOfBounds
    arr[10] = 0;
}</programlisting>

      <para>これで、--inline-suppr オプションの準備ができました。次のようにcppcheckを起動するとエラーが抑制されます。:</para>

      <programlisting>cppcheck --inline-suppr test.c</programlisting>

      <para>特定のシンボルにのみ適用するインライン抑制を指定できます。:</para>

      <programlisting>// cppcheck-suppress arrayIndexOutOfBounds symbolName=arr</programlisting>

      <para>抑制のためにコメントを書きます。; や // を使って開始点を指定できます。</para>

      <programlisting>// cppcheck-suppress arrayIndexOutOfBounds ; some comment
// cppcheck-suppress arrayIndexOutOfBounds // some comment</programlisting>
    </section>
  </chapter>

  <chapter>
    <title>ライブラリ設定</title>

    <para>WinAPI, POSIX, gtk, Qtなど他の外部のライブラリを使用した場合、<literal>Cppcheck</literal>は外部の関数がどのようなものであるかがわかりません。<literal>Cppcheck</literal> はそのため、メモリリークやバッファオーバーフロー、ヌルポインタのデリファレンスの可能性といったさまざまな問題が検出できません。これを解決するには設定ファイル(.cfg file)を使用します。</para>

    <para>Cppcheckはいくつかのライブラリ用の設定を持っています。これらは次のようにしてロードできます。cppcheckは C または C++言語用の標準ライブラリの設定 <literal>std.cfg</literal>はいつもロードします。ご注意ください。もしあなたが有名なライブラリの設定ファイルを作成した場合や更新した場合には、私達のサイトにアップロードしてくれると非常に助かります。</para>

    <section>
      <title>カスタム設定ファイル(.cfg file)の使用</title>

      <para>あなたのプロジェクト専用の設定ファイルを作成し、使用することができます。そのためには、<literal>--check-library</literal> と<literal>--enable=information</literal> を使用して設定のためのヒントを入手します。</para>

      <para>設定ファイルの編集に、<literal>Library Editor</literal>の使用をお勧めします、これは<literal>Cppcheck GUI</literal>に含まれています。これは<literal>View</literal>メニューで使用できます。すべての設定がこのマニュアルに載っていません。</para>

      <para>この設定ファイル<literal>.cfg</literal>のフォーマットに質問がある場合、フォーラム(http://sourceforge.net/p/cppcheck/discussion/)で質問してください。</para>

      <para>コマンドラインのcppcheck はカスタマイズした設定ファイル(.cfg files)を作業パスから読み込もうとします。作業パスはcppcheckを実行しているパスですでそこに設定ファイルがあると考えます。</para>

      <para>GUIのcppcheckはプロジェクトのファイルパスから設定ファイルを読み込もうとします。カスタマイズした設定ファイル(.cfg file)は <literal>プロジェクトファイルの編集</literal> ダイアログで確認できます。このタイアログを表示させるには<literal>ファイル</literal> メニューから開いてください。</para>
    </section>

    <section>
      <title>メモリーリソースのリーク</title>

      <para>Cppcheck はリークのチェックが調整できます。言い換えれば、あなたはメモリーやリソースを割り当てる関数またはその割り当てを回収する関数を指定できます。</para>

      <section>
        <title>alloc と dealloc</title>

        <para>ここにサンプルのプログラムがあります。:</para>

        <para><programlisting>void test()
{
    HPEN pen = CreatePen(PS_SOLID, 1, RGB(255,0,0));
}</programlisting></para>

        <para>上のコード例はリソースリークの欠陥があります。 - <literal>CreatePen()</literal> は WinAPI 関数でpenを作成します。しかし、Cppcheckは関数からの返り値が解放されていなければならないと仮定しません。そのためエラーメッセージは表示されません。:</para>

        <programlisting># cppcheck pen1.c
Checking pen1.c...</programlisting>

        <para>もしあなたが設定ファイルを与えれば、<literal>Cppcheck</literal>はバグを検出します。:</para>

        <programlisting># cppcheck --library=windows.cfg pen1.c
Checking pen1.c...
[pen1.c:3]: (error) Resource leak: pen</programlisting>

        <para>これが最小限の<literal>windows.cfg</literal> ファイルです:</para>

        <programlisting>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;def&gt;
  &lt;resource&gt;
    &lt;alloc&gt;CreatePen&lt;/alloc&gt;
    &lt;dealloc&gt;DeleteObject&lt;/dealloc&gt;
  &lt;/resource&gt;
&lt;/def&gt;</programlisting>

        <para>このアロケート関数とデアロケート関数はグループにまとめられています。それぞれのグループは<literal>&lt;resource&gt;</literal> や <literal>&lt;memory&gt;</literal> タグ中で定義されており、その<literal>&lt;dealloc&gt;</literal>関数によって特定されます。これは、<literal>&lt;dealloc&gt;</literal>タグでオーバーラップしたグループはマージされます。</para>
      </section>

      <section>
        <title>leak-ignore とuse</title>

        <para>しばしば、割り当てられたポインタを関数に渡すことがあります。例:</para>

        <programlisting>void test()
{
    char *p = malloc(100);
    dostuff(p);
}</programlisting>

        <para>もし設定ファイルがなく、Cppcheckが<literal>dostuff</literal>の仕様を把握していなければ、Cppcheckは<literal>dostuff</literal>がメモリーについて配慮しており、メモリーリークは発生しないと仮定します。</para>

        <para><literal>dostuff</literal>がメモリーについて配慮せず、解放などを行なっていないことを指定するためには、<literal>leak-ignore</literal>を<literal>&lt;function&gt;</literal> タグ中で使います。:</para>

        <programlisting>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;def&gt;
  &lt;function name=&quot;dostuff&quot;&gt;
    &lt;leak-ignore/&gt;
    &lt;arg nr=&quot;1&quot;/&gt;
  &lt;/function&gt;
&lt;/def&gt;</programlisting>

        <para>これとは逆に<literal>dostuff</literal>がメモリーについて配慮している場合には次のように設定します。:</para>

        <programlisting>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;def&gt;
  &lt;memory&gt;
    &lt;dealloc&gt;free&lt;/dealloc&gt;
    &lt;use&gt;dostuff&lt;/use&gt;
  &lt;/memory&gt;
&lt;/def&gt;</programlisting>

        <para>なお、この<literal>&lt;use&gt;</literal>の設定は論理的に全く無意味です。この設定がない場合でも同じエラーが表示されます。これは<literal>--check-library</literal>のinformationメッセージを減らすために使用します。</para>
      </section>
    </section>

    <section>
      <title>関数の動作</title>

      <para>関数の動作や関数の使用方法を指定するのに、<literal>&lt;function&gt;</literal>タグが使えます。関数は、その名前によって特定されます。この名前は、<literal>name</literal> 属性とその引数によって指定されます。この名前はコンマで区切られた関数名のリストです。名前空間やクラス中の関数の場合には、完全修飾名で指定されます。例: <literal>&lt;function name=&quot;memcpy,std::memcpy&quot;&gt;</literal>もしテンプレート関数がある場合、インスタンス化した名前を提供してします。<literal>&lt;function name=&quot;dostuff&lt;int&gt;&quot;&gt;</literal>.</para>

      <section>
        <title>関数引き数</title>

        <para>関数がとる引数は、<literal>&lt;arg&gt;</literal>タグで指定できます。引数のそれぞれは、引数の順番（1始まり）を<literal>nr</literal>属性で示します。<literal>nr=&quot;any&quot;</literal> は任意の引き数を表します。また、<literal>nr=&quot;variadic&quot;</literal>は可変長引数を表します。オプション引数は、デフォルト値で指定します。: <literal>default=&quot;value&quot;</literal>. それぞれの引数に対する設定は、全ての引数に対する指定を上書きします。</para>

        <section>
          <title>非ブール</title>

          <para>ここで誤った比較のあるサンプルプログラムがあります。:</para>

          <programlisting>void test()
{
    if (MemCmp(buffer1, buffer2, 1024==0)) {}
}</programlisting>

          <para><literal>Cppcheck</literal>は、この関数にブール値を渡してよいと仮定します。:</para>

          <programlisting># cppcheck notbool.c
Checking notbool.c...</programlisting>

          <para>もしあなたが設定ファイルを与えれば、Cppcheckはバグを検出します。:</para>

          <programlisting># cppcheck --library=notbool.cfg notbool.c
Checking notbool.c...
[notbool.c:5]: (error) Invalid MemCmp() argument nr 3. 非ブール値が求められています。</programlisting>

          <para>ここで最小のnotbool.cfgを用意しました。</para>

          <para><programlisting>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;def&gt;
  &lt;function name=&quot;MemCmp&quot;&gt;
    &lt;arg nr=&quot;1&quot;/&gt;
    &lt;arg nr=&quot;2&quot;/&gt;
    &lt;arg nr=&quot;3&quot;&gt;
      &lt;not-bool/&gt;
    &lt;/arg&gt;
  &lt;/function&gt;
&lt;/def&gt;</programlisting></para>
        </section>

        <section>
          <title>未初期化メモリ</title>

          <para>ここにサンプルのプログラムがあります。:</para>

          <programlisting>void test()
{
    char buffer1[1024];
    char buffer2[1024];
    CopyMemory(buffer1, buffer2, 1024);
}</programlisting>

          <para>このプログラムのバグは buffer2 が初期化されていないことです。CopyMemory 関数の第二引数は初期化されている必要があります。しかし、<literal>Cppcheck</literal>は関数に未初期化の変数を渡してもよいと仮定しています。:</para>

          <programlisting># cppcheck uninit.c
Checking uninit.c...</programlisting>

          <para>もしあなたが設定ファイルを与えれば、Cppcheckはバグを検出します。:</para>

          <programlisting># cppcheck --library=windows.cfg uninit.c
Checking uninit.c...
[uninit.c:5]: (error) Uninitialized variable: buffer2</programlisting>

          <para>注意:これは、ポインタが示すメモリ領域が初期化されていなければならないことを意味しています。</para>

          <para>これが最小限の<literal>windows.cfg</literal>ファイルです。:</para>

          <para><programlisting>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;def&gt;
  &lt;function name=&quot;CopyMemory&quot;&gt;
    &lt;arg nr=&quot;1&quot;/&gt;
    &lt;arg nr=&quot;2&quot;&gt;
      &lt;not-uninit/&gt;
    &lt;/arg&gt;
    &lt;arg nr=&quot;3&quot;/&gt;
  &lt;/function&gt;
&lt;/def&gt;</programlisting></para>
        </section>

        <section>
          <title>ヌルポインタ</title>

          <para>Cppcheckは、関数にヌルポインタを渡してもよいと仮定しています。ここにサンプルのプログラムがあります。:</para>

          <programlisting>void test()
{
    CopyMemory(NULL, NULL, 1024);
}</programlisting>

          <para>MSDNの文書はこれが問題あるかないかを明らかにしていません。しかし、ここでは問題ありと仮定します。Cppcheck は関数にヌルポインタを渡してもよいと仮定していますので、エラーを出力しません。:</para>

          <programlisting># cppcheck null.c
Checking null.c...</programlisting>

          <para>もしあなたが設定ファイルを与えれば、<literal>Cppcheck</literal>はバグを検出します。:</para>

          <programlisting>cppcheck --library=windows.cfg null.c
Checking null.c...
[null.c:3]: (error) Null pointer dereference</programlisting>

          <para>注意:<literal>&lt;not-uninit&gt;</literal>は値について意味しています。初期化されていないメモリが関数に渡されています。</para>

          <para>これが最小限の<literal>windows.cfg</literal> ファイルです:</para>

          <programlisting>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;def&gt;
  &lt;function name=&quot;CopyMemory&quot;&gt;
    &lt;arg nr=&quot;1&quot;&gt;
      &lt;not-null/&gt;
    &lt;/arg&gt;
    &lt;arg nr=&quot;2&quot;/&gt;
    &lt;arg nr=&quot;3&quot;/&gt;
  &lt;/function&gt;
&lt;/def&gt;</programlisting>
        </section>

        <section>
          <title>フォーマット文字列</title>

          <para>フォーマット文字列を扱う関数を定義できます。例:</para>

          <programlisting>void test()
{
    do_something(&quot;%i %i\n&quot;, 1024);
}</programlisting>

          <para>これについてもエラーは報告されません。:</para>

          <programlisting># cppcheck formatstring.c
    Checking formatstring.c...</programlisting>

          <para>引数がフォーマット文字列であることを出力する設定ファイルが作成できます。設定ファイルの例です。:</para>

          <para><programlisting>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;def&gt;
  &lt;function name=&quot;do_something&quot;&gt;
    &lt;formatstr type=&quot;printf&quot;/&gt;
    &lt;arg nr=&quot;1&quot;&gt;
      &lt;formatstr/&gt;
    &lt;/arg&gt;
  &lt;/function&gt;
&lt;/def&gt;</programlisting>これで、Cppcheckはエラーを報告できるようになりました。:</para>

          <programlisting>cppcheck --library=test.cfg formatstring.c
Checking formatstring.c...
[formatstring.c:3]: (error) do_something format string requires 2 parameters but only 1 is given.</programlisting>

          <para>このフォーマット文字列の<literal>type</literal>属性は次のどちらかになります。:</para>

          <itemizedlist>
            <listitem>
              <para>printf - printf のルールに従うフォーマット文字列</para>
            </listitem>

            <listitem>
              <para>scanf - scanf のルールに従うフォーマット文字列</para>
            </listitem>
          </itemizedlist>
        </section>

        <section>
          <title>値の範囲</title>

          <para>有効な値の範囲が定義できます。想像してください。:</para>

          <programlisting>void test()
{
    do_something(1024);
}</programlisting>

          <para>これについてもエラーは報告されません。:</para>

          <programlisting># cppcheck valuerange.c
Checking valuerange.c...</programlisting>

          <para>1024 が 範囲外の値であることを出力する設定ファイルが作成できます。設定ファイルの例です。:</para>

          <para><programlisting>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;def&gt;
  &lt;function name=&quot;do_something&quot;&gt;
    &lt;arg nr=&quot;1&quot;&gt;
      &lt;valid&gt;0:1023&lt;/valid&gt;
    &lt;/arg&gt;
  &lt;/function&gt;
&lt;/def&gt;</programlisting>これで、Cppcheckはエラーを報告できるようになりました。:</para>

          <programlisting>cppcheck --library=test.cfg range.c
Checking range.c...
[range.c:3]: (error) Invalid do_something() argument nr 1. この値は1024ですが、妥当な値は0から1023までです。</programlisting>

          <para>validの要素で次のような表現が利用できます。:</para>

          <programlisting>0,3,5  =&gt; 0, 3 それに 5 だけが有効な値です。
-10:20  =&gt;  -10 から 20 までの値(両端含む)が有効な値です。
:0  =&gt;  0または0未満の値が有効な値です。
0:  =&gt;  0または0以上の値が有効な値です。
0,2:32  =&gt;  0 または2から32までの値(両端含む)が有効な値です。
-1.5:5.6  =&gt;  -1.5 から 5.6 までの値(両端含む)が有効な値です。 </programlisting>
        </section>

        <section>
          <title>最小サイズ</title>

          <para>いくつかの関数はバッファーを引数にとります。バッファの最小サイズを指定することができます。(要素数ではなくバイト数です。)想像してください。:</para>

          <programlisting>void test()
{
    char str[5];
    do_something(str,&quot;12345&quot;);
}</programlisting>

          <para>これについてもエラーは報告されません。:</para>

          <programlisting># cppcheck minsize.c
Checking minsize.c...</programlisting>

          <para>設定ファイルで、例えば、引数1のバッファのサイズが引数2の文字列長より大きくなればならないと警告するような設定ファイルを作成できます。例を挙げます。:</para>

          <para><programlisting>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;def&gt;
  &lt;function name=&quot;do_something&quot;&gt;
    &lt;arg nr=&quot;1&quot;&gt;
      &lt;minsize type=&quot;strlen&quot; arg=&quot;2&quot;/&gt;
    &lt;/arg&gt;
    &lt;arg nr=&quot;2&quot;/&gt;
  &lt;/function&gt;
&lt;/def&gt;</programlisting>これで、Cppcheckはこのエラーを報告できるようになりました。:</para>

          <programlisting>cppcheck --library=1.cfg minsize.c
Checking minsize.c...
[minsize.c:4]: (error) Buffer is accessed out of bounds: str
</programlisting>

          <para>minsizes はいくつかの種類があります。:</para>

          <variablelist>
            <varlistentry>
              <term>strlen</term>

              <listitem>
                <para>バッファーのサイズが、その他の引数の文字列長より大きくなければなりません。例: std.cfg のstrcpyの設定を参照してください。</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>argvalue</term>

              <listitem>
                <para>バッファーのサイズがその他の引数の値より大きくなればなりません。例: std.cfg のmemsetの設定を参照してください。</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>sizeof</term>

              <listitem>
                <para>バッファーのサイズがその他の引数のバッファーのサイズより大きくなればなりません。例：posix.cfgのmemccpyの設定をみてください。</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>mul</term>

              <listitem>
                <para>バッファーのサイズがその他の2つの引数の値の積より大きくなればなりません。典型的な使用例としては、一つの引数が構造体などの要素のサイズを指定し、もうひとつの引数が要素の個数を定義するような場合です。例: std.cfg のfreadの設定を参照してください</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </section>

        <section>
          <title>strz</title>

          <para>これを指定すると、数が0終端文字列でなければならないということができます。</para>

          <para><programlisting>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;def&gt;
  &lt;function name=&quot;do_something&quot;&gt;
    &lt;arg nr=&quot;1&quot;&gt;
      &lt;strz/&gt;
    &lt;/arg&gt;
  &lt;/function&gt;
&lt;/def&gt;</programlisting></para>
        </section>
      </section>

      <section>
        <title>noreturn</title>

        <para>Cppcheck はこの関数がいつも値を返すとは仮定していません。ここにサンプルのプログラムがあります。:</para>

        <programlisting>void test(int x)
{
    int data, buffer[1024];
    if (x == 1)
        data = 123;
    else
        ZeroMemory(buffer, sizeof(buffer));
    buffer[0] = data;  // &lt;- error: xが1でないとき初期化されていない
}</programlisting>

        <para>理屈の上では、<literal>ZeroMemory</literal>がプログラムを終了させてもバグはありません。そのため Cppcheckはエラーを報告しません。:</para>

        <programlisting># cppcheck noreturn.c
Checking noreturn.c...</programlisting>

        <para>しかし、<literal>--check-library</literal> と<literal>--enable=information</literal>をつかうとエラーが出力されます。:</para>

        <programlisting># cppcheck --check-library --enable=information noreturn.c
Checking noreturn.c...
[noreturn.c:7]: (information) --check-library: Function ZeroMemory() should have &lt;noreturn&gt; configuration
</programlisting>

        <para>もし適切な <literal>windows.cfg</literal> が提供されていましたら、このバグは検出されます。:</para>

        <programlisting># cppcheck --library=windows.cfg noreturn.c
Checking noreturn.c...
[noreturn.c:8]: (error) Uninitialized variable: data</programlisting>

        <para>これが最小限の<literal>windows.cfg</literal> ファイルです:</para>

        <programlisting>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;def&gt;
  &lt;function name=&quot;ZeroMemory&quot;&gt;
    &lt;noreturn&gt;false&lt;/noreturn&gt;
    &lt;arg nr=&quot;1&quot;/&gt;
    &lt;arg nr=&quot;2&quot;/&gt;
  &lt;/function&gt;
&lt;/def&gt;</programlisting>
      </section>

      <section>
        <title>use-retval</title>

        <para>他になにも指定されていない限り、cppcheckは関数が返り値を無視していても問題ないと仮定します。:</para>

        <programlisting>bool test(const char* a, const char* b)
{
    strcmp(a, b);  // &lt;- bug: strcmp の呼び出しは副作用を持ちませんが返り値を無視している。
    return true;
}</programlisting>

        <para><literal>strcmp</literal> が副作用を持つ場合、パラメータが関数に渡されている結果を無視しても問題はなく、このような仮定は正しいといえます。:</para>

        <programlisting># cppcheck useretval.c
Checking useretval.c...</programlisting>

        <para>もし適切な<literal>lib.cfg</literal> が提供されていましたら、このバグは検出されます。:</para>

        <programlisting># cppcheck --library=lib.cfg --enable=warning useretval.c
Checking useretval.c...
[useretval.c:3]: (warning) Return value of function strcmp() is not used.</programlisting>

        <para>これが最小限の<literal>lib.cfg</literal> ファイルです。:</para>

        <programlisting>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;def&gt;
  &lt;function name=&quot;strcmp&quot;&gt;
    &lt;use-retval/&gt;
    &lt;arg nr=&quot;1&quot;/&gt;
    &lt;arg nr=&quot;2&quot;/&gt;
  &lt;/function&gt;
&lt;/def&gt;</programlisting>
      </section>

      <section>
        <title>pure関数(pure)とconst関数</title>

        <para>これらは、GCC関数属性のpureとconstに対応します。</para>

        <para>pure関数は、値を返す以外の効果を持ちません。そしてその返り値はその関数の引数とグローバル変数によってのみ決まります。</para>

        <para>const関数は、値を返す以外の効果を持ちません。そしてその返り値はその関数の引数によってのみ決まります。</para>

        <para>ここにサンプルのプログラムがあります。:</para>

        <programlisting>void f(int x)
{
    if (calculate(x) == 213) {
    
    } else if (calculate(x) == 213) {
         // 到達不能コード
    }
}</programlisting>

        <para>もし<literal>calculate()</literal> がconst関数であれば、<literal>calculate(x)</literal>は両方の条件で同じ値を返します。というのも、同じパラメータを引数にしているからです。</para>

        <para>Cppcheck は通常、その結果が異なると仮定するため、Cppcheckはこのコード例に警告を出しません。:</para>

        <programlisting># cppcheck const.c
Checking const.c...</programlisting>

        <para>もし適切な<literal>const.cfg</literal> が提供されていましたら、このバグは検出されます。:</para>

        <programlisting># cppcheck --enable=style --library=const const.c 
Checking const.c...
[const.c:7]: (style) Expression is always false because 'else if' condition matches previous condition at line 5.</programlisting>

        <para>これが最小限の<literal>const.cfg</literal> ファイルです。:</para>

        <programlisting>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;def&gt;
  &lt;function name=&quot;calculate&quot;&gt;
    &lt;const/&gt;
    &lt;arg nr=&quot;1&quot;/&gt;
  &lt;/function&gt;
&lt;/def&gt;</programlisting>
      </section>

      <section>
        <title>関数strcpyの設定例</title>

        <para>標準関数のstrcpyのための適切な設定は次のようになる。:</para>

        <programlisting>  &lt;function name=&quot;strcpy&quot;&gt;
    &lt;leak-ignore/&gt;
    &lt;noreturn&gt;false&lt;/noreturn&gt;
    &lt;arg nr=&quot;1&quot;&gt;
      &lt;not-null/&gt;
    &lt;/arg&gt;
    &lt;arg nr=&quot;2&quot;&gt;
      &lt;not-null/&gt;
      &lt;not-uninit/&gt;
      &lt;strz/&gt;
    &lt;/arg&gt;
  &lt;/function&gt;</programlisting>

        <para>この<literal>&lt;leak-ignore/&gt;</literal> は、リークチェック中に関数呼び出しを無視するように、Cppcheckに伝えます。この関数は、割り当てられたメモリを解放しないことを意味しています。</para>

        <para>この<literal>&lt;noreturn&gt;</literal> は、この関数が、返り値を返すかどうかをCppchecに伝えます。</para>

        <para>この関数は第一引数にポインタを取ります。しかしこのポインタは、ヌルポインタであってはなりません。というのは<literal>&lt;not-null&gt;</literal>が使用されているからです。</para>

        <para>この関数は第二引数にポインタを取ります。このポインタはヌルポインタであってはなりません。また、このポインタは初期化されたデータを指していなければなりません。<literal>&lt;not-null&gt;</literal> と <literal>&lt;not-uninit&gt;</literal> は正しく使用されています。さらにいえば、このポインタは0終端文字列(zero-terminated string)でなければなりません。そのため&lt;strz&gt;が使用されています。</para>
      </section>
    </section>

    <section>
      <title>define</title>

      <para>ライブラリはマクロプリプロセッサのdefineを使用することができます。例:</para>

      <programlisting>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;def&gt;
  &lt;define name=&quot;NULL_VALUE&quot; value=&quot;0&quot;/&gt;
&lt;/def&gt;</programlisting>

      <para>プリプロセッサの段階でソースコード中に &quot;NULL_VALUE&quot; が現れるごとに、&quot;0&quot;で置き換えます。</para>
    </section>

    <section>
      <title>podtype</title>

      <para>多くのソースコードで、プラットフォームに依存しない型をtypedefによって定義しています。&quot;podtype&quot;のタグによって、cppcheckがこれらをサポートするために必要な情報を提供できます。このような情報のない場合、cppcheckは次の例でみるような &quot;uint16_t&quot; 型を理解できません。</para>

      <programlisting>void test() {
    uint16_t a;
}</programlisting>

      <para>そのため、未使用変数である、'a'が未使用であるとのメッセージが表示されません。</para>

      <programlisting># cppcheck --enable=style unusedvar.cpp
Checking unusedvar.cpp...</programlisting>

      <para>もし uint16_t が以下のように定義されていた場合、結果にメッセージが反映されます。</para>

      <programlisting>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;def&gt;
  &lt;podtype name=&quot;uint16_t&quot; sign=&quot;u&quot; size=&quot;2&quot;/&gt;
&lt;/def&gt;</programlisting>

      <para>型のサイズはバイトサイズで指定します。符号の &quot;sign&quot; 属性は 符号ありの &quot;s&quot; か 符号無し &quot;u&quot; のどちらかです。これらの属性はオプションです。このライブラリを使用しますと、cppcheckはメッセージを表示できるようになります。</para>

      <programlisting># cppcheck --library=lib.cfg --enable=style unusedvar.cpp
Checking unusedvar.cpp...
[unusedvar.cpp:2]: (style) Unused variable: a</programlisting>
    </section>

    <section>
      <title>コンテナ(container)</title>

      <para>C++ ライブラリの多くや STL 自身は、非常によく似た機能性をもつコンテナを提供します。ライブラリによってその動作をcppcheckに伝えられます。それぞれのコンテナの設定にはユニークなIDが必要とします。コンテナの設定には、startPatternを加えることができます(オプション)。この startPatternはToken::Match パターンとendPattern に有効でなけばなりません。また、このendPatternはリンクしているトークンと比較されるものです。オブション属性の&quot;inherits&quot;は事前に定義されたコンテナのIDをとります。</para>

      <para>&lt;container&gt;タグの内部で、&lt;size&gt;、&lt;access&gt;、&lt;other&gt;を選択して使用して関数を定義できます。これらのタグはそれぞれ、&quot;resize&quot; やその結果を与えるような動作を指定することができます。その例 &quot;end-iterator&quot;を示します。</para>

      <para>次の例は、std::vectorの為の定義を示しています。std::vectorは&quot;stdContainer&quot;の定義に基づいていますが、ここには表示していません。:</para>

      <programlisting>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;def&gt;
  &lt;container id=&quot;stdVector&quot; startPattern=&quot;std :: vector &amp;lt;&quot; inherits=&quot;stdContainer&quot;&gt;
    &lt;size&gt;
      &lt;function name=&quot;push_back&quot; action=&quot;push&quot;/&gt;
      &lt;function name=&quot;pop_back&quot; action=&quot;pop&quot;/&gt;
    &lt;/size&gt;
    &lt;access indexOperator=&quot;array-like&quot;&gt;
      &lt;function name=&quot;at&quot; yields=&quot;at_index&quot;/&gt;
      &lt;function name=&quot;front&quot; yields=&quot;item&quot;/&gt;
      &lt;function name=&quot;back&quot; yields=&quot;item&quot;/&gt;
    &lt;/access&gt;
  &lt;/container&gt;
&lt;/def&gt;</programlisting>
    </section>
  </chapter>

  <chapter>
    <title>ルール(Rules)</title>

    <para>正規表現を使用して、ユーザーがルール(rule)を定義することができます。</para>

    <para>これらのカスタムルールは、ソースコードを高度に分析した結果を使用することができません。しかしソースコード中の非常にシンプルなパターンについて簡単にルールを作成することができます。</para>

    <para>ルールの作成を始めるには次の関連記事を参照してください。:</para>

    <para><ulink url="http://sourceforge.net/projects/cppcheck/files/Articles/">http://sourceforge.net/projects/cppcheck/files/Articles/</ulink></para>

    <para>ルールのファイルフォーマットは次のとおりです。:</para>

    <programlisting>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;rule&gt;
  &lt;tokenlist&gt;LIST&lt;/tokenlist&gt;
  &lt;pattern&gt;PATTERN&lt;/pattern&gt;
  &lt;message&gt;
    &lt;id&gt;ID&lt;/id&gt;
    &lt;severity&gt;SEVERITY&lt;/severity&gt;
    &lt;summary&gt;SUMMARY&lt;/summary&gt;
  &lt;/message&gt;
&lt;/rule&gt;</programlisting>

    <para>patternタグ中にCDATAを含めた場合、XMLに干渉する可能性がありますので使用時はご注意ください。:</para>

    <programlisting>&lt;![CDATA[some&lt;strange&gt;pattern]]&gt;</programlisting>

    <section>
      <title>&lt;tokenlist&gt;</title>

      <para>この<literal>&lt;tokenlist&gt;</literal> 要素はオプションです。この要素がある場合、どのトークンをチェックするかを指示することができます。この<literal>LIST</literal>は<literal>define</literal>, <literal>raw</literal>, <literal>normal</literal> , <literal>simple</literal>のいずれかです。</para>

      <variablelist>
        <varlistentry>
          <term>define</term>

          <listitem>
            <para>#define プリプロセッサの記述をチェックするために使用します。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>raw</term>

          <listitem>
            <para>プリプロセッサの出力をチェックするために使用します。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>normal</term>

          <listitem>
            <para><literal>normal</literal> のトークンリストをチェックするために使用します。ソースコードをある程度、単純化した結果をチェックすることになります。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>simple</term>

          <listitem>
            <para>単純なトークンリストをチェックするために使用します。ソースコードを完全に単純化した結果をチェックすることになります。ほとんどの Cppcheckのチェックには、この 単純ばトークンリストを使用します。</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>もし&lt;tokenlist&gt;要素を省略した場合、<literal>simple</literal> が使用されます。</para>
    </section>

    <section>
      <title>&lt;pattern&gt;</title>

      <para>この<literal>PATTERN</literal> にはPerlの正規表現と互換性のある正規表現 <literal>PCRE</literal>を指定します。</para>
    </section>

    <section>
      <title>&lt;id&gt;</title>

      <para>この ID にはユーザーが定義した message idを指定します。</para>
    </section>

    <section>
      <title>&lt;severity&gt;</title>

      <para>この<literal>SEVERITY</literal>には<literal>Cppcheck</literal> の厳格度(severities)である、次のいずれかを指定します。: <literal>information</literal>, <literal>performance</literal>, <literal>portability</literal>, <literal>style</literal>, <literal>warning</literal>,<literal>error</literal></para>
    </section>

    <section>
      <title>&lt;summary&gt;</title>

      <para>オプションです。メッセージのサマリーです。もしこのsummaryトークンが指定されていなければ、マッチしたトークンが出力されます。</para>
    </section>
  </chapter>

  <chapter>
    <title>Cppcheck アドオン</title>

    <para>Cppcheckのアドオンは、個別のスクリプトや個別のプログラムとして実装されています。Cppcheckのアドオンを使用すると次のような利点があります。</para>

    <itemizedlist>
      <listitem>
        <para>洗練された分析の結果を使用した個別の、外部チェックを追加できます。</para>
      </listitem>

      <listitem>
        <para>ソースコードが可視化できます。</para>
      </listitem>

      <listitem>
        <para>その他</para>
      </listitem>
    </itemizedlist>

    <section>
      <title>Cppcheckアドオンの使用方法</title>

      <para>現在、アドオンを使用するには2段階の操作が必要です。:</para>

      <orderedlist>
        <listitem>
          <para>Cppcheckを実行し、ダンプファイルを生成します。</para>
        </listitem>

        <listitem>
          <para>アドオンでダンプファイルを処理します。</para>
        </listitem>
      </orderedlist>

      <para><literal>--dump</literal>フラグを使用するとダンプファイルを生成できます。foo/ フォルダ以下の全てのソースファイルからダンプファイルを生成するには次のようにします。</para>

      <programlisting>cppcheck --dump foo/</programlisting>

      <para>foo/ フォルダ以下の全てのダンプファイルをアドオンで処理するには次のようにします。</para>

      <programlisting>python addon.py foo/*.dump</programlisting>

      <section>
        <title>Cppcheckアドオンの見つけ方</title>

        <para>ダウンロードできる、アドオンがいくつかあります。</para>

        <itemizedlist>
          <listitem>
            <para>Cppcheck プロジェクトはいくつかのアドオンを以下の場所で提供しています。: <uri>http://github.com/danmar/cppcheck/blob/master/addons</uri></para>
          </listitem>

          <listitem>
            <para>ublinterは規格で定義されていない未定義動作に注力した&quot;lint&quot;です。: <uri>http://github.com/danmar/ublinter</uri></para>
          </listitem>
        </itemizedlist>

        <para>あなたのアドオンの情報をご紹介ください。(商用、フリーを問いません。)</para>
      </section>
    </section>

    <section>
      <title>Cppcheck アドオンの作成</title>

      <para>Cppcheck は XML形式でダンプファイルを生成できます。このファイルには以下のようなものが含まれています。:</para>

      <itemizedlist>
        <listitem>
          <para>トークンリスト(Token list)</para>
        </listitem>

        <listitem>
          <para>シンタックスツリー(Syntax trees)</para>
        </listitem>

        <listitem>
          <para>シンボルデータベース(関数、クラス、変数、スコープ)</para>
        </listitem>

        <listitem>
          <para>既知の値(value flow analysis)</para>
        </listitem>
      </itemizedlist>

      <para>Cppcheckはアドオンを直接実行することはできません。直接実行するためにインターフェースはありません。これは、次のような制限がないことを意味します。:</para>

      <itemizedlist>
        <listitem>
          <para>アドオンを作成しリリースする際に、どのようなライセンスでも適用できます。</para>
        </listitem>

        <listitem>
          <para>アドオンの作成に、どのようなスクリプト言語やプログラミング言語で作成できます。</para>
        </listitem>

        <listitem>
          <para>アドオン作成者がユーザーインターフェースと出力を決定できます。</para>
        </listitem>

        <listitem>
          <para>警告の生成以外の目的にもアドオン使用できます。</para>
        </listitem>
      </itemizedlist>

      <para>アドオン作成者の利便性のために、Cppcheck プロジェクトは PythonからCppcheckのデータにアクセスするための cppcheckdata.pyを提供しています。cppcheckdata.pyの使用はオプションです。</para>

      <section>
        <title>使用例1 - 全トークンの表示</title>

        <para>Script:</para>

        <programlisting>import sys
import cppcheckdata

def printtokens(data):
    for token in data.tokenlist:
        print(token.str)

for arg in sys.argv[1:]:
    printtokens(cppcheckdata.parse(arg))</programlisting>
      </section>

      <section>
        <title>使用例2 - 全関数リストアップ</title>

        <para>Script:</para>

        <programlisting>import sys
import cppcheckdata

def printfunctions(data):
    for scope in data.scopes:
        if scope.type == 'Function':
            print(scope.className)

for arg in sys.argv[1:]:
    printfunctions(cppcheckdata.parse(arg))</programlisting>
      </section>

      <section>
        <title>使用例 3 - 全クラスリストアップ</title>

        <para>Script:</para>

        <programlisting>import sys
import cppcheckdata

def printclasses(data):
    for scope in data.scopes:
        if scope.type == 'Class':
            print(scope.className)

for arg in sys.argv[1:]:
    printfunctions(cppcheckdata.parse(arg))</programlisting>
      </section>
    </section>
  </chapter>

  <chapter>
    <title>HTML 形式での報告</title>

    <para>cppcheckのXML出力をHTML形式に変更できます。これを利用するには、Python と pygments module (<ulink url="http://pygments.org/">http://pygments.org/</ulink>) が必要です。Cppcheckのソースツリーに<filename class="directory">htmlreport</filename>というフォルダがあります。このフォルダには、CppcheckのXMLファイルをHTML出力に変換するスクリプトがあります。</para>

    <para>このコマンドでヘルプ画面を生成するには次のように実行します。</para>

    <programlisting>htmlreport/cppcheck-htmlreport -h</programlisting>

    <para>出力画面には次の内容が表示されます。:</para>

    <programlisting>Usage: cppcheck-htmlreport [options]

Options:
  -h, --help      show this help message and exit
  --file=FILE     The cppcheck xml output file to read defects from.
                  Default is reading from stdin.
  --report-dir=REPORT_DIR
                  The directory where the html report content is written.
  --source-dir=SOURCE_DIR
                  Base directory where source code files can be found.</programlisting>

    <para>使用例:</para>

    <programlisting>./cppcheck gui/test.cpp --xml 2&gt; err.xml
htmlreport/cppcheck-htmlreport --file=err.xml --report-dir=test1 --source-dir=.</programlisting>
  </chapter>

  <chapter>
    <title>グラフィカルインターフェースGUI</title>

    <section>
      <title>イントロダクション</title>

      <para>Cppcheck GUIが利用できます。</para>

      <para>メイン画面は、このソフトを起動時に表示されます。</para>
    </section>

    <section>
      <title>ソースコードのチェック</title>

      <para><guimenu>Check</guimenu>メニューを使用します。</para>
    </section>

    <section>
      <title>結果の確認</title>

      <para>結果はリスト表示されます。</para>

      <para><guimenu>View</guimenu> メニューを操作して、メッセージの種類毎に表示/非表示を切り替えできます。</para>

      <para>結果をXML ファイルに保存して、後で確認できます。<literal>Save results to file</literal> と <literal>Open XML</literal>を参照してください。</para>
    </section>

    <section>
      <title>設定</title>

      <para><guimenu>Language</guimenu>メニューからいつでも使用言語を変更できます。</para>

      <para>設定は、<menuchoice> <guimenu>Edit</guimenu> <guimenuitem>Preferences</guimenuitem> </menuchoice>で変更できます。</para>
    </section>

    <section>
      <title>プロジェクトファイル</title>

      <para>プロジェクトファイルは、プロジェクト固有の設定を保存するのに使用します。固有の設定には次のものがあります。:</para>

      <itemizedlist>
        <listitem>
          <para>インクルードパス</para>
        </listitem>

        <listitem>
          <para>プリプロセッサのdefine</para>
        </listitem>
      </itemizedlist>

      <para>このマニュアルの<link linkend="preprocessor-configurations">3 章</link>にあるように、全てのコンパイルスイッチの組み合わせをチェックします。コンパイルスイッチの組み合わせを制限したい場合にだけ、プリプロセッサのdefineを指定してください。</para>
    </section>
  </chapter>
</book>
