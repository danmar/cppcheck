
### Template Simplifier pass 1 ###


##file simplecpp-1.5.1/simplecpp.h

1:
|
48:
49: namespace simplecpp {
50:
51: enum cstd_t { CUnknown = -1 , C89 , C99 , C11 , C17 , C23 } ;
52:
53:
54: enum cppstd_t { CPPUnknown = -1 , CPP03 , CPP11 , CPP14 , CPP17 , CPP20 , CPP23 , CPP26 } ;
55:
56:
57: class Macro ;
58: class FileDataCache ;
59:
|
62:
63: class Location {
64: public:
65: explicit Location ( const std :: vector < std :: string > & f ) : files ( f ) , fileIndex ( 0 ) , line ( 1U ) , col ( 0U ) { }
66:
67: Location ( const Location & loc ) : files ( loc . files ) , fileIndex ( loc . fileIndex ) , line ( loc . line ) , col ( loc . col ) { }
68:
69: Location & operator= ( const Location & other ) {
70: if ( this != & other ) {
71: fileIndex = other . fileIndex ;
72: line = other . line ;
73: col = other . col ;
74: }
75: return * this ;
76: }
77:
78:
79: void adjust ( const std :: string & str ) ;
80:
81: bool operator< ( const Location & rhs ) const {
82: if ( fileIndex != rhs . fileIndex ) {
83: return fileIndex < rhs . fileIndex ; }
84: if ( line != rhs . line ) {
85: return line < rhs . line ; }
86: return col < rhs . col ;
87: }
88:
89: bool sameline ( const Location & other ) const {
90: return fileIndex == other . fileIndex && line == other . line ;
91: }
92:
93: const std :: string & file ( ) const {
94: return fileIndex < files . size ( ) ? files [ fileIndex ] : emptyFileName ;
95: }
96:
97: const std :: vector < std :: string > & files ;
98: unsigned int fileIndex ;
99: unsigned int line ;
100: unsigned int col ;
101: private:
102: static const std :: string emptyFileName ;
103: } ;
104:
|
108:
109: class Token {
110: public:
111: Token ( const std :: string & s , const Location & loc , bool wsahead = false ) :
112: whitespaceahead ( wsahead ) , location ( loc ) , previous ( nullptr ) , next ( nullptr ) , nextcond ( nullptr ) , string ( s ) {
113: flags ( ) ;
114: }
115:
116: Token ( const Token & tok ) :
117: macro ( tok . macro ) , op ( tok . op ) , comment ( tok . comment ) , name ( tok . name ) , number ( tok . number ) , whitespaceahead ( tok . whitespaceahead ) , location ( tok . location ) , previous ( nullptr ) , next ( nullptr ) , nextcond ( nullptr ) , string ( tok . string ) , mExpandedFrom ( tok . mExpandedFrom ) {
118: }
119:
120: void flags ( ) {
121: name = ( std :: isalpha ( static_cast < unsigned char > ( string [ 0 ] ) ) || string [ 0 ] == '_' || string [ 0 ] == '$' )
122: && ( std :: memchr ( string . c_str ( ) , '\'' , string . size ( ) ) == nullptr ) ;
123: comment = string . size ( ) > 1U && string [ 0 ] == '/' && ( string [ 1 ] == '/' || string [ 1 ] == '*' ) ;
124: number = isNumberLike ( string ) ;
125: op = ( string . size ( ) == 1U && ! name && ! comment && ! number ) ? string [ 0 ] : '\0' ;
126: }
127:
128: const std :: string & str ( ) const {
129: return string ;
130: }
131: void setstr ( const std :: string & s ) {
132: string = s ;
133: flags ( ) ;
134: }
135:
136: bool isOneOf ( const char ops [ ] ) const ;
137: bool startsWithOneOf ( const char c [ ] ) const ;
138: bool endsWithOneOf ( const char c [ ] ) const ;
139: static bool isNumberLike ( const std :: string & str ) {
140: return std :: isdigit ( static_cast < unsigned char > ( str [ 0 ] ) ) ||
141: ( str . size ( ) > 1U && ( str [ 0 ] == '-' || str [ 0 ] == '+' ) && std :: isdigit ( static_cast < unsigned char > ( str [ 1 ] ) ) ) ;
142: }
143:
144: std :: string macro ;
145: char op ;
146: bool comment ;
147: bool name ;
148: bool number ;
149: bool whitespaceahead ;
150: Location location ;
151: Token * previous ;
152: Token * next ;
153: const mutable Token * nextcond ;
154:
155: const Token * previousSkipComments ( ) const {
156: const Token * tok ; tok = this . previous ;
157: while ( tok && tok . comment ) {
158: tok = tok . previous ; }
159: return tok ;
160: }
161:
162: const Token * nextSkipComments ( ) const {
163: const Token * tok ; tok = this . next ;
164: while ( tok && tok . comment ) {
165: tok = tok . next ; }
166: return tok ;
167: }
168:
169: void setExpandedFrom ( const Token * tok , const Macro * m ) {
170: mExpandedFrom = tok . mExpandedFrom ;
171: mExpandedFrom . insert ( m ) ;
172: if ( tok . whitespaceahead ) {
173: whitespaceahead = true ; }
174: }
175: bool isExpandedFrom ( const Macro * m ) const {
176: return mExpandedFrom . find ( m ) != mExpandedFrom . end ( ) ;
177: }
178:
179: void printAll ( ) const ;
180: void printOut ( ) const ;
181: private:
182: std :: string string ;
183:
184: std :: set < const Macro * > mExpandedFrom ;
185:
186:
187: Token & operator= ( const Token & tok ) ;
188: } ;
189:
190:
191: struct Output {
192: explicit Output ( const std :: vector < std :: string > & files ) : type ( ERROR ) , location ( files ) { }
193: enum Type {
194: ERROR ,
195: WARNING ,
196: MISSING_HEADER ,
197: INCLUDE_NESTED_TOO_DEEPLY ,
198: SYNTAX_ERROR ,
199: PORTABILITY_BACKSLASH ,
200: UNHANDLED_CHAR_ERROR ,
201: EXPLICIT_INCLUDE_NOT_FOUND ,
202: FILE_NOT_FOUND ,
203: DUI_ERROR
204: } ; enum Type type ;
205: explicit Output ( const std :: vector < std :: string > & files , Type type , const std :: string & msg ) : type ( type ) , location ( files ) , msg ( msg ) { }
206: Location location ;
207: std :: string msg ;
208: } ;
209:
|
212:
213: class TokenList {
214: public:
215: class Stream ;
216:
217: explicit TokenList ( std :: vector < std :: string > & filenames ) ;
218:
219: TokenList ( std :: istream & istr , std :: vector < std :: string > & filenames , const std :: string & filename = std :: string ( ) , std :: list < Output > * outputList = nullptr ) ;
220:
221: TokenList ( const unsigned char * data , unsigned long size , std :: vector < std :: string > & filenames , const std :: string & filename = std :: string ( ) , std :: list < Output > * outputList = nullptr ) ;
222:
223: TokenList ( const char * data , unsigned long size , std :: vector < std :: string > & filenames , const std :: string & filename = std :: string ( ) , std :: list < Output > * outputList = nullptr ) ;
224:
225: TokenList ( const std :: string & filename , std :: vector < std :: string > & filenames , std :: list < Output > * outputList = nullptr ) ;
226: TokenList ( const TokenList & other ) ;
227: TokenList ( TokenList && other ) ;
228: ~ TokenList ( ) ;
229: TokenList & operator= ( const TokenList & other ) ;
230: TokenList & operator= ( TokenList && other ) ;
231:
232: void clear ( ) ;
233: bool empty ( ) const {
234: return ! frontToken ;
235: }
236: void push_back ( Token * tok ) ;
237:
238: void dump ( ) const ;
239: std :: string stringify ( ) const ;
240:
241: void readfile ( Stream & stream , const std :: string & filename = std :: string ( ) , std :: list < Output > * outputList = nullptr ) ;
242: void constFold ( ) ;
243:
244: void removeComments ( ) ;
245:
246: Token * front ( ) {
247: return frontToken ;
248: }
249:
250: const Token * cfront ( ) const {
251: return frontToken ;
252: }
253:
254: Token * back ( ) {
255: return backToken ;
256: }
257:
258: const Token * cback ( ) const {
259: return backToken ;
260: }
261:
262: void deleteToken ( Token * tok ) {
263: if ( ! tok ) {
264: return ; }
265: Token * const prev ; prev = tok . previous ;
266: Token * const next ; next = tok . next ;
267: if ( prev ) {
268: prev . next = next ; }
269: if ( next ) {
270: next . previous = prev ; }
271: if ( frontToken == tok ) {
272: frontToken = next ; }
273: if ( backToken == tok ) {
274: backToken = prev ; }
275: delete tok ;
276: }
277:
278: void takeTokens ( TokenList & other ) {
279: if ( ! other . frontToken ) {
280: return ; }
281: if ( ! frontToken ) {
282: frontToken = other . frontToken ;
283: } else {
284: backToken . next = other . frontToken ;
285: other . frontToken . previous = backToken ;
286: }
287: backToken = other . backToken ;
288: other . frontToken = other . backToken = nullptr ;
289: }
290:
291:
292: std :: map < std :: string , unsigned long > sizeOfType ;
293:
294: const std :: vector < std :: string > & getFiles ( ) const {
295: return files ;
296: }
297:
298: private:
299: void combineOperators ( ) ;
300:
301: void constFoldUnaryNotPosNeg ( Token * tok ) ;
302: void constFoldMulDivRem ( Token * tok ) ;
303: void constFoldAddSub ( Token * tok ) ;
304: void constFoldShift ( Token * tok ) ;
305: void constFoldComparison ( Token * tok ) ;
306: void constFoldBitwise ( Token * tok ) ;
307: void constFoldLogicalOp ( Token * tok ) ;
308: void constFoldQuestionOp ( Token * * tok1 ) ;
309:
310: std :: string readUntil ( Stream & stream , const Location & location , char start , char end , std :: list < Output > * outputList ) ;
311: void lineDirective ( unsigned int fileIndex , unsigned int line , Location * location ) ;
312:
313: std :: string lastLine ( int maxsize = 1000 ) const ;
314: const Token * lastLineTok ( int maxsize = 1000 ) const ;
315: bool isLastLinePreprocessor ( int maxsize = 1000 ) const ;
316:
317: unsigned int fileIndex ( const std :: string & filename ) ;
318:
319: Token * frontToken ;
320: Token * backToken ;
321: std :: vector < std :: string > & files ;
322: } ;
323:
324:
325: struct MacroUsage {
326: explicit MacroUsage ( const std :: vector < std :: string > & f , bool macroValueKnown_ ) : macroLocation ( f ) , useLocation ( f ) , macroValueKnown ( macroValueKnown_ ) { }
327: std :: string macroName ;
328: Location macroLocation ;
329: Location useLocation ;
330: bool macroValueKnown ;
331: } ;
332:
333:
334: struct IfCond {
335: explicit IfCond ( const Location & location , const std :: string & E , long long result ) : location ( location ) , E ( E ) , result ( result ) { }
336: Location location ;
337: std :: string E ;
338: long long result ;
339: } ;
340:
|
344:
345: struct DUI {
346: DUI ( ) : clearIncludeCache ( false ) , removeComments ( false ) { }
347: std :: list < std :: string > defines ;
348: std :: set < std :: string > undefined ;
349: std :: list < std :: string > includePaths ;
350: std :: list < std :: string > includes ;
351: std :: string std ;
352: bool clearIncludeCache ;
353: bool removeComments ;
354: } ;
355:
356: long long characterLiteralToLL ( const std :: string & str ) ;
357:
358: FileDataCache load ( const TokenList & rawtokens , std :: vector < std :: string > & filenames , const DUI & dui , std :: list < Output > * outputList = nullptr ) ;
359:
|
371:
372: void preprocess ( TokenList & output , const TokenList & rawtokens , std :: vector < std :: string > & files , FileDataCache & cache , const DUI & dui , std :: list < Output > * outputList = nullptr , std :: list < MacroUsage > * macroUsage = nullptr , std :: list < IfCond > * ifCond = nullptr ) ;
373:
|
376:
377: void cleanup ( FileDataCache & cache ) ;
378:
379:
380: std :: string simplifyPath ( std :: string path ) ;
381:
382:
383: std :: string convertCygwinToWindowsPath ( const std :: string & cygwinPath ) ;
384:
385:
386: cstd_t getCStd ( const std :: string & std ) ;
387:
388:
389: cppstd_t getCppStd ( const std :: string & std ) ;
390:
391:
392: std :: string getCStdString ( const std :: string & std ) ;
393: std :: string getCStdString ( cstd_t std ) ;
394:
395:
396: std :: string getCppStdString ( const std :: string & std ) ;
397: std :: string getCppStdString ( cppstd_t std ) ;
398:
399: struct FileData {
400:
401: std :: string filename ;
402:
403: TokenList tokens ;
404: } ;
405:
406: class FileDataCache {
407: public:
408: FileDataCache ( ) = default ;
409:
410: FileDataCache ( const FileDataCache & ) = delete ;
411: FileDataCache ( FileDataCache && ) = default ;
412:
413: FileDataCache & operator= ( const FileDataCache & ) = delete ;
414: FileDataCache & operator= ( FileDataCache && ) = default ;
415:
416:
417:
418: std :: pair < FileData * , bool > get ( const std :: string & sourcefile , const std :: string & header , const DUI & dui , bool systemheader , std :: vector < std :: string > & filenames , std :: list < Output > * outputList ) ;
419:
420: void insert ( FileData data ) {
421: FileData * const newdata ; newdata = new FileData ( std :: move ( data ) ) ;
422:
423: mData . emplace_back ( newdata ) ;
424: mNameMap . emplace ( newdata . filename , newdata ) ;
425: }
426:
427: void clear ( ) {
428: mNameMap . clear ( ) ;
429: mIdMap . clear ( ) ;
430: mData . clear ( ) ;
431: }
432:
|
437:
438: std :: vector < std :: unique_ptr < FileData > > :: size_type size ( ) const {
439: return mData . size ( ) ;
440: }
441: std :: vector < std :: unique_ptr < FileData > > :: iterator begin ( ) {
442: return mData . begin ( ) ;
443: }
444: std :: vector < std :: unique_ptr < FileData > > :: iterator end ( ) {
445: return mData . end ( ) ;
446: }
447: std :: vector < std :: unique_ptr < FileData > > :: const_iterator begin ( ) const {
448: return mData . begin ( ) ;
449: }
450: std :: vector < std :: unique_ptr < FileData > > :: const_iterator end ( ) const {
451: return mData . end ( ) ;
452: }
453: std :: vector < std :: unique_ptr < FileData > > :: const_iterator cbegin ( ) const {
454: return mData . cbegin ( ) ;
455: }
456: std :: vector < std :: unique_ptr < FileData > > :: const_iterator cend ( ) const {
457: return mData . cend ( ) ;
458: }
459:
460: private:
461: struct FileID {
462:
|
476:
477: dev_t dev ;
478: ino_t ino ;
479:
480: bool operator== ( const FileID & that ) const noexcept ( true ) {
481: return dev == that . dev && ino == that . ino ;
482: }
483:
484: struct Hasher {
485: unsigned long operator() ( const FileID & id ) const {
486:
|
489:
490: return static_cast < unsigned long > ( id . dev ) ^ static_cast < unsigned long > ( id . ino ) ;
491:
492: }
493: } ;
494: } ;
495:
|
498:
499: static bool getFileId ( const std :: string & path , FileID & id ) ;
500:
501: std :: pair < FileData * , bool > tryload ( std :: unordered_map < std :: string , FileData * > :: iterator & name_it , const DUI & dui , std :: vector < std :: string > & filenames , std :: list < Output > * outputList ) ;
502:
503: std :: vector < std :: unique_ptr < FileData > > mData ;
504: std :: unordered_map < std :: string , FileData * > mNameMap ;
505: std :: unordered_map < FileID , FileData * , FileID :: Hasher > mIdMap ;
506:
507: } ;
508: }

##file simplecpp-1.5.1/simplecpp.cpp

1:
|
48:
49: static bool isHex ( const std :: string & s )
50: {
51: return s . size ( ) > 2 && ( s . compare ( 0 , 2 , "0x" ) == 0 || s . compare ( 0 , 2 , "0X" ) == 0 ) ;
52: }
53:
54: static bool isOct ( const std :: string & s )
55: {
56: return s . size ( ) > 1 && ( s [ 0 ] == '0' ) && ( s [ 1 ] >= '0' ) && ( s [ 1 ] < '8' ) ;
57: }
58:
59:
60: static bool isStringLiteral_ ( const std :: string & s )
61: {
62: return s . size ( ) > 1 && ( s [ 0 ] == '\"' ) && ( * s . rbegin ( ) == '\"' ) ;
63: }
64:
65:
66: static bool isCharLiteral_ ( const std :: string & s )
67: {
68:
69:
70: return s . size ( ) > 1 && ( s [ 0 ] == '\'' ) && ( * s . rbegin ( ) == '\'' ) ;
71: }
72:
73: static const std :: string DEFINE ( "define" ) ;
74: static const std :: string UNDEF ( "undef" ) ;
75:
76: static const std :: string INCLUDE ( "include" ) ;
77:
78: static const std :: string ERROR ( "error" ) ;
79: static const std :: string WARNING ( "warning" ) ;
80:
81: static const std :: string IF ( "if" ) ;
82: static const std :: string IFDEF ( "ifdef" ) ;
83: static const std :: string IFNDEF ( "ifndef" ) ;
84: static const std :: string DEFINED ( "defined" ) ;
85: static const std :: string ELSE ( "else" ) ;
86: static const std :: string ELIF ( "elif" ) ;
87: static const std :: string ENDIF ( "endif" ) ;
88:
89: static const std :: string PRAGMA ( "pragma" ) ;
90: static const std :: string ONCE ( "once" ) ;
91:
92: static const std :: string HAS_INCLUDE ( "__has_include" ) ;
93:
94: template < class T > static std :: string toString ( T t )
95: {
96:
97: std :: ostringstream ostr ;
98: ostr << t ;
99: return ostr . str ( ) ;
100: }
101:
|
110:
111: static long long stringToLL ( const std :: string & s )
112: {
113: long long ret ;
114: const bool hex = isHex ( s ) ;
115: const bool oct = isOct ( s ) ;
116: std :: istringstream istr ( hex ? s . substr ( 2 ) : oct ? s . substr ( 1 ) : s ) ;
117: if ( hex ) {
118: istr >> std :: hex ; }
119: else if ( oct ) {
120: istr >> std :: oct ; }
121: istr >> ret ;
122: return ret ;
123: }
124:
125: static unsigned long long stringToULL ( const std :: string & s )
126: {
127: unsigned long long ret ;
128: const bool hex = isHex ( s ) ;
129: const bool oct = isOct ( s ) ;
130: std :: istringstream istr ( hex ? s . substr ( 2 ) : oct ? s . substr ( 1 ) : s ) ;
131: if ( hex ) {
132: istr >> std :: hex ; }
133: else if ( oct ) {
134: istr >> std :: oct ; }
135: istr >> ret ;
136: return ret ;
137: }
138:
139: static bool endsWith ( const std :: string & s , const std :: string & e )
140: {
141: return ( s . size ( ) >= e . size ( ) ) && std :: equal ( e . rbegin ( ) , e . rend ( ) , s . rbegin ( ) ) ;
142: }
143:
144: static bool sameline ( const simplecpp :: Token * tok1 , const simplecpp :: Token * tok2 )
145: {
146: return tok1 && tok2 && tok1 . location . sameline ( tok2 . location ) ;
147: }
148:
149: static bool isAlternativeBinaryOp ( const simplecpp :: Token * tok , const std :: string & alt )
150: {
151: return ( tok . name &&
152: tok . str ( ) == alt &&
153: tok . previous &&
154: tok . next &&
155: ( tok . previous . number || tok . previous . name || tok . previous . op == ')' ) &&
156: ( tok . next . number || tok . next . name || tok . next . op == '(' ) ) ;
157: }
158:
159: static bool isAlternativeUnaryOp ( const simplecpp :: Token * tok , const std :: string & alt )
160: {
161: return ( ( tok . name && tok . str ( ) == alt ) &&
162: ( ! tok . previous || tok . previous . op == '(' ) &&
163: ( tok . next && ( tok . next . name || tok . next . number ) ) ) ;
164: }
165:
166: static std :: string replaceAll ( std :: string s , const std :: string & from , const std :: string & to )
167: {
168: for ( unsigned long pos = s . find ( from ) ; pos != std :: string :: npos ; pos = s . find ( from , pos + to . size ( ) ) ) {
169: s . replace ( pos , from . size ( ) , to ) ; }
170: return s ;
171: }
172:
173: const std :: string simplecpp :: Location :: emptyFileName ;
174:
175: void simplecpp :: Location :: adjust ( const std :: string & str )
176: {
177: if ( strpbrk ( str . c_str ( ) , "\r\n" ) == nullptr ) {
178: col += str . size ( ) ;
179: return ;
180: }
181:
182: for ( unsigned long i = 0U ; i < str . size ( ) ; ++ i ) {
183: col ++ ;
184: if ( str [ i ] == '\n' || str [ i ] == '\r' ) {
185: col = 1 ;
186: line ++ ;
187: if ( str [ i ] == '\r' && ( i + 1 ) < str . size ( ) && str [ i + 1 ] == '\n' ) {
188: ++ i ; }
189: }
190: }
191: }
192:
193: bool simplecpp :: Token :: isOneOf ( const char ops [ ] ) const
194: {
195: return ( op != '\0' ) && ( std :: strchr ( ops , op ) != nullptr ) ;
196: }
197:
198: bool simplecpp :: Token :: startsWithOneOf ( const char c [ ] ) const
199: {
200: return std :: strchr ( c , string [ 0 ] ) != nullptr ;
201: }
202:
203: bool simplecpp :: Token :: endsWithOneOf ( const char c [ ] ) const
204: {
205: return std :: strchr ( c , string [ string . size ( ) - 1U ] ) != nullptr ;
206: }
207:
208: void simplecpp :: Token :: printAll ( ) const
209: {
210: const Token * tok ; tok = this ;
211: while ( tok . previous ) {
212: tok = tok . previous ; }
213: for ( ; tok ; tok = tok . next ) {
214: if ( tok . previous ) {
215: std :: cout << ( sameline ( tok , tok . previous ) ? ' ' : '\n' ) ;
216: }
217: std :: cout << tok . str ( ) ;
218: }
219: std :: cout << std :: endl ;
220: }
221:
222: void simplecpp :: Token :: printOut ( ) const
223: {
224: for ( const Token * tok = this ; tok ; tok = tok . next ) {
225: if ( tok != this ) {
226: std :: cout << ( sameline ( tok , tok . previous ) ? ' ' : '\n' ) ;
227: }
228: std :: cout << tok . str ( ) ;
229: }
230: std :: cout << std :: endl ;
231: }
232:
233:
234: class simplecpp :: TokenList :: Stream {
235: public:
236: virtual ~ Stream ( ) { }
237:
238: virtual int get ( ) = 0 ;
239: virtual int peek ( ) = 0 ;
240: virtual void unget ( ) = 0 ;
241: virtual bool good ( ) = 0 ;
242:
243: unsigned char readChar ( ) {
244: unsigned char ch ; ch = static_cast < unsigned char > ( get ( ) ) ;
245:
246:
247:
248: if ( isUtf16 ) {
249: const unsigned char ch2 = static_cast < unsigned char > ( get ( ) ) ;
250: const int ch16 = makeUtf16Char ( ch , ch2 ) ;
251: ch = static_cast < unsigned char > ( ( ch16 >= 0x80 ) ? 0xff : ch16 ) ;
252: }
253:
254:
255: if ( ch == '\r' ) {
256: ch = '\n' ;
257:
258: int ch2 ; ch2 = get ( ) ;
259: if ( isUtf16 ) {
260: const int c2 = get ( ) ;
261: ch2 = makeUtf16Char ( ch2 , c2 ) ;
262: }
263:
264: if ( ch2 != '\n' ) {
265: ungetChar ( ) ; }
266: }
267:
268: return ch ;
269: }
270:
271: unsigned char peekChar ( ) {
272: unsigned char ch ; ch = static_cast < unsigned char > ( peek ( ) ) ;
273:
274:
275:
276: if ( isUtf16 ) {
277: ( void ) get ( ) ;
278: const unsigned char ch2 = static_cast < unsigned char > ( peek ( ) ) ;
279: unget ( ) ;
280: const int ch16 = makeUtf16Char ( ch , ch2 ) ;
281: ch = static_cast < unsigned char > ( ( ch16 >= 0x80 ) ? 0xff : ch16 ) ;
282: }
283:
284:
285: if ( ch == '\r' ) {
286: ch = '\n' ; }
287:
288: return ch ;
289: }
290:
291: void ungetChar ( ) {
292: unget ( ) ;
293: if ( isUtf16 ) {
294: unget ( ) ; }
295: }
296:
297: protected:
298: void init ( ) {
299:
300: isUtf16 = false ;
301: bom = getAndSkipBOM ( ) ;
302: isUtf16 = bom == 0xfeff || bom == 0xfffe ;
303: }
304:
305: private:
306: int makeUtf16Char ( const unsigned char ch , const unsigned char ch2 ) const {
307: return ( bom == 0xfeff ) ? ( ch << 8 | ch2 ) : ( ch2 << 8 | ch ) ;
308: }
309:
310: unsigned short getAndSkipBOM ( ) {
311: const int ch1 = peek ( ) ;
312:
313:
314: if ( ch1 >= 0xfe ) {
315: ( void ) get ( ) ;
316: const unsigned short byte = static_cast < unsigned char > ( ch1 ) << 8 ;
317: if ( peek ( ) >= 0xfe ) {
318: return byte | static_cast < unsigned char > ( get ( ) ) ; }
319: unget ( ) ;
320: return 0 ;
321: }
322:
323:
324: if ( ch1 == 0xef ) {
325: ( void ) get ( ) ;
326: if ( peek ( ) == 0xbb ) {
327: ( void ) get ( ) ;
328: if ( peek ( ) == 0xbf ) {
329: ( void ) get ( ) ;
330: return 0 ;
331: }
332: unget ( ) ;
333: }
334: unget ( ) ;
335: }
336:
337: return 0 ;
338: }
339:
340: unsigned short bom ;
341: protected:
342: bool isUtf16 ;
343: } ;
344:
345: class StdIStream : public simplecpp :: TokenList :: Stream {
346: public:
347:
348: explicit StdIStream ( std :: istream & istr )
349: : istr ( istr ) {
350: assert ( istr . good ( ) ) ;
351: init ( ) ;
352: }
353:
354: virtual int get ( ) override {
355: return istr . get ( ) ;
356: }
357: virtual int peek ( ) override {
358: return istr . peek ( ) ;
359: }
360: virtual void unget ( ) override {
361: istr . unget ( ) ;
362: }
363: virtual bool good ( ) override {
364: return istr . good ( ) ;
365: }
366:
367: private:
368: std :: istream & istr ;
369: } ;
370:
371: class StdCharBufStream : public simplecpp :: TokenList :: Stream {
372: public:
373:
374: StdCharBufStream ( const unsigned char * str , unsigned long size )
375: : str ( str )
376: , size ( size )
377: , pos ( 0 )
378: , lastStatus ( 0 ) {
379: init ( ) ;
380: }
381:
382: virtual int get ( ) override {
383: if ( pos >= size ) {
384: return lastStatus = EOF ; }
385: return str [ pos ++ ] ;
386: }
387: virtual int peek ( ) override {
388: if ( pos >= size ) {
389: return lastStatus = EOF ; }
390: return str [ pos ] ;
391: }
392: virtual void unget ( ) override {
393: -- pos ;
394: }
395: virtual bool good ( ) override {
396: return lastStatus != EOF ;
397: }
398:
399: private:
400: const unsigned char * str ;
401: const unsigned long size ;
402: unsigned long pos ;
403: int lastStatus ;
404: } ;
405:
406: class FileStream : public simplecpp :: TokenList :: Stream {
407: public:
408:
409: explicit FileStream ( const std :: string & filename , std :: vector < std :: string > & files )
410: : file ( fopen ( filename . c_str ( ) , "rb" ) )
411: , lastCh ( 0 )
412: , lastStatus ( 0 ) {
413: if ( ! file ) {
414: files . push_back ( filename ) ;
415: throw simplecpp :: Output ( files , simplecpp :: Output :: FILE_NOT_FOUND , "File is missing: " + filename ) ;
416: }
417: init ( ) ;
418: }
419:
420: ~ FileStream ( ) override {
421: fclose ( file ) ;
422: file = nullptr ;
423: }
424:
425: virtual int get ( ) override {
426: lastStatus = lastCh = fgetc ( file ) ;
427: return lastCh ;
428: }
429: virtual int peek ( ) override {
430:
431: const int ch = fgetc ( file ) ;
432: unget_internal ( ch ) ;
433: return ch ;
434: }
435: virtual void unget ( ) override {
436: unget_internal ( lastCh ) ;
437: }
438: virtual bool good ( ) override {
439: return lastStatus != EOF ;
440: }
441:
442: private:
443: void unget_internal ( int ch ) {
444: if ( isUtf16 ) {
445:
446:
447: fseek ( file , -1 , $1 ) ;
448: } else {
449: ungetc ( ch , file ) ; }
450: }
451:
452: FileStream ( const FileStream & ) ;
453: FileStream & operator= ( const FileStream & ) ;
454:
455: FILE * file ;
456: int lastCh ;
457: int lastStatus ;
458: } ;
459:
460: simplecpp :: TokenList :: TokenList ( std :: vector < std :: string > & filenames ) : frontToken ( nullptr ) , backToken ( nullptr ) , files ( filenames ) { }
461:
462: simplecpp :: TokenList :: TokenList ( std :: istream & istr , std :: vector < std :: string > & filenames , const std :: string & filename , std :: list < Output > * outputList )
463: : frontToken ( nullptr ) , backToken ( nullptr ) , files ( filenames )
464: {
465: StdIStream stream ( istr ) ;
466: readfile ( stream , filename , outputList ) ;
467: }
468:
469: simplecpp :: TokenList :: TokenList ( const unsigned char * data , unsigned long size , std :: vector < std :: string > & filenames , const std :: string & filename , std :: list < Output > * outputList )
470: : frontToken ( nullptr ) , backToken ( nullptr ) , files ( filenames )
471: {
472: StdCharBufStream stream ( data , size ) ;
473: readfile ( stream , filename , outputList ) ;
474: }
475:
476: simplecpp :: TokenList :: TokenList ( const char * data , unsigned long size , std :: vector < std :: string > & filenames , const std :: string & filename , std :: list < Output > * outputList )
477: : frontToken ( nullptr ) , backToken ( nullptr ) , files ( filenames )
478: {
479: StdCharBufStream stream ( reinterpret_cast < const unsigned char * > ( data ) , size ) ;
480: readfile ( stream , filename , outputList ) ;
481: }
482:
483: simplecpp :: TokenList :: TokenList ( const std :: string & filename , std :: vector < std :: string > & filenames , std :: list < Output > * outputList )
484: : frontToken ( nullptr ) , backToken ( nullptr ) , files ( filenames )
485: {
486: try {
487: FileStream stream ( filename , filenames ) ;
488: readfile ( stream , filename , outputList ) ;
489: } catch ( const simplecpp :: Output & e ) {
490: outputList . push_back ( e ) ;
491: }
492: }
493:
494: simplecpp :: TokenList :: TokenList ( const TokenList & other ) : frontToken ( nullptr ) , backToken ( nullptr ) , files ( other . files )
495: {
496: * this = other ;
497: }
498:
499: simplecpp :: TokenList :: TokenList ( TokenList && other ) : frontToken ( nullptr ) , backToken ( nullptr ) , files ( other . files )
500: {
501: * this = std :: move ( other ) ;
502: }
503:
504: simplecpp :: TokenList :: ~ TokenList ( )
505: {
506: clear ( ) ;
507: }
508:
509: simplecpp :: TokenList & simplecpp :: TokenList :: operator= ( const TokenList & other )
510: {
511: if ( this != & other ) {
512: clear ( ) ;
513: files = other . files ;
514: for ( const Token * tok = other . cfront ( ) ; tok ; tok = tok . next ) {
515: push_back ( new Token ( * tok ) ) ; }
516: sizeOfType = other . sizeOfType ;
517: }
518: return * this ;
519: }
520:
521: simplecpp :: TokenList & simplecpp :: TokenList :: operator= ( TokenList && other )
522: {
523: if ( this != & other ) {
524: clear ( ) ;
525: frontToken = other . frontToken ;
526: other . frontToken = nullptr ;
527: backToken = other . backToken ;
528: other . backToken = nullptr ;
529: files = other . files ;
530: sizeOfType = std :: move ( other . sizeOfType ) ;
531: }
532: return * this ;
533: }
534:
535: void simplecpp :: TokenList :: clear ( )
536: {
537: backToken = nullptr ;
538: while ( frontToken ) {
539: Token * const next ; next = frontToken . next ;
540: delete frontToken ;
541: frontToken = next ;
542: }
543: sizeOfType . clear ( ) ;
544: }
545:
546: void simplecpp :: TokenList :: push_back ( Token * tok )
547: {
548: if ( ! frontToken ) {
549: frontToken = tok ; }
550: else {
551: backToken . next = tok ; }
552: tok . previous = backToken ;
553: backToken = tok ;
554: }
555:
556: void simplecpp :: TokenList :: dump ( ) const
557: {
558: std :: cout << stringify ( ) << std :: endl ;
559: }
560:
561: std :: string simplecpp :: TokenList :: stringify ( ) const
562: {
563: std :: ostringstream ret ;
564: Location loc ( files ) ;
565: for ( const Token * tok = cfront ( ) ; tok ; tok = tok . next ) {
566: if ( tok . location . line < loc . line || tok . location . fileIndex != loc . fileIndex ) {
567: ret << "\n#line " << tok . location . line << " \"" << tok . location . file ( ) << "\"\n" ;
568: loc = tok . location ;
569: }
570:
571: while ( tok . location . line > loc . line ) {
572: ret << '\n' ;
573: loc . line ++ ;
574: }
575:
576: if ( sameline ( tok . previous , tok ) ) {
577: ret << ' ' ; }
578:
579: ret << tok . str ( ) ;
580:
581: loc . adjust ( tok . str ( ) ) ;
582: }
583:
584: return ret . str ( ) ;
585: }
586:
587: static bool isNameChar ( unsigned char ch )
588: {
589: return std :: isalnum ( ch ) || ch == '_' || ch == '$' ;
590: }
591:
592: static std :: string escapeString ( const std :: string & str )
593: {
594: std :: ostringstream ostr ;
595: ostr << '\"' ;
596: for ( unsigned long i = 1U ; i < str . size ( ) - 1 ; ++ i ) {
597: const char c = str [ i ] ;
598: if ( c == '\\' || c == '\"' || c == '\'' ) {
599: ostr << '\\' ; }
600: ostr << c ;
601: }
602: ostr << '\"' ;
603: return ostr . str ( ) ;
604: }
605:
606: static void portabilityBackslash ( std :: list < Output > * outputList , const std :: vector < std :: string > & files , const simplecpp :: Location & location )
607: {
608: if ( ! outputList ) {
609: return ; }
610: simplecpp :: Output err ( files ) ;
611: err . type = simplecpp :: Output :: PORTABILITY_BACKSLASH ;
612: err . location = location ;
613: err . msg = "Combination 'backslash space newline' is not portable." ;
614: outputList . push_back ( err ) ;
615: }
616:
617: static bool isStringLiteralPrefix ( const std :: string & str )
618: {
619: return str == "u" || str == "U" || str == "L" || str == "u8" ||
620: str == "R" || str == "uR" || str == "UR" || str == "LR" || str == "u8R" ;
621: }
622:
623: void simplecpp :: TokenList :: lineDirective ( unsigned int fileIndex , unsigned int line , Location * location )
624: {
625: if ( fileIndex != location . fileIndex || line >= location . line ) {
626: location . fileIndex = fileIndex ;
627: location . line = line ;
628: return ;
629: }
630:
631: if ( line + 2 >= location . line ) {
632: location . line = line ;
633: while ( cback ( ) . op != '#' ) {
634: deleteToken ( back ( ) ) ; }
635: deleteToken ( back ( ) ) ;
636: return ;
637: }
638: }
639:
640: static const std :: string COMMENT_END ( "*/" ) ;
641:
642: void simplecpp :: TokenList :: readfile ( Stream & stream , const std :: string & filename , std :: list < Output > * outputList )
643: {
644: std :: stack < simplecpp :: Location > loc ;
645:
646: unsigned int multiline ; multiline = 0U ;
647:
648: const Token * oldLastToken ; oldLastToken = nullptr ;
649:
650: Location location ( files ) ;
651: location . fileIndex = fileIndex ( filename ) ;
652: location . line = 1U ;
653: location . col = 1U ;
654: while ( stream . good ( ) ) {
655: unsigned char ch ; ch = stream . readChar ( ) ;
656: if ( ! stream . good ( ) ) {
657: break ; }
658:
659: if ( ch >= 0x80 ) {
660: if ( outputList ) {
661: simplecpp :: Output err ( files ) ;
662: err . type = simplecpp :: Output :: UNHANDLED_CHAR_ERROR ;
663: err . location = location ;
664: std :: ostringstream s ;
665: s << static_cast < int > ( ch ) ;
666: err . msg = "The code contains unhandled character(s) (character code=" + s . str ( ) + "). Neither unicode nor extended ascii is supported." ;
667: outputList . push_back ( err ) ;
668: }
669: clear ( ) ;
670: return ;
671: }
672:
673: if ( ch == '\n' ) {
674: if ( cback ( ) && cback ( ) . op == '\\' ) {
675: if ( location . col > cback ( ) . location . col + 1U ) {
676: portabilityBackslash ( outputList , files , cback ( ) . location ) ; }
677: ++ multiline ;
678: deleteToken ( back ( ) ) ;
679: } else {
680: location . line += multiline + 1 ;
681: multiline = 0U ;
682: }
683: if ( ! multiline ) {
684: location . col = 1 ; }
685:
686: if ( oldLastToken != cback ( ) ) {
687: oldLastToken = cback ( ) ;
688: if ( ! isLastLinePreprocessor ( ) ) {
689: continue ; }
690: const std :: string lastline ( lastLine ( ) ) ;
691: if ( lastline == "# file %str%" ) {
692: const Token * strtok ; strtok = cback ( ) ;
693: while ( strtok . comment ) {
694: strtok = strtok . previous ; }
695: loc . push ( location ) ;
696: location . fileIndex = fileIndex ( strtok . str ( ) . substr ( 1U , strtok . str ( ) . size ( ) - 2U ) ) ;
697: location . line = 1U ;
698: } else if ( lastline == "# line %num%" ) {
699: const Token * numtok ; numtok = cback ( ) ;
700: while ( numtok . comment ) {
701: numtok = numtok . previous ; }
702: lineDirective ( location . fileIndex , std :: atol ( numtok . str ( ) . c_str ( ) ) , & location ) ;
703: } else if ( lastline == "# %num% %str%" || lastline == "# line %num% %str%" ) {
704: const Token * strtok ; strtok = cback ( ) ;
705: while ( strtok . comment ) {
706: strtok = strtok . previous ; }
707: const Token * numtok ; numtok = strtok . previous ;
708: while ( numtok . comment ) {
709: numtok = numtok . previous ; }
710: lineDirective ( fileIndex ( replaceAll ( strtok . str ( ) . substr ( 1U , strtok . str ( ) . size ( ) - 2U ) , "\\\\" , "\\" ) ) ,
711: std :: atol ( numtok . str ( ) . c_str ( ) ) , & location ) ;
712: }
713:
714: else if ( lastline == "# endfile" && ! loc . empty ( ) ) {
715: location = loc . top ( ) ;
716: loc . pop ( ) ;
717: }
718: }
719:
720: continue ;
721: }
722:
723: if ( ch <= ' ' ) {
724: location . col ++ ;
725: continue ;
726: }
727:
728: std :: string currentToken ;
729:
730: if ( cback ( ) && cback ( ) . location . line == location . line && cback ( ) . previous && cback ( ) . previous . op == '#' ) {
731: const Token * const llTok ; llTok = lastLineTok ( ) ;
732: if ( llTok && llTok . op == '#' && llTok . next && ( llTok . next . str ( ) == "error" || llTok . next . str ( ) == "warning" ) ) {
733: char prev ; prev = ' ' ;
734: while ( stream . good ( ) && ( prev == '\\' || ( ch != '\r' && ch != '\n' ) ) ) {
735: currentToken += ch ;
736: prev = ch ;
737: ch = stream . readChar ( ) ;
738: }
739: stream . ungetChar ( ) ;
740: push_back ( new Token ( currentToken , location ) ) ;
741: location . adjust ( currentToken ) ;
742: continue ;
743: }
744: }
745:
746:
747: if ( isNameChar ( ch ) ) {
748: const bool num = std :: isdigit ( ch ) ;
749: while ( stream . good ( ) && isNameChar ( ch ) ) {
750: currentToken += ch ;
751: ch = stream . readChar ( ) ;
752: if ( num && ch == '\'' && isNameChar ( stream . peekChar ( ) ) ) {
753: ch = stream . readChar ( ) ; }
754: }
755:
756: stream . ungetChar ( ) ;
757: }
758:
759:
760: else if ( ch == '/' && stream . peekChar ( ) == '/' ) {
761: while ( stream . good ( ) && ch != '\n' ) {
762: currentToken += ch ;
763: ch = stream . readChar ( ) ;
764: if ( ch == '\\' ) {
765: std :: string tmp ;
766: char tmp_ch ; tmp_ch = ch ;
767: while ( ( stream . good ( ) ) && ( tmp_ch == '\\' || tmp_ch == ' ' || tmp_ch == '\t' ) ) {
768: tmp += tmp_ch ;
769: tmp_ch = stream . readChar ( ) ;
770: }
771: if ( ! stream . good ( ) ) {
772: break ;
773: }
774:
775: if ( tmp_ch != '\n' ) {
776: currentToken += tmp ;
777: } else {
778: const std :: string check_portability = currentToken + tmp ;
779: const std :: string :: size_type pos = check_portability . find_last_not_of ( " \t" ) ;
780: if ( pos < check_portability . size ( ) - 1U && check_portability [ pos ] == '\\' ) {
781: portabilityBackslash ( outputList , files , location ) ; }
782: ++ multiline ;
783: tmp_ch = stream . readChar ( ) ;
784: currentToken += '\n' ;
785: }
786: ch = tmp_ch ;
787: }
788: }
789: if ( ch == '\n' ) {
790: stream . ungetChar ( ) ;
791: }
792: }
793:
794:
795: else if ( ch == '/' && stream . peekChar ( ) == '*' ) {
796: currentToken = "/*" ;
797: ( void ) stream . readChar ( ) ;
798: ch = stream . readChar ( ) ;
799: while ( stream . good ( ) ) {
800: currentToken += ch ;
801: if ( currentToken . size ( ) >= 4U && endsWith ( currentToken , COMMENT_END ) ) {
802: break ; }
803: ch = stream . readChar ( ) ;
804: }
805:
806:
807: std :: string :: size_type pos ; pos = 0 ;
808: while ( ( pos = currentToken . find ( "\\\n" , pos ) ) != std :: string :: npos ) {
809: currentToken . erase ( pos , 2 ) ;
810: ++ multiline ;
811: }
812: if ( multiline || isLastLinePreprocessor ( ) ) {
813: pos = 0 ;
814: while ( ( pos = currentToken . find ( '\n' , pos ) ) != std :: string :: npos ) {
815: currentToken . erase ( pos , 1 ) ;
816: ++ multiline ;
817: }
818: }
819: }
820:
821:
822: else if ( ch == '\"' || ch == '\'' ) {
823: std :: string prefix ;
824: if ( cback ( ) && cback ( ) . name && isStringLiteralPrefix ( cback ( ) . str ( ) ) &&
825: ( ( cback ( ) . location . col + cback ( ) . str ( ) . size ( ) ) == location . col ) &&
826: ( cback ( ) . location . line == location . line ) ) {
827: prefix = cback ( ) . str ( ) ;
828: }
829:
830: if ( ch == '\"' && ! prefix . empty ( ) && * cback ( ) . str ( ) . rbegin ( ) == 'R' ) {
831: std :: string delim ;
832: currentToken = ch ;
833: prefix . resize ( prefix . size ( ) - 1 ) ;
834: ch = stream . readChar ( ) ;
835: while ( stream . good ( ) && ch != '(' && ch != '\n' ) {
836: delim += ch ;
837: ch = stream . readChar ( ) ;
838: }
839: if ( ! stream . good ( ) || ch == '\n' ) {
840: if ( outputList ) {
841: Output err ( files ) ;
842: err . type = Output :: SYNTAX_ERROR ;
843: err . location = location ;
844: err . msg = "Invalid newline in raw string delimiter." ;
845: outputList . push_back ( err ) ;
846: }
847: return ;
848: }
849: const std :: string endOfRawString ( ')' + delim + currentToken ) ;
850: while ( stream . good ( ) && ! ( endsWith ( currentToken , endOfRawString ) && currentToken . size ( ) > 1 ) ) {
851: currentToken += stream . readChar ( ) ; }
852: if ( ! endsWith ( currentToken , endOfRawString ) ) {
853: if ( outputList ) {
854: Output err ( files ) ;
855: err . type = Output :: SYNTAX_ERROR ;
856: err . location = location ;
857: err . msg = "Raw string missing terminating delimiter." ;
858: outputList . push_back ( err ) ;
859: }
860: return ;
861: }
862: currentToken . erase ( currentToken . size ( ) - endOfRawString . size ( ) , endOfRawString . size ( ) - 1U ) ;
863: currentToken = escapeString ( currentToken ) ;
864: currentToken . insert ( 0 , prefix ) ;
865: back ( ) . setstr ( currentToken ) ;
866: location . adjust ( currentToken ) ;
867: if ( currentToken . find_first_of ( "\r\n" ) == std :: string :: npos ) {
868: location . col += 2 + 2 * delim . size ( ) ; }
869: else {
870: location . col += 1 + delim . size ( ) ; }
871:
872: continue ;
873: }
874:
875: currentToken = readUntil ( stream , location , ch , ch , outputList ) ;
876: if ( currentToken . size ( ) < 2U ) {
877:
878: return ; }
879:
880: std :: string s ; s = currentToken ;
881: std :: string :: size_type pos ;
882: int newlines ; newlines = 0 ;
883: while ( ( pos = s . find_first_of ( "\r\n" ) ) != std :: string :: npos ) {
884: s . erase ( pos , 1 ) ;
885: newlines ++ ;
886: }
887:
888: if ( prefix . empty ( ) ) {
889: push_back ( new Token ( s , location , std :: isspace ( stream . peekChar ( ) ) ) ) ; }
890: else {
891: back ( ) . setstr ( prefix + s ) ; }
892:
893: if ( newlines > 0 ) {
894: const Token * const llTok ; llTok = lastLineTok ( ) ;
895: if ( llTok && llTok . op == '#' && llTok . next && ( llTok . next . str ( ) == "define" || llTok . next . str ( ) == "pragma" ) && llTok . next . next ) {
896: multiline += newlines ;
897: location . adjust ( s ) ;
898: continue ;
899: }
900: }
901:
902: location . adjust ( currentToken ) ;
903: continue ;
904: }
905:
906: else {
907: currentToken += ch ;
908: }
909:
910: if ( * currentToken . begin ( ) == '<' ) {
911: const Token * const llTok ; llTok = lastLineTok ( ) ;
912: if ( llTok && llTok . op == '#' && llTok . next && llTok . next . str ( ) == "include" ) {
913: currentToken = readUntil ( stream , location , '<' , '>' , outputList ) ;
914: if ( currentToken . size ( ) < 2U ) {
915: return ; }
916: }
917: }
918:
919: push_back ( new Token ( currentToken , location , std :: isspace ( stream . peekChar ( ) ) ) ) ;
920:
921: if ( multiline ) {
922: location . col += currentToken . size ( ) ; }
923: else {
924: location . adjust ( currentToken ) ; }
925: }
926:
927: combineOperators ( ) ;
928: }
929:
930: void simplecpp :: TokenList :: constFold ( )
931: {
932: while ( cfront ( ) ) {
933:
934: Token * tok ; tok = back ( ) ;
935: while ( tok && tok . op != '(' ) {
936: tok = tok . previous ; }
937:
938:
939: if ( ! tok ) {
940: tok = front ( ) ; }
941:
942:
943: constFoldUnaryNotPosNeg ( tok ) ;
944: constFoldMulDivRem ( tok ) ;
945: constFoldAddSub ( tok ) ;
946: constFoldShift ( tok ) ;
947: constFoldComparison ( tok ) ;
948: constFoldBitwise ( tok ) ;
949: constFoldLogicalOp ( tok ) ;
950: constFoldQuestionOp ( & tok ) ;
951:
952:
953: if ( tok . op != '(' ) {
954: break ; }
955:
956: if ( ! tok . next || ! tok . next . next || tok . next . next . op != ')' ) {
957: break ; }
958:
959: tok = tok . next ;
960: deleteToken ( tok . previous ) ;
961: deleteToken ( tok . next ) ;
962: }
963: }
964:
965: static bool isFloatSuffix ( const simplecpp :: Token * tok )
966: {
967: if ( ! tok || tok . str ( ) . size ( ) != 1U ) {
968: return false ; }
969: const char c = std :: tolower ( tok . str ( ) [ 0 ] ) ;
970: return c == 'f' || c == 'l' ;
971: }
972:
973: void simplecpp :: TokenList :: combineOperators ( )
974: {
975: std :: stack < bool > executableScope ;
976: executableScope . push ( false ) ;
977: for ( Token * tok = front ( ) ; tok ; tok = tok . next ) {
978: if ( tok . op == '{' ) {
979: if ( executableScope . top ( ) ) {
980: executableScope . push ( true ) ;
981: continue ;
982: }
983: const Token * prev ; prev = tok . previous ;
984: while ( prev && prev . isOneOf ( ";{}()" ) ) {
985: prev = prev . previous ; }
986: executableScope . push ( prev && prev . op == ')' ) ;
987: continue ;
988: }
989: if ( tok . op == '}' ) {
990: if ( executableScope . size ( ) > 1 ) {
991: executableScope . pop ( ) ; }
992: continue ;
993: }
994:
995: if ( tok . op == '.' ) {
996:
997: if ( tok . next && tok . next . op == '.' && tok . next . location . col == ( tok . location . col + 1 ) &&
998: tok . next . next && tok . next . next . op == '.' && tok . next . next . location . col == ( tok . location . col + 2 ) ) {
999: tok . setstr ( "..." ) ;
1000: deleteToken ( tok . next ) ;
1001: deleteToken ( tok . next ) ;
1002: continue ;
1003: }
1004:
1005: if ( tok . previous && tok . previous . number && sameline ( tok . previous , tok ) && tok . previous . str ( ) . find_first_of ( "._" ) == std :: string :: npos ) {
1006: tok . setstr ( tok . previous . str ( ) + '.' ) ;
1007: deleteToken ( tok . previous ) ;
1008: if ( sameline ( tok , tok . next ) && ( isFloatSuffix ( tok . next ) || ( tok . next && tok . next . startsWithOneOf ( "AaBbCcDdEeFfPp" ) ) ) ) {
1009: tok . setstr ( tok . str ( ) + tok . next . str ( ) ) ;
1010: deleteToken ( tok . next ) ;
1011: }
1012: }
1013: if ( tok . next && tok . next . number ) {
1014: tok . setstr ( tok . str ( ) + tok . next . str ( ) ) ;
1015: deleteToken ( tok . next ) ;
1016: }
1017: }
1018:
1019: const char lastChar = tok . str ( ) [ tok . str ( ) . size ( ) - 1 ] ;
1020: if ( tok . number && ! isOct ( tok . str ( ) ) &&
1021: ( ( ! isHex ( tok . str ( ) ) && ( lastChar == 'E' || lastChar == 'e' ) ) ||
1022: ( isHex ( tok . str ( ) ) && ( lastChar == 'P' || lastChar == 'p' ) ) ) &&
1023: tok . next && tok . next . isOneOf ( "+-" ) && tok . next . next && tok . next . next . number ) {
1024: tok . setstr ( tok . str ( ) + tok . next . op + tok . next . next . str ( ) ) ;
1025: deleteToken ( tok . next ) ;
1026: deleteToken ( tok . next ) ;
1027: }
1028:
1029: if ( tok . op == '\0' || ! tok . next || tok . next . op == '\0' ) {
1030: continue ; }
1031: if ( ! sameline ( tok , tok . next ) ) {
1032: continue ; }
1033: if ( tok . location . col + 1U != tok . next . location . col ) {
1034: continue ; }
1035:
1036: if ( tok . next . op == '=' && tok . isOneOf ( "=!<>+-*/%&|^" ) ) {
1037: if ( tok . op == '&' && ! executableScope . top ( ) ) {
1038:
1039:
1040: int indentlevel ; indentlevel = 0 ;
1041: const Token * start ; start = tok ;
1042: while ( indentlevel >= 0 && start ) {
1043: if ( start . op == ')' ) {
1044: ++ indentlevel ; }
1045: else if ( start . op == '(' ) {
1046: -- indentlevel ; }
1047: else if ( start . isOneOf ( ";{}" ) ) {
1048: break ; }
1049: start = start . previous ;
1050: }
1051: if ( indentlevel == -1 && start ) {
1052: const Token * const ftok ; ftok = start ;
1053: bool isFuncDecl ; isFuncDecl = ftok . name ;
1054: while ( isFuncDecl ) {
1055: if ( ! start . name && start . str ( ) != "::" && start . op != '*' && start . op != '&' ) {
1056: isFuncDecl = false ; }
1057: if ( ! start . previous ) {
1058: break ; }
1059: if ( start . previous . isOneOf ( ";{}:" ) ) {
1060: break ; }
1061: start = start . previous ;
1062: }
1063: isFuncDecl &= start != ftok && start . name ;
1064: if ( isFuncDecl ) {
1065:
1066: continue ;
1067: }
1068: }
1069: }
1070: tok . setstr ( tok . str ( ) + "=" ) ;
1071: deleteToken ( tok . next ) ;
1072: } else if ( ( tok . op == '|' || tok . op == '&' ) && tok . op == tok . next . op ) {
1073: tok . setstr ( tok . str ( ) + tok . next . str ( ) ) ;
1074: deleteToken ( tok . next ) ;
1075: } else if ( tok . op == ':' && tok . next . op == ':' ) {
1076: tok . setstr ( tok . str ( ) + tok . next . str ( ) ) ;
1077: deleteToken ( tok . next ) ;
1078: } else if ( tok . op == '-' && tok . next . op == '>' ) {
1079: tok . setstr ( tok . str ( ) + tok . next . str ( ) ) ;
1080: deleteToken ( tok . next ) ;
1081: } else if ( ( tok . op == '<' || tok . op == '>' ) && tok . op == tok . next . op ) {
1082: tok . setstr ( tok . str ( ) + tok . next . str ( ) ) ;
1083: deleteToken ( tok . next ) ;
1084: if ( tok . next && tok . next . op == '=' && tok . next . next && tok . next . next . op != '=' ) {
1085: tok . setstr ( tok . str ( ) + tok . next . str ( ) ) ;
1086: deleteToken ( tok . next ) ;
1087: }
1088: } else if ( ( tok . op == '+' || tok . op == '-' ) && tok . op == tok . next . op ) {
1089: if ( tok . location . col + 1U != tok . next . location . col ) {
1090: continue ; }
1091: if ( tok . previous && tok . previous . number ) {
1092: continue ; }
1093: if ( tok . next . next && tok . next . next . number ) {
1094: continue ; }
1095: tok . setstr ( tok . str ( ) + tok . next . str ( ) ) ;
1096: deleteToken ( tok . next ) ;
1097: }
1098: }
1099: }
1100:
1101: static const std :: string COMPL ( "compl" ) ;
1102: static const std :: string NOT ( "not" ) ;
1103: void simplecpp :: TokenList :: constFoldUnaryNotPosNeg ( simplecpp :: Token * tok )
1104: {
1105: for ( ; tok && tok . op != ')' ; tok = tok . next ) {
1106:
1107: if ( isAlternativeUnaryOp ( tok , NOT ) ) {
1108: tok . op = '!' ; }
1109:
1110: else if ( isAlternativeUnaryOp ( tok , COMPL ) ) {
1111: tok . op = '~' ; }
1112:
1113: if ( tok . op == '!' && tok . next && tok . next . number ) {
1114: tok . setstr ( tok . next . str ( ) == "0" ? "1" : "0" ) ;
1115: deleteToken ( tok . next ) ;
1116: } else if ( tok . op == '~' && tok . next && tok . next . number ) {
1117: tok . setstr ( toString ( ~ stringToLL ( tok . next . str ( ) ) ) ) ;
1118: deleteToken ( tok . next ) ;
1119: } else {
1120: if ( tok . previous && ( tok . previous . number || tok . previous . name ) ) {
1121: continue ; }
1122: if ( ! tok . next || ! tok . next . number ) {
1123: continue ; }
1124: switch ( tok . op ) {
1125: case '+' : ;
1126: tok . setstr ( tok . next . str ( ) ) ;
1127: deleteToken ( tok . next ) ;
1128: break ;
1129: case '-' : ;
1130: tok . setstr ( tok . op + tok . next . str ( ) ) ;
1131: deleteToken ( tok . next ) ;
1132: break ;
1133: }
1134: }
1135: }
1136: }
1137:
1138: void simplecpp :: TokenList :: constFoldMulDivRem ( Token * tok )
1139: {
1140: for ( ; tok && tok . op != ')' ; tok = tok . next ) {
1141: if ( ! tok . previous || ! tok . previous . number ) {
1142: continue ; }
1143: if ( ! tok . next || ! tok . next . number ) {
1144: continue ; }
1145:
1146: long long result ;
1147: if ( tok . op == '*' ) {
1148: result = stringToLL ( tok . previous . str ( ) ) * stringToLL ( tok . next . str ( ) ) ; }
1149: else if ( tok . op == '/' || tok . op == '%' ) {
1150: const long long rhs = stringToLL ( tok . next . str ( ) ) ;
1151: if ( rhs == 0 ) {
1152: throw std :: overflow_error ( "division/modulo by zero" ) ; }
1153: const long long lhs = stringToLL ( tok . previous . str ( ) ) ;
1154: if ( rhs == -1 && lhs == std :: numeric_limits < long long > :: min ( ) ) {
1155: throw std :: overflow_error ( "division overflow" ) ; }
1156: if ( tok . op == '/' ) {
1157: result = lhs / rhs ; }
1158: else {
1159: result = lhs % rhs ; }
1160: } else {
1161: continue ; }
1162:
1163: tok = tok . previous ;
1164: tok . setstr ( toString ( result ) ) ;
1165: deleteToken ( tok . next ) ;
1166: deleteToken ( tok . next ) ;
1167: }
1168: }
1169:
1170: void simplecpp :: TokenList :: constFoldAddSub ( Token * tok )
1171: {
1172: for ( ; tok && tok . op != ')' ; tok = tok . next ) {
1173: if ( ! tok . previous || ! tok . previous . number ) {
1174: continue ; }
1175: if ( ! tok . next || ! tok . next . number ) {
1176: continue ; }
1177:
1178: long long result ;
1179: if ( tok . op == '+' ) {
1180: result = stringToLL ( tok . previous . str ( ) ) + stringToLL ( tok . next . str ( ) ) ; }
1181: else if ( tok . op == '-' ) {
1182: result = stringToLL ( tok . previous . str ( ) ) - stringToLL ( tok . next . str ( ) ) ; }
1183: else {
1184: continue ; }
1185:
1186: tok = tok . previous ;
1187: tok . setstr ( toString ( result ) ) ;
1188: deleteToken ( tok . next ) ;
1189: deleteToken ( tok . next ) ;
1190: }
1191: }
1192:
1193: void simplecpp :: TokenList :: constFoldShift ( Token * tok )
1194: {
1195: for ( ; tok && tok . op != ')' ; tok = tok . next ) {
1196: if ( ! tok . previous || ! tok . previous . number ) {
1197: continue ; }
1198: if ( ! tok . next || ! tok . next . number ) {
1199: continue ; }
1200:
1201: long long result ;
1202: if ( tok . str ( ) == "<<" ) {
1203: result = stringToLL ( tok . previous . str ( ) ) << stringToLL ( tok . next . str ( ) ) ; }
1204: else if ( tok . str ( ) == ">>" ) {
1205: result = stringToLL ( tok . previous . str ( ) ) >> stringToLL ( tok . next . str ( ) ) ; }
1206: else {
1207: continue ; }
1208:
1209: tok = tok . previous ;
1210: tok . setstr ( toString ( result ) ) ;
1211: deleteToken ( tok . next ) ;
1212: deleteToken ( tok . next ) ;
1213: }
1214: }
1215:
1216: static const std :: string NOTEQ ( "not_eq" ) ;
1217: void simplecpp :: TokenList :: constFoldComparison ( Token * tok )
1218: {
1219: for ( ; tok && tok . op != ')' ; tok = tok . next ) {
1220: if ( isAlternativeBinaryOp ( tok , NOTEQ ) ) {
1221: tok . setstr ( "!=" ) ; }
1222:
1223: if ( ! tok . startsWithOneOf ( "<>=!" ) ) {
1224: continue ; }
1225: if ( ! tok . previous || ! tok . previous . number ) {
1226: continue ; }
1227: if ( ! tok . next || ! tok . next . number ) {
1228: continue ; }
1229:
1230: int result ;
1231: if ( tok . str ( ) == "==" ) {
1232: result = stringToLL ( tok . previous . str ( ) ) == stringToLL ( tok . next . str ( ) ) ; }
1233: else if ( tok . str ( ) == "!=" ) {
1234: result = stringToLL ( tok . previous . str ( ) ) != stringToLL ( tok . next . str ( ) ) ; }
1235: else if ( tok . str ( ) == ">" ) {
1236: result = stringToLL ( tok . previous . str ( ) ) > stringToLL ( tok . next . str ( ) ) ; }
1237: else if ( tok . str ( ) == ">=" ) {
1238: result = stringToLL ( tok . previous . str ( ) ) >= stringToLL ( tok . next . str ( ) ) ; }
1239: else if ( tok . str ( ) == "<" ) {
1240: result = stringToLL ( tok . previous . str ( ) ) < stringToLL ( tok . next . str ( ) ) ; }
1241: else if ( tok . str ( ) == "<=" ) {
1242: result = stringToLL ( tok . previous . str ( ) ) <= stringToLL ( tok . next . str ( ) ) ; }
1243: else {
1244: continue ; }
1245:
1246: tok = tok . previous ;
1247: tok . setstr ( toString ( result ) ) ;
1248: deleteToken ( tok . next ) ;
1249: deleteToken ( tok . next ) ;
1250: }
1251: }
1252:
1253: static const std :: string BITAND ( "bitand" ) ;
1254: static const std :: string BITOR ( "bitor" ) ;
1255: static const std :: string XOR ( "xor" ) ;
1256: void simplecpp :: TokenList :: constFoldBitwise ( Token * tok )
1257: {
1258: Token * const tok1 ; tok1 = tok ;
1259: for ( const char * op = "&^|" ; * op ; op ++ ) {
1260: const std :: string * alternativeOp ;
1261: if ( * op == '&' ) {
1262: alternativeOp = & BITAND ; }
1263: else if ( * op == '|' ) {
1264: alternativeOp = & BITOR ; }
1265: else {
1266: alternativeOp = & XOR ; }
1267: for ( tok = tok1 ; tok && tok . op != ')' ; tok = tok . next ) {
1268: if ( tok . op != * op && ! isAlternativeBinaryOp ( tok , * alternativeOp ) ) {
1269: continue ; }
1270: if ( ! tok . previous || ! tok . previous . number ) {
1271: continue ; }
1272: if ( ! tok . next || ! tok . next . number ) {
1273: continue ; }
1274: long long result ;
1275: if ( * op == '&' ) {
1276: result = stringToLL ( tok . previous . str ( ) ) & stringToLL ( tok . next . str ( ) ) ; }
1277: else if ( * op == '^' ) {
1278: result = stringToLL ( tok . previous . str ( ) ) ^ stringToLL ( tok . next . str ( ) ) ; }
1279: else {
1280: result = stringToLL ( tok . previous . str ( ) ) | stringToLL ( tok . next . str ( ) ) ; }
1281: tok = tok . previous ;
1282: tok . setstr ( toString ( result ) ) ;
1283: deleteToken ( tok . next ) ;
1284: deleteToken ( tok . next ) ;
1285: }
1286: }
1287: }
1288:
1289: static const std :: string AND ( "and" ) ;
1290: static const std :: string OR ( "or" ) ;
1291: void simplecpp :: TokenList :: constFoldLogicalOp ( Token * tok )
1292: {
1293: for ( ; tok && tok . op != ')' ; tok = tok . next ) {
1294: if ( tok . name ) {
1295: if ( isAlternativeBinaryOp ( tok , AND ) ) {
1296: tok . setstr ( "&&" ) ; }
1297: else if ( isAlternativeBinaryOp ( tok , OR ) ) {
1298: tok . setstr ( "||" ) ; }
1299: }
1300: if ( tok . str ( ) != "&&" && tok . str ( ) != "||" ) {
1301: continue ; }
1302: if ( ! tok . previous || ! tok . previous . number ) {
1303: continue ; }
1304: if ( ! tok . next || ! tok . next . number ) {
1305: continue ; }
1306:
1307: int result ;
1308: if ( tok . str ( ) == "||" ) {
1309: result = stringToLL ( tok . previous . str ( ) ) || stringToLL ( tok . next . str ( ) ) ; }
1310: else {
1311: result = stringToLL ( tok . previous . str ( ) ) && stringToLL ( tok . next . str ( ) ) ; }
1312:
1313: tok = tok . previous ;
1314: tok . setstr ( toString ( result ) ) ;
1315: deleteToken ( tok . next ) ;
1316: deleteToken ( tok . next ) ;
1317: }
1318: }
1319:
1320: void simplecpp :: TokenList :: constFoldQuestionOp ( Token * * tok1 )
1321: {
1322: bool gotoTok1 ; gotoTok1 = false ;
1323: for ( Token * tok = * tok1 ; tok && tok . op != ')' ; tok = gotoTok1 ? * tok1 : tok . next ) {
1324: gotoTok1 = false ;
1325: if ( tok . str ( ) != "?" ) {
1326: continue ; }
1327: if ( ! tok . previous || ! tok . next || ! tok . next . next ) {
1328: throw std :: runtime_error ( "invalid expression" ) ; }
1329: if ( ! tok . previous . number ) {
1330: continue ; }
1331: if ( tok . next . next . op != ':' ) {
1332: continue ; }
1333: Token * const condTok ; condTok = tok . previous ;
1334: Token * const trueTok ; trueTok = tok . next ;
1335: Token * const falseTok ; falseTok = trueTok . next . next ;
1336: if ( ! falseTok ) {
1337: throw std :: runtime_error ( "invalid expression" ) ; }
1338: if ( condTok == * tok1 ) {
1339: * tok1 = condTok . str ( ) != "0" ? trueTok : falseTok ; }
1340: deleteToken ( condTok . next ) ;
1341: deleteToken ( trueTok . next ) ;
1342: deleteToken ( condTok . str ( ) == "0" ? trueTok : falseTok ) ;
1343: deleteToken ( condTok ) ;
1344: gotoTok1 = true ;
1345: }
1346: }
1347:
1348: void simplecpp :: TokenList :: removeComments ( )
1349: {
1350: Token * tok ; tok = frontToken ;
1351: while ( tok ) {
1352: Token * const tok1 ; tok1 = tok ;
1353: tok = tok . next ;
1354: if ( tok1 . comment ) {
1355: deleteToken ( tok1 ) ; }
1356: }
1357: }
1358:
1359: std :: string simplecpp :: TokenList :: readUntil ( Stream & stream , const Location & location , const char start , const char end , std :: list < Output > * outputList )
1360: {
1361: std :: string ret ;
1362: ret += start ;
1363:
1364: bool backslash ; backslash = false ;
1365: char ch ; ch = 0 ;
1366: while ( ch != end && ch != '\r' && ch != '\n' && stream . good ( ) ) {
1367: ch = stream . readChar ( ) ;
1368: if ( backslash && ch == '\n' ) {
1369: ch = 0 ;
1370: backslash = false ;
1371: continue ;
1372: }
1373: backslash = false ;
1374: ret += ch ;
1375: if ( ch == '\\' ) {
1376: bool update_ch ; update_ch = false ;
1377: char next ; next = 0 ;
1378: do {
1379: next = stream . readChar ( ) ;
1380: if ( next == '\r' || next == '\n' ) {
1381: ret . erase ( ret . size ( ) - 1U ) ;
1382: backslash = next == '\r' ;
1383: update_ch = false ;
1384: } else if ( next == '\\' ) {
1385: update_ch = ! update_ch ; }
1386: ret += next ;
1387: } while ( next == '\\' ) ;
1388: if ( update_ch ) {
1389: ch = next ; }
1390: }
1391: }
1392:
1393: if ( ! stream . good ( ) || ch != end ) {
1394: clear ( ) ;
1395: if ( outputList ) {
1396: Output err ( files ) ;
1397: err . type = Output :: SYNTAX_ERROR ;
1398: err . location = location ;
1399: err . msg = std :: string ( "No pair for character (" ) + start + "). Can't process file. File is either invalid or unicode, which is currently not supported." ;
1400: outputList . push_back ( err ) ;
1401: }
1402: return "" ;
1403: }
1404:
1405: return ret ;
1406: }
1407:
1408: std :: string simplecpp :: TokenList :: lastLine ( int maxsize ) const
1409: {
1410: std :: string ret ;
1411: int count ; count = 0 ;
1412: for ( const Token * tok = cback ( ) ; ; tok = tok . previous ) {
1413: if ( ! sameline ( tok , cback ( ) ) ) {
1414: break ;
1415: }
1416: if ( tok . comment ) {
1417: continue ; }
1418: if ( ++ count > maxsize ) {
1419: return "" ; }
1420: if ( ! ret . empty ( ) ) {
1421: ret += ' ' ; }
1422:
1423: if ( tok . str ( ) [ 0 ] == '\"' ) {
1424: ret += "%rts%" ; }
1425: else if ( tok . number ) {
1426: ret += "%mun%" ; }
1427: else {
1428: ret += tok . str ( ) ;
1429: std :: reverse ( ret . end ( ) - tok . str ( ) . length ( ) , ret . end ( ) ) ;
1430: }
1431: }
1432: std :: reverse ( ret . begin ( ) , ret . end ( ) ) ;
1433: return ret ;
1434: }
1435:
1436: const simplecpp :: Token * simplecpp :: TokenList :: lastLineTok ( int maxsize ) const
1437: {
1438: const Token * prevTok ; prevTok = nullptr ;
1439: int count ; count = 0 ;
1440: for ( const Token * tok = cback ( ) ; ; tok = tok . previous ) {
1441: if ( ! sameline ( tok , cback ( ) ) ) {
1442: break ; }
1443: if ( tok . comment ) {
1444: continue ; }
1445: if ( ++ count > maxsize ) {
1446: return nullptr ; }
1447: prevTok = tok ;
1448: }
1449: return prevTok ;
1450: }
1451:
1452: bool simplecpp :: TokenList :: isLastLinePreprocessor ( int maxsize ) const
1453: {
1454: const Token * const prevTok ; prevTok = lastLineTok ( maxsize ) ;
1455: return prevTok && prevTok . op == '#' ;
1456: }
1457:
1458: unsigned int simplecpp :: TokenList :: fileIndex ( const std :: string & filename )
1459: {
1460: for ( unsigned int i = 0 ; i < files . size ( ) ; ++ i ) {
1461: if ( files [ i ] == filename ) {
1462: return i ; }
1463: }
1464: files . push_back ( filename ) ;
1465: return files . size ( ) - 1U ;
1466: }
1467:
1468:
1469: namespace simplecpp {
1470: class Macro ;
1471:
1472:
1473: class Macro {
1474: public:
1475: explicit Macro ( std :: vector < std :: string > & f ) : nameTokDef ( nullptr ) , valueToken ( nullptr ) , endToken ( nullptr ) , files ( f ) , tokenListDefine ( f ) , variadic ( false ) , variadicOpt ( false ) , optExpandValue ( nullptr ) , optNoExpandValue ( nullptr ) , valueDefinedInCode_ ( false ) { }
1476:
1477: Macro ( const Token * tok , std :: vector < std :: string > & f ) : nameTokDef ( nullptr ) , files ( f ) , tokenListDefine ( f ) , valueDefinedInCode_ ( true ) {
1478: if ( sameline ( tok . previousSkipComments ( ) , tok ) ) {
1479: throw std :: runtime_error ( "bad macro syntax" ) ; }
1480: if ( tok . op != '#' ) {
1481: throw std :: runtime_error ( "bad macro syntax" ) ; }
1482: const Token * const hashtok ; hashtok = tok ;
1483: tok = tok . next ;
1484: if ( ! tok || tok . str ( ) != DEFINE ) {
1485: throw std :: runtime_error ( "bad macro syntax" ) ; }
1486: tok = tok . next ;
1487: if ( ! tok || ! tok . name || ! sameline ( hashtok , tok ) ) {
1488: throw std :: runtime_error ( "bad macro syntax" ) ; }
1489: if ( ! parseDefine ( tok ) ) {
1490: throw std :: runtime_error ( "bad macro syntax" ) ; }
1491: }
1492:
1493: Macro ( const std :: string & name , const std :: string & value , std :: vector < std :: string > & f ) : nameTokDef ( nullptr ) , files ( f ) , tokenListDefine ( f ) , valueDefinedInCode_ ( false ) {
1494: const std :: string def ( name + ' ' + value ) ;
1495: StdCharBufStream stream ( reinterpret_cast < const unsigned char * > ( def . data ( ) ) , def . size ( ) ) ;
1496: tokenListDefine . readfile ( stream ) ;
1497: if ( ! parseDefine ( tokenListDefine . cfront ( ) ) ) {
1498: throw std :: runtime_error ( "bad macro syntax. macroname=" + name + " value=" + value ) ; }
1499: }
1500:
1501: Macro ( const Macro & other ) : nameTokDef ( nullptr ) , files ( other . files ) , tokenListDefine ( other . files ) , valueDefinedInCode_ ( other . valueDefinedInCode_ ) {
1502: * this = other ;
1503: }
1504:
1505: ~ Macro ( ) {
1506: delete optExpandValue ;
1507: delete optNoExpandValue ;
1508: }
1509:
1510: Macro & operator= ( const Macro & other ) {
1511: if ( this != & other ) {
1512: files = other . files ;
1513: valueDefinedInCode_ = other . valueDefinedInCode_ ;
1514: if ( other . tokenListDefine . empty ( ) ) {
1515: parseDefine ( other . nameTokDef ) ; }
1516: else {
1517: tokenListDefine = other . tokenListDefine ;
1518: parseDefine ( tokenListDefine . cfront ( ) ) ;
1519: }
1520: usageList = other . usageList ;
1521: }
1522: return * this ;
1523: }
1524:
1525: bool valueDefinedInCode ( ) const {
1526: return valueDefinedInCode_ ;
1527: }
1528:
|
1537:
1538: const Token * expand ( TokenList * const output ,
1539: const Token * rawtok ,
1540: const std :: unordered_map < std :: string , Macro > & macros ,
1541: std :: vector < std :: string > & inputFiles ) const {
1542: std :: set < std :: string > expandedmacros ;
1543:
|
1547:
1548: TokenList output2 ( inputFiles ) ;
1549:
1550: if ( functionLike ( ) && rawtok . next && rawtok . next . op == '(' ) {
1551:
1552: const Token * const rawtok1 ; rawtok1 = rawtok ;
1553: TokenList rawtokens2 ( inputFiles ) ;
1554: rawtokens2 . push_back ( new Token ( rawtok . str ( ) , rawtok1 . location , rawtok . whitespaceahead ) ) ;
1555: rawtok = rawtok . next ;
1556: rawtokens2 . push_back ( new Token ( rawtok . str ( ) , rawtok1 . location , rawtok . whitespaceahead ) ) ;
1557: rawtok = rawtok . next ;
1558: int par ; par = 1 ;
1559: while ( rawtok && par > 0 ) {
1560: if ( rawtok . op == '(' ) {
1561: ++ par ; }
1562: else if ( rawtok . op == ')' ) {
1563: -- par ; }
1564: else if ( rawtok . op == '#' && ! sameline ( rawtok . previous , rawtok ) ) {
1565: throw Error ( rawtok . location , "it is invalid to use a preprocessor directive as macro parameter" ) ; }
1566: rawtokens2 . push_back ( new Token ( rawtok . str ( ) , rawtok1 . location , rawtok . whitespaceahead ) ) ;
1567: rawtok = rawtok . next ;
1568: }
1569: if ( expand ( & output2 , rawtok1 . location , rawtokens2 . cfront ( ) , macros , expandedmacros ) ) {
1570: rawtok = rawtok1 . next ; }
1571: } else {
1572: rawtok = expand ( & output2 , rawtok . location , rawtok , macros , expandedmacros ) ;
1573: }
1574: while ( output2 . cback ( ) && rawtok ) {
1575: unsigned int par ; par = 0 ;
1576: Token * macro2tok ; macro2tok = output2 . back ( ) ;
1577: while ( macro2tok ) {
1578: if ( macro2tok . op == '(' ) {
1579: if ( par == 0 ) {
1580: break ; }
1581: -- par ;
1582: } else if ( macro2tok . op == ')' ) {
1583: ++ par ; }
1584: macro2tok = macro2tok . previous ;
1585: }
1586: if ( macro2tok ) {
1587: macro2tok = macro2tok . previous ;
1588: expandedmacros . insert ( name ( ) ) ;
1589: } else if ( rawtok . op == '(' ) {
1590: macro2tok = output2 . back ( ) ; }
1591: if ( ! macro2tok || ! macro2tok . name ) {
1592: break ; }
1593: if ( output2 . cfront ( ) != output2 . cback ( ) && macro2tok . str ( ) == this . name ( ) ) {
1594: break ; }
1595: const MacroMap :: const_iterator macro = macros . find ( macro2tok . str ( ) ) ;
1596: if ( macro == macros . end ( ) || ! macro . second . functionLike ( ) ) {
1597: break ; }
1598: TokenList rawtokens2 ( inputFiles ) ;
1599: const Location loc ( macro2tok . location ) ;
1600: while ( macro2tok ) {
1601: Token * const next ; next = macro2tok . next ;
1602: rawtokens2 . push_back ( new Token ( macro2tok . str ( ) , loc ) ) ;
1603: output2 . deleteToken ( macro2tok ) ;
1604: macro2tok = next ;
1605: }
1606: par = ( rawtokens2 . cfront ( ) != rawtokens2 . cback ( ) ) ? 1U : 0U ;
1607: const Token * rawtok2 ; rawtok2 = rawtok ;
1608: for ( ; rawtok2 ; rawtok2 = rawtok2 . next ) {
1609: rawtokens2 . push_back ( new Token ( rawtok2 . str ( ) , loc ) ) ;
1610: if ( rawtok2 . op == '(' ) {
1611: ++ par ; }
1612: else if ( rawtok2 . op == ')' ) {
1613: if ( par <= 1U ) {
1614: break ; }
1615: -- par ;
1616: }
1617: }
1618: if ( ! rawtok2 || par != 1U ) {
1619: break ; }
1620: if ( macro . second . expand ( & output2 , rawtok . location , rawtokens2 . cfront ( ) , macros , expandedmacros ) != nullptr ) {
1621: break ; }
1622: rawtok = rawtok2 . next ;
1623: }
1624: output . takeTokens ( output2 ) ;
1625: return rawtok ;
1626: }
1627:
1628:
1629: const std :: string & name ( ) const {
1630: return nameTokDef . str ( ) ;
1631: }
1632:
1633:
1634: const Location & defineLocation ( ) const {
1635: return nameTokDef . location ;
1636: }
1637:
1638:
1639: const std :: list < Location > & usage ( ) const {
1640: return usageList ;
1641: }
1642:
1643:
1644: bool functionLike ( ) const {
1645: return nameTokDef . next &&
1646: nameTokDef . next . op == '(' &&
1647: sameline ( nameTokDef , nameTokDef . next ) &&
1648: nameTokDef . next . location . col == nameTokDef . location . col + nameTokDef . str ( ) . size ( ) ;
1649: }
1650:
1651:
1652: struct Error {
1653: Error ( const Location & loc , const std :: string & s ) : location ( loc ) , what ( s ) { }
1654: const Location location ;
1655: const std :: string what ;
1656: } ;
1657:
1658:
1659: struct wrongNumberOfParameters : public Error {
1660: wrongNumberOfParameters ( const Location & loc , const std :: string & macroName ) : Error ( loc , "Wrong number of parameters for macro \'" + macroName + "\'." ) { }
1661: } ;
1662:
1663:
1664: struct invalidHashHash : public Error {
1665: static std :: string format ( const std :: string & macroName , const std :: string & message ) {
1666: return "Invalid ## usage when expanding \'" + macroName + "\': " + message ;
1667: }
1668:
1669: invalidHashHash ( const Location & loc , const std :: string & macroName , const std :: string & message )
1670: : Error ( loc , format ( macroName , message ) ) { }
1671:
1672: static invalidHashHash unexpectedToken ( const Location & loc , const std :: string & macroName , const Token * tokenA ) {
1673: return invalidHashHash ( loc , macroName , "Unexpected token '" + tokenA . str ( ) + "'" ) ;
1674: }
1675:
1676: static invalidHashHash cannotCombine ( const Location & loc , const std :: string & macroName , const Token * tokenA , const Token * tokenB ) {
1677: return invalidHashHash ( loc , macroName , "Combining '" + tokenA . str ( ) + "' and '" + tokenB . str ( ) + "' yields an invalid token." ) ;
1678: }
1679:
1680: static invalidHashHash unexpectedNewline ( const Location & loc , const std :: string & macroName ) {
1681: return invalidHashHash ( loc , macroName , "Unexpected newline" ) ;
1682: }
1683:
1684: static invalidHashHash universalCharacterUB ( const Location & loc , const std :: string & macroName , const Token * tokenA , const std :: string & strAB ) {
1685: return invalidHashHash ( loc , macroName , "Combining '\\" + tokenA . str ( ) + "' and '" + strAB . substr ( tokenA . str ( ) . size ( ) ) + "' yields universal character '\\" + strAB + "'. This is undefined behavior according to C standard chapter 5.1.1.2, paragraph 4." ) ;
1686: }
1687: } ;
1688: private:
1689:
1690: Token * newMacroToken ( const std :: string & str , const Location & loc , bool replaced , const Token * expandedFromToken = nullptr ) const {
1691: Token * tok ; tok = new Token ( str , loc ) ;
1692: if ( replaced ) {
1693: tok . macro = nameTokDef . str ( ) ; }
1694: if ( expandedFromToken ) {
1695: tok . setExpandedFrom ( expandedFromToken , this ) ; }
1696: return tok ;
1697: }
1698:
1699: bool parseDefine ( const Token * nametoken ) {
1700: nameTokDef = nametoken ;
1701: variadic = false ;
1702: variadicOpt = false ;
1703: optExpandValue = nullptr ;
1704: optNoExpandValue = nullptr ;
1705: if ( ! nameTokDef ) {
1706: valueToken = endToken = nullptr ;
1707: args . clear ( ) ;
1708: return false ;
1709: }
1710:
1711:
1712: if ( functionLike ( ) ) {
1713: args . clear ( ) ;
1714: const Token * argtok ; argtok = nameTokDef . next . next ;
1715: while ( sameline ( nametoken , argtok ) && argtok . op != ')' ) {
1716: if ( argtok . str ( ) == "..." &&
1717: argtok . next && argtok . next . op == ')' ) {
1718: variadic = true ;
1719: if ( ! argtok . previous . name ) {
1720: args . push_back ( "__VA_ARGS__" ) ; }
1721: argtok = argtok . next ;
1722: break ;
1723: }
1724: if ( argtok . op != ',' ) {
1725: args . push_back ( argtok . str ( ) ) ; }
1726: argtok = argtok . next ;
1727: }
1728: if ( ! sameline ( nametoken , argtok ) ) {
1729: endToken = argtok ? argtok . previous : argtok ;
1730: valueToken = nullptr ;
1731: return false ;
1732: }
1733: valueToken = argtok ? argtok . next : nullptr ;
1734: } else {
1735: args . clear ( ) ;
1736: valueToken = nameTokDef . next ;
1737: }
1738:
1739: if ( ! sameline ( valueToken , nameTokDef ) ) {
1740: valueToken = nullptr ; }
1741: endToken = valueToken ;
1742: while ( sameline ( endToken , nameTokDef ) ) {
1743: if ( variadic && endToken . str ( ) == "__VA_OPT__" ) {
1744: variadicOpt = true ; }
1745: endToken = endToken . next ;
1746: }
1747:
1748: if ( variadicOpt ) {
1749: TokenList expandValue ( files ) ;
1750: TokenList noExpandValue ( files ) ;
1751: for ( const Token * tok = valueToken ; tok && tok != endToken ; ) {
1752: if ( tok . str ( ) == "__VA_OPT__" ) {
1753: if ( ! sameline ( tok , tok . next ) || tok . next . op != '(' ) {
1754: throw Error ( tok . location , "In definition of '" + nameTokDef . str ( ) + "': Missing opening parenthesis for __VA_OPT__" ) ; }
1755: tok = tok . next . next ;
1756: int par ; par = 1 ;
1757: while ( tok && tok != endToken ) {
1758: if ( tok . op == '(' ) {
1759: par ++ ; }
1760: else if ( tok . op == ')' ) {
1761: par -- ; }
1762: else if ( tok . str ( ) == "__VA_OPT__" ) {
1763: throw Error ( tok . location , "In definition of '" + nameTokDef . str ( ) + "': __VA_OPT__ cannot be nested" ) ; }
1764: if ( par == 0 ) {
1765: tok = tok . next ;
1766: break ;
1767: }
1768: expandValue . push_back ( new Token ( * tok ) ) ;
1769: tok = tok . next ;
1770: }
1771: if ( par != 0 ) {
1772: const Token * const lastTok ; lastTok = expandValue . back ( ) ? expandValue . back ( ) : valueToken . next ;
1773: throw Error ( lastTok . location , "In definition of '" + nameTokDef . str ( ) + "': Missing closing parenthesis for __VA_OPT__" ) ;
1774: }
1775: } else {
1776: expandValue . push_back ( new Token ( * tok ) ) ;
1777: noExpandValue . push_back ( new Token ( * tok ) ) ;
1778: tok = tok . next ;
1779: }
1780: }
1781: optExpandValue = new TokenList ( std :: move ( expandValue ) ) ;
1782: optNoExpandValue = new TokenList ( std :: move ( noExpandValue ) ) ;
1783: }
1784:
1785: return true ;
1786: }
1787:
1788: unsigned int getArgNum ( const std :: string & str ) const {
1789: unsigned int par ; par = 0 ;
1790: while ( par < args . size ( ) ) {
1791: if ( str == args [ par ] ) {
1792: return par ; }
1793: par ++ ;
1794: }
1795: return ~ 0U ;
1796: }
1797:
1798: std :: vector < const Token * > getMacroParameters ( const Token * nameTokInst , bool calledInDefine ) const {
1799: if ( ! nameTokInst . next || nameTokInst . next . op != '(' || ! functionLike ( ) ) {
1800: return std :: vector < const Token * > ( ) ; }
1801:
1802: std :: vector < const Token * > parametertokens ;
1803: parametertokens . push_back ( nameTokInst . next ) ;
1804: unsigned int par ; par = 0U ;
1805: for ( const Token * tok = nameTokInst . next . next ; calledInDefine ? sameline ( tok , nameTokInst ) : ( tok != nullptr ) ; tok = tok . next ) {
1806: if ( tok . op == '(' ) {
1807: ++ par ; }
1808: else if ( tok . op == ')' ) {
1809: if ( par == 0U ) {
1810: parametertokens . push_back ( tok ) ;
1811: break ;
1812: }
1813: -- par ;
1814: } else if ( par == 0U && tok . op == ',' && ( ! variadic || parametertokens . size ( ) < args . size ( ) ) ) {
1815: parametertokens . push_back ( tok ) ; }
1816: }
1817: return parametertokens ;
1818: }
1819:
1820: const Token * appendTokens ( TokenList * tokens ,
1821: const Location & rawloc ,
1822: const Token * const lpar ,
1823: const std :: unordered_map < std :: string , Macro > & macros ,
1824: const std :: set < std :: string > & expandedmacros ,
1825: const std :: vector < const Token * > & parametertokens ) const {
1826: if ( ! lpar || lpar . op != '(' ) {
1827: return nullptr ; }
1828: unsigned int par ; par = 0 ;
1829: const Token * tok ; tok = lpar ;
1830: while ( sameline ( lpar , tok ) ) {
1831: if ( tok . op == '#' && sameline ( tok , tok . next ) && tok . next . op == '#' && sameline ( tok , tok . next . next ) ) {
1832:
1833: tok = expandHashHash ( tokens , rawloc , tok , macros , expandedmacros , parametertokens , false ) ;
1834: } else if ( tok . op == '#' && sameline ( tok , tok . next ) && tok . next . op != '#' ) {
1835: tok = expandHash ( tokens , rawloc , tok , expandedmacros , parametertokens ) ;
1836: } else {
1837: if ( ! expandArg ( tokens , tok , rawloc , macros , expandedmacros , parametertokens ) ) {
1838: tokens . push_back ( new Token ( * tok ) ) ;
1839: if ( tok . macro . empty ( ) && ( par > 0 || tok . str ( ) != "(" ) ) {
1840: tokens . back ( ) . macro = name ( ) ; }
1841: }
1842:
1843: if ( tok . op == '(' ) {
1844: ++ par ; }
1845: else if ( tok . op == ')' ) {
1846: -- par ;
1847: if ( par == 0U ) {
1848: break ; }
1849: }
1850: tok = tok . next ;
1851: }
1852: }
1853: for ( Token * tok2 = tokens . front ( ) ; tok2 ; tok2 = tok2 . next ) {
1854: tok2 . location = lpar . location ; }
1855: return sameline ( lpar , tok ) ? tok : nullptr ;
1856: }
1857:
1858: const Token * expand ( TokenList * const output , const Location & loc , const Token * const nameTokInst , const std :: unordered_map < std :: string , Macro > & macros , std :: set < std :: string > expandedmacros ) const {
1859: expandedmacros . insert ( nameTokInst . str ( ) ) ;
1860:
|
1864:
1865: usageList . push_back ( loc ) ;
1866:
1867: if ( nameTokInst . str ( ) == "__FILE__" ) {
1868: output . push_back ( new Token ( '\"' + loc . file ( ) + '\"' , loc ) ) ;
1869: return nameTokInst . next ;
1870: }
1871: if ( nameTokInst . str ( ) == "__LINE__" ) {
1872: output . push_back ( new Token ( toString ( loc . line ) , loc ) ) ;
1873: return nameTokInst . next ;
1874: }
1875: if ( nameTokInst . str ( ) == "__COUNTER__" ) {
1876: output . push_back ( new Token ( toString ( usageList . size ( ) - 1U ) , loc ) ) ;
1877: return nameTokInst . next ;
1878: }
1879:
1880: const bool calledInDefine = loc . fileIndex != nameTokInst . location . fileIndex ||
1881: loc . line < nameTokInst . location . line ;
1882:
1883: std :: vector < const Token * > parametertokens1 ( getMacroParameters ( nameTokInst , calledInDefine ) ) ;
1884:
1885: if ( functionLike ( ) ) {
1886:
1887: if ( nameTokInst . next && nameTokInst . next . op != '(' ) {
1888: output . push_back ( new Token ( nameTokInst . str ( ) , loc ) ) ;
1889: return nameTokInst . next ;
1890: }
1891:
1892:
1893: if ( variadic ) {
1894: if ( parametertokens1 . size ( ) < args . size ( ) ) {
1895: throw wrongNumberOfParameters ( nameTokInst . location , name ( ) ) ;
1896: }
1897: } else {
1898: if ( parametertokens1 . size ( ) != args . size ( ) + ( args . empty ( ) ? 2U : 1U ) ) {
1899: throw wrongNumberOfParameters ( nameTokInst . location , name ( ) ) ; }
1900: }
1901: }
1902:
1903:
1904: TokenList tokensparams ( files ) ;
1905: std :: vector < const Token * > parametertokens2 ;
1906: if ( ! parametertokens1 . empty ( ) ) {
1907: bool counter ; counter = false ;
1908: for ( const Token * tok = parametertokens1 [ 0 ] ; tok != parametertokens1 . back ( ) ; tok = tok . next ) {
1909: if ( tok . str ( ) == "__COUNTER__" ) {
1910: counter = true ;
1911: break ;
1912: }
1913: }
1914:
1915: const MacroMap :: const_iterator m = macros . find ( "__COUNTER__" ) ;
1916:
1917: if ( ! counter || m == macros . end ( ) ) {
1918: parametertokens2 . swap ( parametertokens1 ) ; }
1919: else {
1920: const Macro & counterMacro = m . second ;
1921: unsigned int par ; par = 0 ;
1922: for ( const Token * tok = parametertokens1 [ 0 ] ; tok && par < parametertokens1 . size ( ) ; tok = tok . next ) {
1923: if ( tok . str ( ) == "__COUNTER__" ) {
1924: tokensparams . push_back ( new Token ( toString ( counterMacro . usageList . size ( ) ) , tok . location ) ) ;
1925: counterMacro . usageList . push_back ( tok . location ) ;
1926: } else {
1927: tokensparams . push_back ( new Token ( * tok ) ) ;
1928: if ( tok == parametertokens1 [ par ] ) {
1929: parametertokens2 . push_back ( tokensparams . cback ( ) ) ;
1930: par ++ ;
1931: }
1932: }
1933: }
1934: }
1935: }
1936:
1937: Token * const output_end_1 ; output_end_1 = output . back ( ) ;
1938:
1939: const Token * valueToken2 ;
1940: const Token * endToken2 ;
1941:
1942: if ( variadicOpt ) {
1943: if ( parametertokens2 . size ( ) > args . size ( ) && parametertokens2 [ args . size ( ) - 1 ] . next . op != ')' ) {
1944: valueToken2 = optExpandValue . cfront ( ) ; }
1945: else {
1946: valueToken2 = optNoExpandValue . cfront ( ) ; }
1947: endToken2 = nullptr ;
1948: } else {
1949: valueToken2 = valueToken ;
1950: endToken2 = endToken ;
1951: }
1952:
1953:
1954: for ( const Token * tok = valueToken2 ; tok != endToken2 ; ) {
1955: if ( tok . op != '#' ) {
1956:
1957: if ( sameline ( tok , tok . next ) && tok . next && tok . next . op == '#' && tok . next . next && tok . next . next . op == '#' ) {
1958: if ( ! sameline ( tok , tok . next . next . next ) ) {
1959: throw invalidHashHash :: unexpectedNewline ( tok . location , name ( ) ) ; }
1960: if ( variadic && tok . op == ',' && tok . next . next . next . str ( ) == args . back ( ) ) {
1961: Token * const comma ; comma = newMacroToken ( tok . str ( ) , loc , isReplaced ( expandedmacros ) , tok ) ;
1962: output . push_back ( comma ) ;
1963: tok = expandToken ( output , loc , tok . next . next . next , macros , expandedmacros , parametertokens2 ) ;
1964: if ( output . back ( ) == comma ) {
1965: output . deleteToken ( comma ) ; }
1966: continue ;
1967: }
1968: TokenList new_output ( files ) ;
1969: if ( ! expandArg ( & new_output , tok , parametertokens2 ) ) {
1970: output . push_back ( newMacroToken ( tok . str ( ) , loc , isReplaced ( expandedmacros ) , tok ) ) ; }
1971: else if ( new_output . empty ( ) ) {
1972: output . push_back ( newMacroToken ( "" , loc , isReplaced ( expandedmacros ) ) ) ; }
1973: else {
1974: for ( const Token * tok2 = new_output . cfront ( ) ; tok2 ; tok2 = tok2 . next ) {
1975: output . push_back ( newMacroToken ( tok2 . str ( ) , loc , isReplaced ( expandedmacros ) , tok2 ) ) ; } }
1976: tok = tok . next ;
1977: } else {
1978: tok = expandToken ( output , loc , tok , macros , expandedmacros , parametertokens2 ) ;
1979: }
1980: continue ;
1981: }
1982:
1983: int numberOfHash ; numberOfHash = 1 ;
1984: const Token * hashToken ; hashToken = tok . next ;
1985: while ( sameline ( tok , hashToken ) && hashToken . op == '#' ) {
1986: hashToken = hashToken . next ;
1987: ++ numberOfHash ;
1988: }
1989: if ( numberOfHash == 4 && tok . next . location . col + 1 == tok . next . next . location . col ) {
1990:
1991: output . push_back ( newMacroToken ( "##" , loc , isReplaced ( expandedmacros ) ) ) ;
1992: tok = hashToken ;
1993: continue ;
1994: }
1995:
1996: if ( numberOfHash >= 2 && tok . location . col + 1 < tok . next . location . col ) {
1997: output . push_back ( new Token ( * tok ) ) ;
1998: tok = tok . next ;
1999: continue ;
2000: }
2001:
2002: tok = tok . next ;
2003: if ( tok == endToken2 ) {
2004: output . push_back ( new Token ( * tok . previous ) ) ;
2005: break ;
2006: }
2007: if ( tok . op == '#' ) {
2008:
2009: tok = expandHashHash ( output , loc , tok . previous , macros , expandedmacros , parametertokens2 ) ;
2010: } else {
2011:
2012: tok = expandHash ( output , loc , tok . previous , expandedmacros , parametertokens2 ) ;
2013: }
2014: }
2015:
2016: if ( ! functionLike ( ) ) {
2017: for ( Token * tok = output_end_1 ? output_end_1 . next : output . front ( ) ; tok ; tok = tok . next ) {
2018: tok . macro = nameTokInst . str ( ) ;
2019: }
2020: }
2021:
2022: if ( ! parametertokens1 . empty ( ) ) {
2023: parametertokens1 . swap ( parametertokens2 ) ; }
2024:
2025: return functionLike ( ) ? parametertokens2 . back ( ) . next : nameTokInst . next ;
2026: }
2027:
2028: const Token * recursiveExpandToken ( TokenList * output , TokenList & temp , const Location & loc , const Token * tok , const std :: unordered_map < std :: string , Macro > & macros , const std :: set < std :: string > & expandedmacros , const std :: vector < const Token * > & parametertokens ) const {
2029: if ( ! ( temp . cback ( ) && temp . cback ( ) . name && tok . next && tok . next . op == '(' ) ) {
2030: output . takeTokens ( temp ) ;
2031: return tok . next ;
2032: }
2033:
2034: if ( ! sameline ( tok , tok . next ) ) {
2035: output . takeTokens ( temp ) ;
2036: return tok . next ;
2037: }
2038:
2039: const std :: unordered_map < std :: string , Macro > :: const_iterator it = macros . find ( temp . cback ( ) . str ( ) ) ;
2040: if ( it == macros . end ( ) || expandedmacros . find ( temp . cback ( ) . str ( ) ) != expandedmacros . end ( ) ) {
2041: output . takeTokens ( temp ) ;
2042: return tok . next ;
2043: }
2044:
2045: const Macro & calledMacro = it . second ;
2046: if ( ! calledMacro . functionLike ( ) ) {
2047: output . takeTokens ( temp ) ;
2048: return tok . next ;
2049: }
2050:
2051: TokenList temp2 ( files ) ;
2052: temp2 . push_back ( new Token ( temp . cback ( ) . str ( ) , tok . location ) ) ;
2053:
2054: const Token * const tok2 ; tok2 = appendTokens ( & temp2 , loc , tok . next , macros , expandedmacros , parametertokens ) ;
2055: if ( ! tok2 ) {
2056: return tok . next ; }
2057: output . takeTokens ( temp ) ;
2058: output . deleteToken ( output . back ( ) ) ;
2059: calledMacro . expand ( output , loc , temp2 . cfront ( ) , macros , expandedmacros ) ;
2060: return tok2 . next ;
2061: }
2062:
2063: const Token * expandToken ( TokenList * output , const Location & loc , const Token * tok , const std :: unordered_map < std :: string , Macro > & macros , const std :: set < std :: string > & expandedmacros , const std :: vector < const Token * > & parametertokens ) const {
2064:
2065: if ( ! tok . name ) {
2066: output . push_back ( newMacroToken ( tok . str ( ) , loc , true , tok ) ) ;
2067: return tok . next ;
2068: }
2069:
2070:
2071: {
2072: TokenList temp ( files ) ;
2073: if ( expandArg ( & temp , tok , loc , macros , expandedmacros , parametertokens ) ) {
2074: if ( tok . str ( ) == "__VA_ARGS__" && temp . empty ( ) && output . cback ( ) && output . cback ( ) . str ( ) == "," &&
2075: tok . nextSkipComments ( ) && tok . nextSkipComments ( ) . str ( ) == ")" ) {
2076: output . deleteToken ( output . back ( ) ) ; }
2077: return recursiveExpandToken ( output , temp , loc , tok , macros , expandedmacros , parametertokens ) ;
2078: }
2079: }
2080:
2081:
2082: const std :: unordered_map < std :: string , Macro > :: const_iterator it = macros . find ( tok . str ( ) ) ;
2083: if ( it != macros . end ( ) && expandedmacros . find ( tok . str ( ) ) == expandedmacros . end ( ) ) {
2084: std :: set < std :: string > expandedmacros2 ( expandedmacros ) ;
2085: expandedmacros2 . insert ( tok . str ( ) ) ;
2086:
2087: const Macro & calledMacro = it . second ;
2088: if ( ! calledMacro . functionLike ( ) ) {
2089: TokenList temp ( files ) ;
2090: calledMacro . expand ( & temp , loc , tok , macros , expandedmacros ) ;
2091: return recursiveExpandToken ( output , temp , loc , tok , macros , expandedmacros2 , parametertokens ) ;
2092: }
2093: if ( ! sameline ( tok , tok . next ) ) {
2094: output . push_back ( newMacroToken ( tok . str ( ) , loc , true , tok ) ) ;
2095: return tok . next ;
2096: }
2097: TokenList tokens ( files ) ;
2098: tokens . push_back ( new Token ( * tok ) ) ;
2099: const Token * tok2 ; tok2 = nullptr ;
2100: if ( tok . next . op == '(' ) {
2101: tok2 = appendTokens ( & tokens , loc , tok . next , macros , expandedmacros , parametertokens ) ; }
2102: else if ( expandArg ( & tokens , tok . next , loc , macros , expandedmacros , parametertokens ) ) {
2103: tokens . front ( ) . location = loc ;
2104: if ( tokens . cfront ( ) . next && tokens . cfront ( ) . next . op == '(' ) {
2105: tok2 = tok . next ; }
2106: }
2107: if ( ! tok2 ) {
2108: output . push_back ( newMacroToken ( tok . str ( ) , loc , true , tok ) ) ;
2109: return tok . next ;
2110: }
2111: TokenList temp ( files ) ;
2112: calledMacro . expand ( & temp , loc , tokens . cfront ( ) , macros , expandedmacros ) ;
2113: return recursiveExpandToken ( output , temp , loc , tok2 , macros , expandedmacros , parametertokens ) ;
2114: }
2115:
2116: if ( tok . str ( ) == DEFINED ) {
2117: const Token * const tok2 ; tok2 = tok . next ;
2118: const Token * const tok3 ; tok3 = tok2 ? tok2 . next : nullptr ;
2119: const Token * const tok4 ; tok4 = tok3 ? tok3 . next : nullptr ;
2120: const Token * defToken ; defToken = nullptr ;
2121: const Token * lastToken ; lastToken = nullptr ;
2122: if ( sameline ( tok , tok4 ) && tok2 . op == '(' && tok3 . name && tok4 . op == ')' ) {
2123: defToken = tok3 ;
2124: lastToken = tok4 ;
2125: } else if ( sameline ( tok , tok2 ) && tok2 . name ) {
2126: defToken = lastToken = tok2 ;
2127: }
2128: if ( defToken ) {
2129: std :: string macroName ; macroName = defToken . str ( ) ;
2130: if ( defToken . next && defToken . next . op == '#' && defToken . next . next && defToken . next . next . op == '#' && defToken . next . next . next && defToken . next . next . next . name && sameline ( defToken , defToken . next . next . next ) ) {
2131: TokenList temp ( files ) ;
2132: if ( expandArg ( & temp , defToken , parametertokens ) ) {
2133: macroName = temp . cback ( ) . str ( ) ; }
2134: if ( expandArg ( & temp , defToken . next . next . next , parametertokens ) ) {
2135: macroName += temp . cback ( ) ? temp . cback ( ) . str ( ) : "" ; }
2136: else {
2137: macroName += defToken . next . next . next . str ( ) ; }
2138: lastToken = defToken . next . next . next ;
2139: }
2140: const bool def = macros . find ( macroName ) != macros . end ( ) ;
2141: output . push_back ( newMacroToken ( def ? "1" : "0" , loc , true ) ) ;
2142: return lastToken . next ;
2143: }
2144: }
2145:
2146: output . push_back ( newMacroToken ( tok . str ( ) , loc , true , tok ) ) ;
2147: return tok . next ;
2148: }
2149:
2150: bool expandArg ( TokenList * output , const Token * tok , const std :: vector < const Token * > & parametertokens ) const {
2151: if ( ! tok . name ) {
2152: return false ; }
2153:
2154: const unsigned int argnr = getArgNum ( tok . str ( ) ) ;
2155: if ( argnr >= args . size ( ) ) {
2156: return false ; }
2157:
2158:
2159: if ( variadic && argnr + 1U >= parametertokens . size ( ) ) {
2160: return true ; }
2161:
2162: for ( const Token * partok = parametertokens [ argnr ] . next ; partok != parametertokens [ argnr + 1U ] ; partok = partok . next ) {
2163: output . push_back ( new Token ( * partok ) ) ; }
2164:
2165: return true ;
2166: }
2167:
2168: bool expandArg ( TokenList * output , const Token * tok , const Location & loc , const std :: unordered_map < std :: string , Macro > & macros , const std :: set < std :: string > & expandedmacros , const std :: vector < const Token * > & parametertokens ) const {
2169: if ( ! tok . name ) {
2170: return false ; }
2171: const unsigned int argnr = getArgNum ( tok . str ( ) ) ;
2172: if ( argnr >= args . size ( ) ) {
2173: return false ; }
2174: if ( variadic && argnr + 1U >= parametertokens . size ( ) ) {
2175: return true ; }
2176: for ( const Token * partok = parametertokens [ argnr ] . next ; partok != parametertokens [ argnr + 1U ] ; ) {
2177: const MacroMap :: const_iterator it = macros . find ( partok . str ( ) ) ;
2178: if ( it != macros . end ( ) && ! partok . isExpandedFrom ( & it . second ) && ( partok . str ( ) == name ( ) || expandedmacros . find ( partok . str ( ) ) == expandedmacros . end ( ) ) ) {
2179: std :: set < std :: string > expandedmacros2 ( expandedmacros ) ;
2180: expandedmacros2 . erase ( name ( ) ) ;
2181: partok = it . second . expand ( output , loc , partok , macros , expandedmacros2 ) ;
2182: } else {
2183: output . push_back ( newMacroToken ( partok . str ( ) , loc , isReplaced ( expandedmacros ) , partok ) ) ;
2184: output . back ( ) . macro = partok . macro ;
2185: partok = partok . next ;
2186: }
2187: }
2188: if ( tok . whitespaceahead && output . back ( ) ) {
2189: output . back ( ) . whitespaceahead = true ; }
2190: return true ;
2191: }
2192:
|
2201:
2202: const Token * expandHash ( TokenList * output , const Location & loc , const Token * tok , const std :: set < std :: string > & expandedmacros , const std :: vector < const Token * > & parametertokens ) const {
2203: TokenList tokenListHash ( files ) ;
2204: const std :: unordered_map < std :: string , Macro > macros2 ;
2205: tok = expandToken ( & tokenListHash , loc , tok . next , macros2 , expandedmacros , parametertokens ) ;
2206: std :: ostringstream ostr ;
2207: ostr << '\"' ;
2208: for ( const Token * hashtok = tokenListHash . cfront ( ) , * next ; hashtok ; hashtok = next ) {
2209: next = hashtok . next ;
2210: ostr << hashtok . str ( ) ;
2211: if ( next && hashtok . whitespaceahead ) {
2212: ostr << ' ' ; }
2213: }
2214: ostr << '\"' ;
2215: output . push_back ( newMacroToken ( escapeString ( ostr . str ( ) ) , loc , isReplaced ( expandedmacros ) ) ) ;
2216: return tok ;
2217: }
2218:
|
2230:
2231: const Token * expandHashHash ( TokenList * output , const Location & loc , const Token * tok , const std :: unordered_map < std :: string , Macro > & macros , const std :: set < std :: string > & expandedmacros , const std :: vector < const Token * > & parametertokens , bool expandResult = true ) const {
2232: Token * A ; A = output . back ( ) ;
2233: if ( ! A ) {
2234: throw invalidHashHash ( tok . location , name ( ) , "Missing first argument" ) ; }
2235: if ( ! sameline ( tok , tok . next ) || ! sameline ( tok , tok . next . next ) ) {
2236: throw invalidHashHash :: unexpectedNewline ( tok . location , name ( ) ) ; }
2237:
2238: const bool canBeConcatenatedWithEqual = A . isOneOf ( "+-*/%&|^" ) || A . str ( ) == "<<" || A . str ( ) == ">>" ;
2239: const bool canBeConcatenatedStringOrChar = isStringLiteral_ ( A . str ( ) ) || isCharLiteral_ ( A . str ( ) ) ;
2240: const bool unexpectedA = ! A . name && ! A . number && ! A . str ( ) . empty ( ) && ! canBeConcatenatedWithEqual && ! canBeConcatenatedStringOrChar ;
2241:
2242: Token * const B ; B = tok . next . next ;
2243: if ( ! B . name && ! B . number && B . op && ! B . isOneOf ( "#=" ) ) {
2244: throw invalidHashHash :: unexpectedToken ( tok . location , name ( ) , B ) ; }
2245:
2246: if ( ( canBeConcatenatedWithEqual && B . op != '=' ) ||
2247: ( ! canBeConcatenatedWithEqual && B . op == '=' ) ) {
2248: throw invalidHashHash :: cannotCombine ( tok . location , name ( ) , A , B ) ; }
2249:
2250:
2251: if ( canBeConcatenatedStringOrChar && ( B . number || ! B . name ) ) {
2252: throw invalidHashHash :: cannotCombine ( tok . location , name ( ) , A , B ) ; }
2253:
2254: TokenList tokensB ( files ) ;
2255: const Token * nextTok ; nextTok = B . next ;
2256:
2257: if ( canBeConcatenatedStringOrChar ) {
2258: if ( unexpectedA ) {
2259: throw invalidHashHash :: unexpectedToken ( tok . location , name ( ) , A ) ; }
2260:
2261:
2262:
2263: if ( expandArg ( & tokensB , B , parametertokens ) ) {
2264: for ( Token * b = tokensB . front ( ) ; b ; b = b . next ) {
2265: b . location = loc ; }
2266: } else {
2267: tokensB . push_back ( new Token ( * B ) ) ;
2268: tokensB . back ( ) . location = loc ;
2269: }
2270: output . takeTokens ( tokensB ) ;
2271: } else {
2272: std :: string strAB ;
2273:
2274: const bool varargs = variadic && ! args . empty ( ) && B . str ( ) == args [ args . size ( ) - 1U ] ;
2275:
2276: if ( expandArg ( & tokensB , B , parametertokens ) ) {
2277: if ( tokensB . empty ( ) ) {
2278: strAB = A . str ( ) ; }
2279: else if ( varargs && A . op == ',' ) {
2280: strAB = "," ; }
2281: else if ( varargs && unexpectedA ) {
2282: throw invalidHashHash :: unexpectedToken ( tok . location , name ( ) , A ) ; }
2283: else {
2284: strAB = A . str ( ) + tokensB . cfront ( ) . str ( ) ;
2285: tokensB . deleteToken ( tokensB . front ( ) ) ;
2286: }
2287: } else {
2288: if ( unexpectedA ) {
2289: throw invalidHashHash :: unexpectedToken ( tok . location , name ( ) , A ) ; }
2290: strAB = A . str ( ) + B . str ( ) ;
2291: }
2292:
2293:
2294: if ( A . previous && A . previous . str ( ) == "\\" ) {
2295: if ( strAB [ 0 ] == 'u' && strAB . size ( ) == 5 ) {
2296: throw invalidHashHash :: universalCharacterUB ( tok . location , name ( ) , A , strAB ) ; }
2297: if ( strAB [ 0 ] == 'U' && strAB . size ( ) == 9 ) {
2298: throw invalidHashHash :: universalCharacterUB ( tok . location , name ( ) , A , strAB ) ; }
2299: }
2300:
2301: if ( varargs && tokensB . empty ( ) && tok . previous . str ( ) == "," ) {
2302: output . deleteToken ( A ) ; }
2303: else if ( strAB != "," && macros . find ( strAB ) == macros . end ( ) ) {
2304: A . setstr ( strAB ) ;
2305: for ( Token * b = tokensB . front ( ) ; b ; b = b . next ) {
2306: b . location = loc ; }
2307: output . takeTokens ( tokensB ) ;
2308: } else if ( sameline ( B , nextTok ) && sameline ( B , nextTok . next ) && nextTok . op == '#' && nextTok . next . op == '#' ) {
2309: TokenList output2 ( files ) ;
2310: output2 . push_back ( new Token ( strAB , tok . location ) ) ;
2311: nextTok = expandHashHash ( & output2 , loc , nextTok , macros , expandedmacros , parametertokens ) ;
2312: output . deleteToken ( A ) ;
2313: output . takeTokens ( output2 ) ;
2314: } else {
2315: output . deleteToken ( A ) ;
2316: TokenList tokens ( files ) ;
2317: tokens . push_back ( new Token ( strAB , tok . location ) ) ;
2318:
2319: if ( tokensB . empty ( ) && sameline ( B , B . next ) && B . next . op == '(' ) {
2320: const MacroMap :: const_iterator it = macros . find ( strAB ) ;
2321: if ( it != macros . end ( ) && expandedmacros . find ( strAB ) == expandedmacros . end ( ) && it . second . functionLike ( ) ) {
2322: const Token * const tok2 ; tok2 = appendTokens ( & tokens , loc , B . next , macros , expandedmacros , parametertokens ) ;
2323: if ( tok2 ) {
2324: nextTok = tok2 . next ; }
2325: }
2326: }
2327: if ( expandResult ) {
2328: expandToken ( output , loc , tokens . cfront ( ) , macros , expandedmacros , parametertokens ) ; }
2329: else {
2330: output . takeTokens ( tokens ) ; }
2331: for ( Token * b = tokensB . front ( ) ; b ; b = b . next ) {
2332: b . location = loc ; }
2333: output . takeTokens ( tokensB ) ;
2334: }
2335: }
2336:
2337: return nextTok ;
2338: }
2339:
2340: static bool isReplaced ( const std :: set < std :: string > & expandedmacros ) {
2341:
2342: std :: set < std :: string > :: const_iterator it ; it = expandedmacros . begin ( ) ;
2343: if ( it == expandedmacros . end ( ) ) {
2344: return false ; }
2345: ++ it ;
2346: return ( it != expandedmacros . end ( ) ) ;
2347: }
2348:
2349:
2350: const Token * nameTokDef ;
2351:
2352:
2353: std :: vector < std :: string > args ;
2354:
2355:
2356: const Token * valueToken ;
2357:
2358:
2359: const Token * endToken ;
2360:
2361:
2362: std :: vector < std :: string > & files ;
2363:
2364:
2365: TokenList tokenListDefine ;
2366:
2367:
2368: mutable std :: list < Location > usageList ;
2369:
2370:
2371: bool variadic ;
2372:
2373:
2374: bool variadicOpt ;
2375:
2376:
2377: const TokenList * optExpandValue ;
2378: const TokenList * optNoExpandValue ;
2379:
2380:
2381: bool valueDefinedInCode_ ;
2382: } ;
2383: }
2384:
2385: namespace simplecpp {
2386:
|
2417:
2418: }
2419:
|
2427:
2428: static bool isAbsolutePath ( const std :: string & path )
2429: {
2430: return path . length ( ) > 1U && path [ 0 ] == '/' ;
2431: }
2432:
2433:
2434: namespace simplecpp {
2435:
2436:
2437:
2438: std :: string simplifyPath ( std :: string path )
2439: {
2440: if ( path . empty ( ) ) {
2441: return path ; }
2442:
2443: std :: string :: size_type pos ;
2444:
2445:
2446: std :: replace ( path . begin ( ) , path . end ( ) , '\\' , '/' ) ;
2447:
2448: const bool unc ( path . compare ( 0 , 2 , "//" ) == 0 ) ;
2449:
2450:
2451: pos = 0 ;
2452: while ( ( pos = path . find ( "//" , pos ) ) != std :: string :: npos ) {
2453: path . erase ( pos , 1 ) ;
2454: }
2455:
2456:
2457: pos = 0 ;
2458: while ( ( pos = path . find ( "./" , pos ) ) != std :: string :: npos ) {
2459: if ( pos == 0 || path [ pos - 1U ] == '/' ) {
2460: path . erase ( pos , 2 ) ; }
2461: else {
2462: pos += 2 ; }
2463: }
2464:
2465:
2466: if ( endsWith ( path , "/." ) ) {
2467: path . erase ( path . size ( ) - 1 ) ; }
2468:
2469:
2470: pos = 1 ;
2471: while ( ( pos = path . find ( "/.." , pos ) ) != std :: string :: npos ) {
2472:
2473: if ( pos + 3 < path . size ( ) && path [ pos + 3 ] != '/' ) {
2474: ++ pos ;
2475: continue ;
2476: }
2477:
2478: std :: string :: size_type pos1 ; pos1 = path . rfind ( '/' , pos - 1U ) ;
2479: if ( pos1 == std :: string :: npos ) {
2480: pos1 = 0 ;
2481: } else {
2482: pos1 += 1U ;
2483: }
2484: const std :: string previousSubPath = path . substr ( pos1 , pos - pos1 ) ;
2485: if ( previousSubPath == ".." ) {
2486:
2487: ++ pos ;
2488: } else {
2489:
2490: path . erase ( pos1 , pos - pos1 + 4 ) ;
2491: if ( path . empty ( ) ) {
2492: path = "." ; }
2493:
2494: pos = ( pos1 == 0 ) ? 1 : ( pos1 - 1 ) ;
2495: }
2496: }
2497:
|
2501:
2502: if ( unc ) {
2503: path = '/' + path ; }
2504:
2505: return path ;
2506: }
2507: }
2508:
2509:
2510: static void simplifySizeof ( simplecpp :: TokenList & expr , const std :: map < std :: string , unsigned long > & sizeOfType )
2511: {
2512: for ( simplecpp :: Token * tok = expr . front ( ) ; tok ; tok = tok . next ) {
2513: if ( tok . str ( ) != "sizeof" ) {
2514: continue ; }
2515: simplecpp :: Token * tok1 ; tok1 = tok . next ;
2516: if ( ! tok1 ) {
2517: throw std :: runtime_error ( "missing sizeof argument" ) ;
2518: }
2519: simplecpp :: Token * tok2 ; tok2 = tok1 . next ;
2520: if ( ! tok2 ) {
2521: throw std :: runtime_error ( "missing sizeof argument" ) ;
2522: }
2523: if ( tok1 . op == '(' ) {
2524: tok1 = tok1 . next ;
2525: while ( tok2 . op != ')' ) {
2526: tok2 = tok2 . next ;
2527: if ( ! tok2 ) {
2528: throw std :: runtime_error ( "invalid sizeof expression" ) ;
2529: }
2530: }
2531: }
2532:
2533: std :: string type ;
2534: for ( simplecpp :: Token * typeToken = tok1 ; typeToken != tok2 ; typeToken = typeToken . next ) {
2535: if ( ( typeToken . str ( ) == "unsigned" || typeToken . str ( ) == "signed" ) && typeToken . next . name ) {
2536: continue ; }
2537: if ( typeToken . str ( ) == "*" && type . find ( '*' ) != std :: string :: npos ) {
2538: continue ; }
2539: if ( ! type . empty ( ) ) {
2540: type += ' ' ; }
2541: type += typeToken . str ( ) ;
2542: }
2543:
2544: const std :: map < std :: string , unsigned long > :: const_iterator it = sizeOfType . find ( type ) ;
2545: if ( it != sizeOfType . end ( ) ) {
2546: tok . setstr ( toString ( it . second ) ) ; }
2547: else {
2548: continue ; }
2549:
2550: tok2 = tok2 . next ;
2551: while ( tok . next != tok2 ) {
2552: expr . deleteToken ( tok . next ) ; }
2553: }
2554: }
2555:
2556: static bool isCpp17OrLater ( const simplecpp :: DUI & dui )
2557: {
2558: const std :: string std_ver = simplecpp :: getCppStdString ( dui . std ) ;
2559: return ! std_ver . empty ( ) && ( std_ver >= "201703L" ) ;
2560: }
2561:
2562: static bool isGnu ( const simplecpp :: DUI & dui )
2563: {
2564: return dui . std . rfind ( "gnu" , 0 ) != std :: string :: npos ;
2565: }
2566:
2567: static std :: string dirPath ( const std :: string & path , bool withTrailingSlash = true )
2568: {
2569: const unsigned long lastSlash = path . find_last_of ( "\\/" ) ;
2570: if ( lastSlash == std :: string :: npos ) {
2571: return "" ;
2572: }
2573: return path . substr ( 0 , lastSlash + ( withTrailingSlash ? 1U : 0U ) ) ;
2574: }
2575:
2576: static std :: string openHeader ( std :: ifstream & f , const simplecpp :: DUI & dui , const std :: string & sourcefile , const std :: string & header , bool systemheader ) ;
2577: static void simplifyHasInclude ( simplecpp :: TokenList & expr , const simplecpp :: DUI & dui )
2578: {
2579: if ( ! isCpp17OrLater ( dui ) && ! isGnu ( dui ) ) {
2580: return ; }
2581:
2582: for ( simplecpp :: Token * tok = expr . front ( ) ; tok ; tok = tok . next ) {
2583: if ( tok . str ( ) != HAS_INCLUDE ) {
2584: continue ; }
2585: simplecpp :: Token * tok1 ; tok1 = tok . next ;
2586: if ( ! tok1 ) {
2587: throw std :: runtime_error ( "missing __has_include argument" ) ;
2588: }
2589: simplecpp :: Token * tok2 ; tok2 = tok1 . next ;
2590: if ( ! tok2 ) {
2591: throw std :: runtime_error ( "missing __has_include argument" ) ;
2592: }
2593: if ( tok1 . op == '(' ) {
2594: tok1 = tok1 . next ;
2595: while ( tok2 . op != ')' ) {
2596: tok2 = tok2 . next ;
2597: if ( ! tok2 ) {
2598: throw std :: runtime_error ( "invalid __has_include expression" ) ;
2599: }
2600: }
2601: }
2602:
2603: const std :: string & sourcefile = tok . location . file ( ) ;
2604: const bool systemheader = tok1 && tok1 . op == '<' ;
2605: std :: string header ;
2606: if ( systemheader ) {
2607: simplecpp :: Token * tok3 ; tok3 = tok1 . next ;
2608: if ( ! tok3 ) {
2609: throw std :: runtime_error ( "missing __has_include closing angular bracket" ) ;
2610: }
2611: while ( tok3 . op != '>' ) {
2612: tok3 = tok3 . next ;
2613: if ( ! tok3 ) {
2614: throw std :: runtime_error ( "invalid __has_include expression" ) ;
2615: }
2616: }
2617:
2618: for ( simplecpp :: Token * headerToken = tok1 . next ; headerToken != tok3 ; headerToken = headerToken . next ) {
2619: header += headerToken . str ( ) ; }
2620: } else {
2621: header = tok1 . str ( ) . substr ( 1U , tok1 . str ( ) . size ( ) - 2U ) ;
2622: }
2623: std :: ifstream f ;
2624: const std :: string header2 = openHeader ( f , dui , sourcefile , header , systemheader ) ;
2625: tok . setstr ( header2 . empty ( ) ? "0" : "1" ) ;
2626:
2627: tok2 = tok2 . next ;
2628: while ( tok . next != tok2 ) {
2629: expr . deleteToken ( tok . next ) ; }
2630: }
2631: }
2632:
2633: static const char * const altopData [ ] = { "and" , "or" , "bitand" , "bitor" , "compl" , "not" , "not_eq" , "xor" } ;
2634: static const std :: set < std :: string > altop ( & altopData [ 0 ] , & altopData [ 8 ] ) ;
2635: static void simplifyName ( simplecpp :: TokenList & expr )
2636: {
2637: for ( simplecpp :: Token * tok = expr . front ( ) ; tok ; tok = tok . next ) {
2638: if ( tok . name ) {
2639: if ( altop . find ( tok . str ( ) ) != altop . end ( ) ) {
2640: bool alt ;
2641: if ( tok . str ( ) == "not" || tok . str ( ) == "compl" ) {
2642: alt = isAlternativeUnaryOp ( tok , tok . str ( ) ) ;
2643: } else {
2644: alt = isAlternativeBinaryOp ( tok , tok . str ( ) ) ;
2645: }
2646: if ( alt ) {
2647: continue ; }
2648: }
2649: if ( tok . next && tok . next . str ( ) == "(" ) {
2650: throw std :: runtime_error ( "undefined function-like macro invocation: " + tok . str ( ) + "( ... )" ) ; }
2651: tok . setstr ( "0" ) ;
2652: }
2653: }
2654: }
2655:
|
2663:
2664: static unsigned long long stringToULLbounded (
2665: const std :: string & s ,
2666: unsigned long & pos ,
2667: int base = 0 ,
2668: long minlen = 1 ,
2669: unsigned long maxlen = std :: string :: npos
2670: )
2671: {
2672: const std :: string sub = s . substr ( pos , maxlen ) ;
2673: const char * const start ; start = sub . c_str ( ) ;
2674: char * end ;
2675: const unsigned long long value = std :: strtoull ( start , & end , base ) ;
2676: pos += end - start ;
2677: if ( end - start < minlen ) {
2678: throw std :: runtime_error ( "expected digit" ) ; }
2679: return value ;
2680: }
2681:
|
2709:
2710: long long simplecpp :: characterLiteralToLL ( const std :: string & str )
2711: {
2712:
2713: bool narrow ; narrow = false ;
2714: bool utf8 ; utf8 = false ;
2715: bool utf16 ; utf16 = false ;
2716:
2717: unsigned long pos ;
2718:
2719: if ( ! str . empty ( ) && str [ 0 ] == '\'' ) {
2720: narrow = true ;
2721: pos = 1 ;
2722: } else if ( str . size ( ) >= 2 && str [ 0 ] == 'u' && str [ 1 ] == '\'' ) {
2723: utf16 = true ;
2724: pos = 2 ;
2725: } else if ( str . size ( ) >= 3 && str [ 0 ] == 'u' && str [ 1 ] == '8' && str [ 2 ] == '\'' ) {
2726: utf8 = true ;
2727: pos = 3 ;
2728: } else if ( str . size ( ) >= 2 && ( str [ 0 ] == 'L' || str [ 0 ] == 'U' ) && str [ 1 ] == '\'' ) {
2729: pos = 2 ;
2730: } else {
2731: throw std :: runtime_error ( "expected a character literal" ) ; }
2732:
2733: unsigned long long multivalue ; multivalue = 0 ;
2734:
2735: unsigned long nbytes ; nbytes = 0 ;
2736:
2737: while ( pos + 1 < str . size ( ) ) {
2738: if ( str [ pos ] == '\'' || str [ pos ] == '\n' ) {
2739: throw std :: runtime_error ( "raw single quotes and newlines not allowed in character literals" ) ; }
2740:
2741: if ( nbytes >= 1 && ! narrow ) {
2742: throw std :: runtime_error ( "multiple characters only supported in narrow character literals" ) ; }
2743:
2744: unsigned long long value ;
2745:
2746: if ( str [ pos ] == '\\' ) {
2747: pos ++ ;
2748: const char escape = str [ pos ++ ] ;
2749:
2750: if ( pos >= str . size ( ) ) {
2751: throw std :: runtime_error ( "unexpected end of character literal" ) ; }
2752:
2753: switch ( escape ) {
2754:
2755: case '%' :
2756: case '(' :
2757: case '[' :
2758: case '{' :
2759:
2760: case '\'' :
2761: case '"' :
2762: case '?' :
2763: case '\\' : ;
2764: value = static_cast < unsigned char > ( escape ) ;
2765: break ;
2766:
2767: case 'a' : ;
2768: value = static_cast < unsigned char > ( '\a' ) ;
2769: break ;
2770: case 'b' : ;
2771: value = static_cast < unsigned char > ( '\b' ) ;
2772: break ;
2773: case 'f' : ;
2774: value = static_cast < unsigned char > ( '\f' ) ;
2775: break ;
2776: case 'n' : ;
2777: value = static_cast < unsigned char > ( '\n' ) ;
2778: break ;
2779: case 'r' : ;
2780: value = static_cast < unsigned char > ( '\r' ) ;
2781: break ;
2782: case 't' : ;
2783: value = static_cast < unsigned char > ( '\t' ) ;
2784: break ;
2785: case 'v' : ;
2786: value = static_cast < unsigned char > ( '\v' ) ;
2787: break ;
2788:
2789:
2790: case 'e' :
2791: case 'E' : ;
2792: value = static_cast < unsigned char > ( '\x1b' ) ;
2793: break ;
2794:
2795: case '0' :
2796: case '1' :
2797: case '2' :
2798: case '3' :
2799: case '4' :
2800: case '5' :
2801: case '6' :
2802: case '7' : ;
2803:
2804: value = stringToULLbounded ( str , -- pos , 8 , 1 , 3 ) ;
2805: break ;
2806:
2807: case 'x' : ;
2808:
2809: value = stringToULLbounded ( str , pos , 16 ) ;
2810: break ;
2811:
2812: case 'u' :
2813: case 'U' : ; {
2814:
2815: const unsigned long ndigits = escape == 'u' ? 4 : 8 ;
2816: value = stringToULLbounded ( str , pos , 16 , ndigits , ndigits ) ;
2817:
2818:
2819:
2820: if ( ( ( narrow || utf8 ) && value > 0x7f ) || ( utf16 && value > 0xffff ) || value > 0x10ffff ) {
2821: throw std :: runtime_error ( "code point too large" ) ; }
2822:
2823: if ( value >= 0xd800 && value <= 0xdfff ) {
2824: throw std :: runtime_error ( "surrogate code points not allowed in universal character names" ) ; }
2825:
2826: break ;
2827: }
2828:
2829: default : ;
2830: throw std :: runtime_error ( "invalid escape sequence" ) ;
2831: }
2832: } else {
2833: value = static_cast < unsigned char > ( str [ pos ++ ] ) ;
2834:
2835: if ( ! narrow && value >= 0x80 ) {
2836:
|
2839:
2840: int additional_bytes ;
2841: if ( value >= 0xf5 ) {
2842: throw std :: runtime_error ( "assumed UTF-8 encoded source, but sequence is invalid" ) ; }
2843: if ( value >= 0xf0 ) {
2844: additional_bytes = 3 ; }
2845: else if ( value >= 0xe0 ) {
2846: additional_bytes = 2 ; }
2847: else if ( value >= 0xc2 ) {
2848: additional_bytes = 1 ; }
2849: else {
2850: throw std :: runtime_error ( "assumed UTF-8 encoded source, but sequence is invalid" ) ; }
2851:
2852: value &= ( 1 << ( 6 - additional_bytes ) ) - 1 ;
2853:
2854: while ( additional_bytes -- ) {
2855: if ( pos + 1 >= str . size ( ) ) {
2856: throw std :: runtime_error ( "assumed UTF-8 encoded source, but character literal ends unexpectedly" ) ; }
2857:
2858: const unsigned char c = str [ pos ++ ] ;
2859:
2860: if ( ( ( c >> 6 ) != 2 )
2861: || ( ! value && additional_bytes == 1 && c < 0xa0 )
2862: || ( ! value && additional_bytes == 2 && c < 0x90 ) ) {
2863: throw std :: runtime_error ( "assumed UTF-8 encoded source, but sequence is invalid" ) ; }
2864:
2865: value = ( value << 6 ) | ( c & ( ( 1 << 7 ) - 1 ) ) ;
2866: }
2867:
2868: if ( value >= 0xd800 && value <= 0xdfff ) {
2869: throw std :: runtime_error ( "assumed UTF-8 encoded source, but sequence is invalid" ) ; }
2870:
2871: if ( ( utf8 && value > 0x7f ) || ( utf16 && value > 0xffff ) || value > 0x10ffff ) {
2872: throw std :: runtime_error ( "code point too large" ) ; }
2873: }
2874: }
2875:
2876: if ( ( ( narrow || utf8 ) && value > std :: numeric_limits < unsigned char > :: max ( ) ) || ( utf16 && value >> 16 ) || value >> 32 ) {
2877: throw std :: runtime_error ( "numeric escape sequence too large" ) ; }
2878:
2879: multivalue <<= $8 ;
2880: multivalue |= value ;
2881: nbytes ++ ;
2882: }
2883:
2884: if ( pos + 1 != str . size ( ) || str [ pos ] != '\'' ) {
2885: throw std :: runtime_error ( "missing closing quote in character literal" ) ; }
2886:
2887: if ( ! nbytes ) {
2888: throw std :: runtime_error ( "empty character literal" ) ; }
2889:
2890:
2891: if ( narrow && nbytes == 1 ) {
2892: return static_cast < char > ( multivalue ) ; }
2893:
2894:
2895: if ( narrow ) {
2896: return static_cast < int > ( multivalue ) ; }
2897:
2898:
2899:
2900: return multivalue ;
2901: }
2902:
2903: static void simplifyNumbers ( simplecpp :: TokenList & expr )
2904: {
2905: for ( simplecpp :: Token * tok = expr . front ( ) ; tok ; tok = tok . next ) {
2906: if ( tok . str ( ) . size ( ) == 1U ) {
2907: continue ; }
2908: if ( tok . str ( ) . compare ( 0 , 2 , "0x" ) == 0 ) {
2909: tok . setstr ( toString ( stringToULL ( tok . str ( ) ) ) ) ; }
2910: else if ( ! tok . number && tok . str ( ) . find ( '\'' ) != std :: string :: npos ) {
2911: tok . setstr ( toString ( simplecpp :: characterLiteralToLL ( tok . str ( ) ) ) ) ; }
2912: }
2913: }
2914:
2915: static void simplifyComments ( simplecpp :: TokenList & expr )
2916: {
2917: for ( simplecpp :: Token * tok = expr . front ( ) ; tok ; ) {
2918: simplecpp :: Token * const d ; d = tok ;
2919: tok = tok . next ;
2920: if ( d . comment ) {
2921: expr . deleteToken ( d ) ; }
2922: }
2923: }
2924:
2925: static long long evaluate ( simplecpp :: TokenList & expr , const simplecpp :: DUI & dui , const std :: map < std :: string , unsigned long > & sizeOfType )
2926: {
2927: simplifyComments ( expr ) ;
2928: simplifySizeof ( expr , sizeOfType ) ;
2929: simplifyHasInclude ( expr , dui ) ;
2930: simplifyName ( expr ) ;
2931: simplifyNumbers ( expr ) ;
2932: expr . constFold ( ) ;
2933:
2934: return expr . cfront ( ) && expr . cfront ( ) == expr . cback ( ) && expr . cfront ( ) . number ? stringToLL ( expr . cfront ( ) . str ( ) ) : 0LL ;
2935: }
2936:
2937: static const simplecpp :: Token * gotoNextLine ( const simplecpp :: Token * tok )
2938: {
2939: const unsigned int line = tok . location . line ;
2940: const unsigned int file = tok . location . fileIndex ;
2941: while ( tok && tok . location . line == line && tok . location . fileIndex == file ) {
2942: tok = tok . next ; }
2943: return tok ;
2944: }
2945:
|
2975:
2976: static std :: string openHeaderDirect ( std :: ifstream & f , const std :: string & path )
2977: {
2978:
|
2981:
2982: f . open ( path . c_str ( ) ) ;
2983: if ( f . is_open ( ) ) {
2984: return path ; }
2985:
2986:
2987:
2988: return "" ;
2989: }
2990:
2991: static std :: string openHeader ( std :: ifstream & f , const simplecpp :: DUI & dui , const std :: string & sourcefile , const std :: string & header , bool systemheader )
2992: {
2993: if ( isAbsolutePath ( header ) ) {
2994: return openHeaderDirect ( f , simplecpp :: simplifyPath ( header ) ) ; }
2995:
2996:
2997: if ( ! systemheader ) {
2998: std :: string path ; path = openHeaderDirect ( f , simplecpp :: simplifyPath ( dirPath ( sourcefile ) + header ) ) ;
2999: if ( ! path . empty ( ) ) {
3000: return path ;
3001: }
3002: }
3003:
3004:
3005: for ( const auto & includePath : dui . includePaths ) {
3006: std :: string path ; path = openHeaderDirect ( f , simplecpp :: simplifyPath ( includePath + "/" + header ) ) ;
3007: if ( ! path . empty ( ) ) {
3008: return path ; }
3009: }
3010: return "" ;
3011: }
3012:
3013: std :: pair < simplecpp :: FileData * , bool > simplecpp :: FileDataCache :: tryload ( std :: unordered_map < std :: string , FileData * > :: iterator & name_it , const simplecpp :: DUI & dui , std :: vector < std :: string > & filenames , std :: list < Output > * outputList )
3014: {
3015: const std :: string & path = name_it . first ;
3016: FileID fileId ;
3017:
3018: if ( ! getFileId ( path , fileId ) ) {
3019: return { nullptr , false } ; }
3020:
3021: const auto id_it = mIdMap . find ( fileId ) ;
3022: if ( id_it != mIdMap . end ( ) ) {
3023: name_it . second = id_it . second ;
3024: return { id_it . second , false } ;
3025: }
3026:
3027: std :: ifstream f ( path ) ;
3028: FileData * const data ; data = new FileData { path , TokenList ( f , filenames , path , outputList ) } ;
3029:
3030: if ( dui . removeComments ) {
3031: data . tokens . removeComments ( ) ; }
3032:
3033: name_it . second = data ;
3034: mIdMap . emplace ( fileId , data ) ;
3035: mData . emplace_back ( data ) ;
3036:
3037: return { data , true } ;
3038: }
3039:
3040: std :: pair < simplecpp :: FileData * , bool > simplecpp :: FileDataCache :: get ( const std :: string & sourcefile , const std :: string & header , const simplecpp :: DUI & dui , bool systemheader , std :: vector < std :: string > & filenames , std :: list < Output > * outputList )
3041: {
3042: if ( isAbsolutePath ( header ) ) {
3043: auto ins ; ins = mNameMap . emplace ( simplecpp :: simplifyPath ( header ) , nullptr ) ;
3044:
3045: if ( ins . second ) {
3046: const auto ret = tryload ( ins . first , dui , filenames , outputList ) ;
3047: if ( ret . first != nullptr ) {
3048: return ret ;
3049: }
3050: } else {
3051: return { ins . first . second , false } ;
3052: }
3053:
3054: return { nullptr , false } ;
3055: }
3056:
3057: if ( ! systemheader ) {
3058: auto ins ; ins = mNameMap . emplace ( simplecpp :: simplifyPath ( dirPath ( sourcefile ) + header ) , nullptr ) ;
3059:
3060: if ( ins . second ) {
3061: const auto ret = tryload ( ins . first , dui , filenames , outputList ) ;
3062: if ( ret . first != nullptr ) {
3063: return ret ;
3064: }
3065: } else if ( ins . first . second != nullptr ) {
3066: return { ins . first . second , false } ;
3067: }
3068: }
3069:
3070: for ( const auto & includePath : dui . includePaths ) {
3071: auto ins ; ins = mNameMap . emplace ( simplecpp :: simplifyPath ( includePath + "/" + header ) , nullptr ) ;
3072:
3073: if ( ins . second ) {
3074: const auto ret = tryload ( ins . first , dui , filenames , outputList ) ;
3075: if ( ret . first != nullptr ) {
3076: return ret ;
3077: }
3078: } else if ( ins . first . second != nullptr ) {
3079: return { ins . first . second , false } ;
3080: }
3081: }
3082:
3083: return { nullptr , false } ;
3084: }
3085:
3086: bool simplecpp :: FileDataCache :: getFileId ( const std :: string & path , FileID & id )
3087: {
3088:
|
3099:
3100: struct stat statbuf ;
3101:
3102: if ( stat ( path . c_str ( ) , & statbuf ) != 0 ) {
3103: return false ; }
3104:
3105: id . dev = statbuf . st_dev ;
3106: id . ino = statbuf . st_ino ;
3107:
3108: return true ;
3109:
3110: }
3111:
3112: simplecpp :: FileDataCache simplecpp :: load ( const simplecpp :: TokenList & rawtokens , std :: vector < std :: string > & filenames , const simplecpp :: DUI & dui , std :: list < Output > * outputList )
3113: {
3114:
|
3118:
3119: FileDataCache cache ;
3120:
3121: std :: list < const Token * > filelist ;
3122:
3123:
3124: for ( std :: list < std :: string > :: const_iterator it = dui . includes . begin ( ) ; it != dui . includes . end ( ) ; ++ it ) {
3125: const std :: string & filename = * it ;
3126:
3127: const auto loadResult = cache . get ( "" , filename , dui , false , filenames , outputList ) ;
3128: const bool loaded = loadResult . second ;
3129: FileData * const filedata ; filedata = loadResult . first ;
3130:
3131: if ( filedata == nullptr ) {
3132: if ( outputList ) {
3133: simplecpp :: Output err ( filenames ) ;
3134: err . type = simplecpp :: Output :: EXPLICIT_INCLUDE_NOT_FOUND ;
3135: err . location = Location ( filenames ) ;
3136: err . msg = "Can not open include file '" + filename + "' that is explicitly included." ;
3137: outputList . push_back ( err ) ;
3138: }
3139: continue ;
3140: }
3141:
3142: if ( ! loaded ) {
3143: continue ; }
3144:
3145: if ( ! filedata . tokens . front ( ) ) {
3146: continue ; }
3147:
3148: if ( dui . removeComments ) {
3149: filedata . tokens . removeComments ( ) ; }
3150:
3151: filelist . push_back ( filedata . tokens . front ( ) ) ;
3152: }
3153:
3154: for ( const Token * rawtok = rawtokens . cfront ( ) ; rawtok || ! filelist . empty ( ) ; rawtok = rawtok ? rawtok . next : nullptr ) {
3155: if ( rawtok == nullptr ) {
3156: rawtok = filelist . back ( ) ;
3157: filelist . pop_back ( ) ;
3158: }
3159:
3160: if ( rawtok . op != '#' || sameline ( rawtok . previousSkipComments ( ) , rawtok ) ) {
3161: continue ; }
3162:
3163: rawtok = rawtok . nextSkipComments ( ) ;
3164: if ( ! rawtok || rawtok . str ( ) != INCLUDE ) {
3165: continue ; }
3166:
3167: const std :: string & sourcefile = rawtok . location . file ( ) ;
3168:
3169: const Token * const htok ; htok = rawtok . nextSkipComments ( ) ;
3170: if ( ! sameline ( rawtok , htok ) ) {
3171: continue ; }
3172:
3173: const bool systemheader = htok . str ( ) [ 0 ] == '<' ;
3174: const std :: string header ( htok . str ( ) . substr ( 1U , htok . str ( ) . size ( ) - 2U ) ) ;
3175:
3176: FileData * const filedata ; filedata = cache . get ( sourcefile , header , dui , systemheader , filenames , outputList ) . first ;
3177: if ( ! filedata ) {
3178: continue ; }
3179:
3180: if ( dui . removeComments ) {
3181: filedata . tokens . removeComments ( ) ; }
3182:
3183: if ( filedata . tokens . front ( ) ) {
3184: filelist . push_back ( filedata . tokens . front ( ) ) ; }
3185: }
3186:
3187: return cache ;
3188: }
3189:
3190: static bool preprocessToken ( simplecpp :: TokenList & output , const simplecpp :: Token * * tok1 , std :: unordered_map < std :: string , Macro > & macros , std :: vector < std :: string > & files , std :: list < Output > * outputList )
3191: {
3192: const simplecpp :: Token * const tok ; tok = * tok1 ;
3193: const std :: unordered_map < std :: string , Macro > :: const_iterator it = macros . find ( tok . str ( ) ) ;
3194: if ( it != macros . end ( ) ) {
3195: simplecpp :: TokenList value ( files ) ;
3196: try {
3197: * tok1 = it . second . expand ( & value , tok , macros , files ) ;
3198: } catch ( simplecpp :: Macro :: Error & err ) {
3199: if ( outputList ) {
3200: simplecpp :: Output out ( files ) ;
3201: out . type = simplecpp :: Output :: SYNTAX_ERROR ;
3202: out . location = err . location ;
3203: out . msg = "failed to expand \'" + tok . str ( ) + "\', " + err . what ;
3204: outputList . push_back ( out ) ;
3205: }
3206: return false ;
3207: }
3208: output . takeTokens ( value ) ;
3209: } else {
3210: if ( ! tok . comment ) {
3211: output . push_back ( new simplecpp :: Token ( * tok ) ) ; }
3212: * tok1 = tok . next ;
3213: }
3214: return true ;
3215: }
3216:
3217: static void getLocaltime ( struct tm & ltime )
3218: {
3219: time_t t ;
3220: time ( & t ) ;
3221:
3222:
3223: localtime_r ( & t , & ltime ) ;
3224:
3225:
3226:
3227: }
3228:
3229: static std :: string getDateDefine ( const struct tm * timep )
3230: {
3231: char buf [ ] = "??? ?? ????" ;
3232: strftime ( buf , sizeof ( buf ) , "%b %d %Y" , timep ) ;
3233: return std :: string ( "\"" ) . append ( buf ) . append ( "\"" ) ;
3234: }
3235:
3236: static std :: string getTimeDefine ( const struct tm * timep )
3237: {
3238: char buf [ ] = "??:??:??" ;
3239: strftime ( buf , sizeof ( buf ) , "%T" , timep ) ;
3240: return std :: string ( "\"" ) . append ( buf ) . append ( "\"" ) ;
3241: }
3242:
3243: void simplecpp :: preprocess ( simplecpp :: TokenList & output , const simplecpp :: TokenList & rawtokens , std :: vector < std :: string > & files , simplecpp :: FileDataCache & cache , const simplecpp :: DUI & dui , std :: list < Output > * outputList , std :: list < simplecpp :: MacroUsage > * macroUsage , std :: list < simplecpp :: IfCond > * ifCond )
3244: {
3245:
|
3249:
3250: std :: map < std :: string , unsigned long > sizeOfType ( rawtokens . sizeOfType ) ;
3251: sizeOfType . insert ( std :: make_pair ( "char" , sizeof ( char ) ) ) ;
3252: sizeOfType . insert ( std :: make_pair ( "short" , sizeof ( short ) ) ) ;
3253: sizeOfType . insert ( std :: make_pair ( "short int" , sizeOfType [ "short" ] ) ) ;
3254: sizeOfType . insert ( std :: make_pair ( "int" , sizeof ( int ) ) ) ;
3255: sizeOfType . insert ( std :: make_pair ( "long" , sizeof ( long ) ) ) ;
3256: sizeOfType . insert ( std :: make_pair ( "long int" , sizeOfType [ "long" ] ) ) ;
3257: sizeOfType . insert ( std :: make_pair ( "long long" , sizeof ( long long ) ) ) ;
3258: sizeOfType . insert ( std :: make_pair ( "float" , sizeof ( float ) ) ) ;
3259: sizeOfType . insert ( std :: make_pair ( "double" , sizeof ( double ) ) ) ;
3260: sizeOfType . insert ( std :: make_pair ( "long double" , sizeof ( long double ) ) ) ;
3261: sizeOfType . insert ( std :: make_pair ( "char *" , sizeof ( char * ) ) ) ;
3262: sizeOfType . insert ( std :: make_pair ( "short *" , sizeof ( short * ) ) ) ;
3263: sizeOfType . insert ( std :: make_pair ( "short int *" , sizeOfType [ "short *" ] ) ) ;
3264: sizeOfType . insert ( std :: make_pair ( "int *" , sizeof ( int * ) ) ) ;
3265: sizeOfType . insert ( std :: make_pair ( "long *" , sizeof ( long * ) ) ) ;
3266: sizeOfType . insert ( std :: make_pair ( "long int *" , sizeOfType [ "long *" ] ) ) ;
3267: sizeOfType . insert ( std :: make_pair ( "long long *" , sizeof ( long long * ) ) ) ;
3268: sizeOfType . insert ( std :: make_pair ( "float *" , sizeof ( float * ) ) ) ;
3269: sizeOfType . insert ( std :: make_pair ( "double *" , sizeof ( double * ) ) ) ;
3270: sizeOfType . insert ( std :: make_pair ( "long double *" , sizeof ( long double * ) ) ) ;
3271:
3272:
3273: std :: vector < std :: string > dummy ;
3274:
3275: const bool hasInclude = isCpp17OrLater ( dui ) || isGnu ( dui ) ;
3276: std :: unordered_map < std :: string , Macro > macros ;
3277: bool strictAnsiDefined ; strictAnsiDefined = false ;
3278: for ( std :: list < std :: string > :: const_iterator it = dui . defines . begin ( ) ; it != dui . defines . end ( ) ; ++ it ) {
3279: const std :: string & macrostr = * it ;
3280: const std :: string :: size_type eq = macrostr . find ( '=' ) ;
3281: const std :: string :: size_type par = macrostr . find ( '(' ) ;
3282: const std :: string macroname = macrostr . substr ( 0 , std :: min ( eq , par ) ) ;
3283: if ( macroname == "__STRICT_ANSI__" ) {
3284: strictAnsiDefined = true ; }
3285: if ( dui . undefined . find ( macroname ) != dui . undefined . end ( ) ) {
3286: continue ; }
3287: const std :: string lhs ( macrostr . substr ( 0 , eq ) ) ;
3288: const std :: string rhs ( eq == std :: string :: npos ? std :: string ( "1" ) : macrostr . substr ( eq + 1 ) ) ;
3289: const Macro macro ( lhs , rhs , dummy ) ;
3290: macros . insert ( std :: pair < std :: string , Macro > ( macro . name ( ) , macro ) ) ;
3291: }
3292:
3293: const bool strictAnsiUndefined = dui . undefined . find ( "__STRICT_ANSI__" ) != dui . undefined . cend ( ) ;
3294: if ( ! isGnu ( dui ) && ! strictAnsiDefined && ! strictAnsiUndefined ) {
3295: macros . insert ( std :: pair < std :: string , Macro > ( "__STRICT_ANSI__" , Macro ( "__STRICT_ANSI__" , "1" , dummy ) ) ) ; }
3296:
3297: macros . insert ( std :: make_pair ( "__FILE__" , Macro ( "__FILE__" , "__FILE__" , dummy ) ) ) ;
3298: macros . insert ( std :: make_pair ( "__LINE__" , Macro ( "__LINE__" , "__LINE__" , dummy ) ) ) ;
3299: macros . insert ( std :: make_pair ( "__COUNTER__" , Macro ( "__COUNTER__" , "__COUNTER__" , dummy ) ) ) ;
3300: struct tm ltime ; ltime = { } ;
3301: getLocaltime ( ltime ) ;
3302: macros . insert ( std :: make_pair ( "__DATE__" , Macro ( "__DATE__" , getDateDefine ( & ltime ) , dummy ) ) ) ;
3303: macros . insert ( std :: make_pair ( "__TIME__" , Macro ( "__TIME__" , getTimeDefine ( & ltime ) , dummy ) ) ) ;
3304:
3305: if ( ! dui . std . empty ( ) ) {
3306: const cstd_t c_std = simplecpp :: getCStd ( dui . std ) ;
3307: if ( c_std != CUnknown ) {
3308: const std :: string std_def = simplecpp :: getCStdString ( c_std ) ;
3309: if ( ! std_def . empty ( ) ) {
3310: macros . insert ( std :: make_pair ( "__STDC_VERSION__" , Macro ( "__STDC_VERSION__" , std_def , dummy ) ) ) ; }
3311: } else {
3312: const cppstd_t cpp_std = simplecpp :: getCppStd ( dui . std ) ;
3313: if ( cpp_std == CPPUnknown ) {
3314: if ( outputList ) {
3315: simplecpp :: Output err ( files ) ;
3316: err . type = Output :: DUI_ERROR ;
3317: err . msg = "unknown standard specified: '" + dui . std + "'" ;
3318: outputList . push_back ( err ) ;
3319: }
3320: output . clear ( ) ;
3321: return ;
3322: }
3323: const std :: string std_def = simplecpp :: getCppStdString ( cpp_std ) ;
3324: if ( ! std_def . empty ( ) ) {
3325: macros . insert ( std :: make_pair ( "__cplusplus" , Macro ( "__cplusplus" , std_def , dummy ) ) ) ; }
3326: }
3327: }
3328:
|
3331:
3332: enum IfState { True , ElseIsTrue , AlwaysFalse } ;
3333: std :: stack < int > ifstates ;
3334: std :: stack < const Token * > iftokens ;
3335: ifstates . push ( True ) ;
3336:
3337: std :: stack < const Token * > includetokenstack ;
3338:
3339: std :: set < std :: string > pragmaOnce ;
3340:
3341: includetokenstack . push ( rawtokens . cfront ( ) ) ;
3342: for ( std :: list < std :: string > :: const_iterator it = dui . includes . begin ( ) ; it != dui . includes . end ( ) ; ++ it ) {
3343: const FileData * const filedata ; filedata = cache . get ( "" , * it , dui , false , files , outputList ) . first ;
3344: if ( filedata != nullptr && filedata . tokens . cfront ( ) != nullptr ) {
3345: includetokenstack . push ( filedata . tokens . cfront ( ) ) ; }
3346: }
3347:
3348: std :: map < std :: string , std :: list < Location > > maybeUsedMacros ;
3349:
3350: for ( const Token * rawtok = nullptr ; rawtok || ! includetokenstack . empty ( ) ; ) {
3351: if ( rawtok == nullptr ) {
3352: rawtok = includetokenstack . top ( ) ;
3353: includetokenstack . pop ( ) ;
3354: continue ;
3355: }
3356:
3357: if ( rawtok . op == '#' && ! sameline ( rawtok . previousSkipComments ( ) , rawtok ) ) {
3358: if ( ! sameline ( rawtok , rawtok . next ) ) {
3359: rawtok = rawtok . next ;
3360: continue ;
3361: }
3362: rawtok = rawtok . next ;
3363: if ( ! rawtok . name ) {
3364: rawtok = gotoNextLine ( rawtok ) ;
3365: continue ;
3366: }
3367:
3368: if ( ifstates . size ( ) <= 1U && ( rawtok . str ( ) == ELIF || rawtok . str ( ) == ELSE || rawtok . str ( ) == ENDIF ) ) {
3369: if ( outputList ) {
3370: simplecpp :: Output err ( files ) ;
3371: err . type = Output :: SYNTAX_ERROR ;
3372: err . location = rawtok . location ;
3373: err . msg = "#" + rawtok . str ( ) + " without #if" ;
3374: outputList . push_back ( err ) ;
3375: }
3376: output . clear ( ) ;
3377: return ;
3378: }
3379:
3380: if ( ifstates . top ( ) == True && ( rawtok . str ( ) == ERROR || rawtok . str ( ) == WARNING ) ) {
3381: if ( outputList ) {
3382: simplecpp :: Output err ( rawtok . location . files ) ;
3383: err . type = rawtok . str ( ) == ERROR ? Output :: ERROR : Output :: WARNING ;
3384: err . location = rawtok . location ;
3385: for ( const Token * tok = rawtok . next ; tok && sameline ( rawtok , tok ) ; tok = tok . next ) {
3386: if ( ! err . msg . empty ( ) && isNameChar ( tok . str ( ) [ 0 ] ) ) {
3387: err . msg += ' ' ; }
3388: err . msg += tok . str ( ) ;
3389: }
3390: err . msg = '#' + rawtok . str ( ) + ' ' + err . msg ;
3391: outputList . push_back ( err ) ;
3392: }
3393: if ( rawtok . str ( ) == ERROR ) {
3394: output . clear ( ) ;
3395: return ;
3396: }
3397: }
3398:
3399: if ( rawtok . str ( ) == DEFINE ) {
3400: if ( ifstates . top ( ) != True ) {
3401: continue ; }
3402: try {
3403: const Macro & macro = Macro ( rawtok . previous , files ) ;
3404: if ( dui . undefined . find ( macro . name ( ) ) == dui . undefined . end ( ) ) {
3405: const MacroMap :: iterator it = macros . find ( macro . name ( ) ) ;
3406: if ( it == macros . end ( ) ) {
3407: macros . insert ( std :: pair < std :: string , Macro > ( macro . name ( ) , macro ) ) ; }
3408: else {
3409: it . second = macro ; }
3410: }
3411: } catch ( const std :: runtime_error & ) {
3412: if ( outputList ) {
3413: simplecpp :: Output err ( files ) ;
3414: err . type = Output :: SYNTAX_ERROR ;
3415: err . location = rawtok . location ;
3416: err . msg = "Failed to parse #define" ;
3417: outputList . push_back ( err ) ;
3418: }
3419: output . clear ( ) ;
3420: return ;
3421: } catch ( simplecpp :: Macro :: Error & err ) {
3422: if ( outputList ) {
3423: simplecpp :: Output out ( files ) ;
3424: out . type = simplecpp :: Output :: SYNTAX_ERROR ;
3425: out . location = err . location ;
3426: out . msg = "Failed to parse #define, " + err . what ;
3427: outputList . push_back ( out ) ;
3428: }
3429: output . clear ( ) ;
3430: return ;
3431: }
3432: } else if ( ifstates . top ( ) == True && rawtok . str ( ) == INCLUDE ) {
3433: TokenList inc1 ( files ) ;
3434: for ( const Token * inctok = rawtok . next ; sameline ( rawtok , inctok ) ; inctok = inctok . next ) {
3435: if ( ! inctok . comment ) {
3436: inc1 . push_back ( new Token ( * inctok ) ) ; }
3437: }
3438: TokenList inc2 ( files ) ;
3439: if ( ! inc1 . empty ( ) && inc1 . cfront ( ) . name ) {
3440: const Token * inctok ; inctok = inc1 . cfront ( ) ;
3441: if ( ! preprocessToken ( inc2 , & inctok , macros , files , outputList ) ) {
3442: output . clear ( ) ;
3443: return ;
3444: }
3445: } else {
3446: inc2 . takeTokens ( inc1 ) ;
3447: }
3448:
3449: if ( ! inc1 . empty ( ) && ! inc2 . empty ( ) && inc2 . cfront ( ) . op == '<' && inc2 . cback ( ) . op == '>' ) {
3450: std :: string hdr ;
3451:
3452:
3453: for ( const Token * tok = inc2 . cfront ( ) ; tok ; tok = tok . next ) {
3454: hdr += tok . str ( ) ;
3455: }
3456: inc2 . clear ( ) ;
3457: inc2 . push_back ( new Token ( hdr , inc1 . cfront ( ) . location ) ) ;
3458: inc2 . front ( ) . op = '<' ;
3459: }
3460:
3461: if ( inc2 . empty ( ) || inc2 . cfront ( ) . str ( ) . size ( ) <= 2U ) {
3462: if ( outputList ) {
3463: simplecpp :: Output err ( files ) ;
3464: err . type = Output :: SYNTAX_ERROR ;
3465: err . location = rawtok . location ;
3466: err . msg = "No header in #include" ;
3467: outputList . push_back ( err ) ;
3468: }
3469: output . clear ( ) ;
3470: return ;
3471: }
3472:
3473: const Token * const inctok ; inctok = inc2 . cfront ( ) ;
3474:
3475: const bool systemheader = inctok . str ( ) [ 0 ] == '<' ;
3476: const std :: string header ( inctok . str ( ) . substr ( 1U , inctok . str ( ) . size ( ) - 2U ) ) ;
3477: const FileData * const filedata ; filedata = cache . get ( rawtok . location . file ( ) , header , dui , systemheader , files , outputList ) . first ;
3478: if ( filedata == nullptr ) {
3479: if ( outputList ) {
3480: simplecpp :: Output out ( files ) ;
3481: out . type = Output :: MISSING_HEADER ;
3482: out . location = rawtok . location ;
3483: out . msg = "Header not found: " + inctok . str ( ) ;
3484: outputList . push_back ( out ) ;
3485: }
3486: } else if ( includetokenstack . size ( ) >= 400 ) {
3487: if ( outputList ) {
3488: simplecpp :: Output out ( files ) ;
3489: out . type = Output :: INCLUDE_NESTED_TOO_DEEPLY ;
3490: out . location = rawtok . location ;
3491: out . msg = "#include nested too deeply" ;
3492: outputList . push_back ( out ) ;
3493: }
3494: } else if ( pragmaOnce . find ( filedata . filename ) == pragmaOnce . end ( ) ) {
3495: includetokenstack . push ( gotoNextLine ( rawtok ) ) ;
3496: rawtok = filedata . tokens . cfront ( ) ;
3497: continue ;
3498: }
3499: } else if ( rawtok . str ( ) == IF || rawtok . str ( ) == IFDEF || rawtok . str ( ) == IFNDEF || rawtok . str ( ) == ELIF ) {
3500: if ( ! sameline ( rawtok , rawtok . next ) ) {
3501: if ( outputList ) {
3502: simplecpp :: Output out ( files ) ;
3503: out . type = Output :: SYNTAX_ERROR ;
3504: out . location = rawtok . location ;
3505: out . msg = "Syntax error in #" + rawtok . str ( ) ;
3506: outputList . push_back ( out ) ;
3507: }
3508: output . clear ( ) ;
3509: return ;
3510: }
3511:
3512: bool conditionIsTrue ;
3513: if ( ifstates . top ( ) == AlwaysFalse || ( ifstates . top ( ) == ElseIsTrue && rawtok . str ( ) != ELIF ) ) {
3514: conditionIsTrue = false ; }
3515: else if ( rawtok . str ( ) == IFDEF ) {
3516: conditionIsTrue = macros . find ( rawtok . next . str ( ) ) != macros . end ( ) || ( hasInclude && rawtok . next . str ( ) == HAS_INCLUDE ) ;
3517: maybeUsedMacros [ rawtok . next . str ( ) ] . push_back ( rawtok . next . location ) ;
3518: } else if ( rawtok . str ( ) == IFNDEF ) {
3519: conditionIsTrue = macros . find ( rawtok . next . str ( ) ) == macros . end ( ) && ! ( hasInclude && rawtok . next . str ( ) == HAS_INCLUDE ) ;
3520: maybeUsedMacros [ rawtok . next . str ( ) ] . push_back ( rawtok . next . location ) ;
3521: } else {
3522: TokenList expr ( files ) ;
3523: for ( const Token * tok = rawtok . next ; tok && tok . location . sameline ( rawtok . location ) ; tok = tok . next ) {
3524: if ( ! tok . name ) {
3525: expr . push_back ( new Token ( * tok ) ) ;
3526: continue ;
3527: }
3528:
3529: if ( tok . str ( ) == DEFINED ) {
3530: tok = tok . next ;
3531: const bool par = tok && tok . op == '(' ;
3532: if ( par ) {
3533: tok = tok . next ; }
3534: maybeUsedMacros [ rawtok . next . str ( ) ] . push_back ( rawtok . next . location ) ;
3535: if ( tok ) {
3536: if ( macros . find ( tok . str ( ) ) != macros . end ( ) ) {
3537: expr . push_back ( new Token ( "1" , tok . location ) ) ; }
3538: else if ( hasInclude && tok . str ( ) == HAS_INCLUDE ) {
3539: expr . push_back ( new Token ( "1" , tok . location ) ) ; }
3540: else {
3541: expr . push_back ( new Token ( "0" , tok . location ) ) ; }
3542: }
3543: if ( par ) {
3544: tok = tok ? tok . next : nullptr ; }
3545: if ( ! tok || ! sameline ( rawtok , tok ) || ( par && tok . op != ')' ) ) {
3546: if ( outputList ) {
3547: Output out ( rawtok . location . files ) ;
3548: out . type = Output :: SYNTAX_ERROR ;
3549: out . location = rawtok . location ;
3550: out . msg = "failed to evaluate " + std :: string ( rawtok . str ( ) == IF ? "#if" : "#elif" ) + " condition" ;
3551: outputList . push_back ( out ) ;
3552: }
3553: output . clear ( ) ;
3554: return ;
3555: }
3556: continue ;
3557: }
3558:
3559: if ( hasInclude && tok . str ( ) == HAS_INCLUDE ) {
3560: tok = tok . next ;
3561: const bool par = tok && tok . op == '(' ;
3562: if ( par ) {
3563: tok = tok . next ; }
3564: bool closingAngularBracket ; closingAngularBracket = false ;
3565: if ( tok ) {
3566: const std :: string & sourcefile = rawtok . location . file ( ) ;
3567: const bool systemheader = tok && tok . op == '<' ;
3568: std :: string header ;
3569:
3570: if ( systemheader ) {
3571: while ( ( tok = tok . next ) && tok . op != '>' ) {
3572: header += tok . str ( ) ; }
3573: if ( tok && tok . op == '>' ) {
3574: closingAngularBracket = true ; }
3575: } else {
3576: header = tok . str ( ) . substr ( 1U , tok . str ( ) . size ( ) - 2U ) ;
3577: closingAngularBracket = true ;
3578: }
3579: std :: ifstream f ;
3580: const std :: string header2 = openHeader ( f , dui , sourcefile , header , systemheader ) ;
3581: expr . push_back ( new Token ( header2 . empty ( ) ? "0" : "1" , tok . location ) ) ;
3582: }
3583: if ( par ) {
3584: tok = tok ? tok . next : nullptr ; }
3585: if ( ! tok || ! sameline ( rawtok , tok ) || ( par && tok . op != ')' ) || ( ! closingAngularBracket ) ) {
3586: if ( outputList ) {
3587: Output out ( rawtok . location . files ) ;
3588: out . type = Output :: SYNTAX_ERROR ;
3589: out . location = rawtok . location ;
3590: out . msg = "failed to evaluate " + std :: string ( rawtok . str ( ) == IF ? "#if" : "#elif" ) + " condition" ;
3591: outputList . push_back ( out ) ;
3592: }
3593: output . clear ( ) ;
3594: return ;
3595: }
3596: continue ;
3597: }
3598:
3599: maybeUsedMacros [ rawtok . next . str ( ) ] . push_back ( rawtok . next . location ) ;
3600:
3601: const Token * tmp ; tmp = tok ;
3602: if ( ! preprocessToken ( expr , & tmp , macros , files , outputList ) ) {
3603: output . clear ( ) ;
3604: return ;
3605: }
3606: if ( ! tmp ) {
3607: break ; }
3608: tok = tmp . previous ;
3609: }
3610: try {
3611: if ( ifCond ) {
3612: std :: string E ;
3613: for ( const simplecpp :: Token * tok = expr . cfront ( ) ; tok ; tok = tok . next ) {
3614: E += ( E . empty ( ) ? "" : " " ) + tok . str ( ) ; }
3615: const long long result = evaluate ( expr , dui , sizeOfType ) ;
3616: conditionIsTrue = result != 0 ;
3617: ifCond . push_back ( IfCond ( rawtok . location , E , result ) ) ;
3618: } else {
3619: const long long result = evaluate ( expr , dui , sizeOfType ) ;
3620: conditionIsTrue = result != 0 ;
3621: }
3622: } catch ( const std :: exception & e ) {
3623: if ( outputList ) {
3624: Output out ( rawtok . location . files ) ;
3625: out . type = Output :: SYNTAX_ERROR ;
3626: out . location = rawtok . location ;
3627: out . msg = "failed to evaluate " + std :: string ( rawtok . str ( ) == IF ? "#if" : "#elif" ) + " condition" ;
3628: if ( e . what ( ) && * e . what ( ) ) {
3629: out . msg += std :: string ( ", " ) + e . what ( ) ; }
3630: outputList . push_back ( out ) ;
3631: }
3632: output . clear ( ) ;
3633: return ;
3634: }
3635: }
3636:
3637: if ( rawtok . str ( ) != ELIF ) {
3638:
3639: if ( ifstates . top ( ) != True ) {
3640: ifstates . push ( AlwaysFalse ) ; }
3641: else {
3642: ifstates . push ( conditionIsTrue ? True : ElseIsTrue ) ; }
3643: iftokens . push ( rawtok ) ;
3644: } else if ( ifstates . top ( ) == True ) {
3645: ifstates . top ( ) = AlwaysFalse ;
3646: iftokens . top ( ) . nextcond = rawtok ;
3647: iftokens . top ( ) = rawtok ;
3648: } else if ( ifstates . top ( ) == ElseIsTrue && conditionIsTrue ) {
3649: ifstates . top ( ) = True ;
3650: iftokens . top ( ) . nextcond = rawtok ;
3651: iftokens . top ( ) = rawtok ;
3652: }
3653: } else if ( rawtok . str ( ) == ELSE ) {
3654: ifstates . top ( ) = ( ifstates . top ( ) == ElseIsTrue ) ? True : AlwaysFalse ;
3655: iftokens . top ( ) . nextcond = rawtok ;
3656: iftokens . top ( ) = rawtok ;
3657: } else if ( rawtok . str ( ) == ENDIF ) {
3658: ifstates . pop ( ) ;
3659: iftokens . top ( ) . nextcond = rawtok ;
3660: iftokens . pop ( ) ;
3661: } else if ( rawtok . str ( ) == UNDEF ) {
3662: if ( ifstates . top ( ) == True ) {
3663: const Token * tok ; tok = rawtok . next ;
3664: while ( sameline ( rawtok , tok ) && tok . comment ) {
3665: tok = tok . next ; }
3666: if ( sameline ( rawtok , tok ) ) {
3667: macros . erase ( tok . str ( ) ) ; }
3668: }
3669: } else if ( ifstates . top ( ) == True && rawtok . str ( ) == PRAGMA && rawtok . next && rawtok . next . str ( ) == ONCE && sameline ( rawtok , rawtok . next ) ) {
3670: pragmaOnce . insert ( rawtok . location . file ( ) ) ;
3671: }
3672: if ( ifstates . top ( ) != True && rawtok . nextcond ) {
3673: rawtok = rawtok . nextcond . previous ; }
3674: else {
3675: rawtok = gotoNextLine ( rawtok ) ; }
3676: continue ;
3677: }
3678:
3679: if ( ifstates . top ( ) != True ) {
3680:
3681: rawtok = gotoNextLine ( rawtok ) ;
3682: continue ;
3683: }
3684:
3685: bool hash ; hash = false ; bool hashhash ; hashhash = false ;
3686: if ( rawtok . op == '#' && sameline ( rawtok , rawtok . next ) ) {
3687: if ( rawtok . next . op != '#' ) {
3688: hash = true ;
3689: rawtok = rawtok . next ;
3690: } else if ( sameline ( rawtok , rawtok . next . next ) ) {
3691: hashhash = true ;
3692: rawtok = rawtok . next . next ;
3693: }
3694: }
3695:
3696: const Location loc ( rawtok . location ) ;
3697: TokenList tokens ( files ) ;
3698:
3699: if ( ! preprocessToken ( tokens , & rawtok , macros , files , outputList ) ) {
3700: output . clear ( ) ;
3701: return ;
3702: }
3703:
3704: if ( hash || hashhash ) {
3705: std :: string s ;
3706: for ( const Token * hashtok = tokens . cfront ( ) ; hashtok ; hashtok = hashtok . next ) {
3707: s += hashtok . str ( ) ; }
3708: if ( hash ) {
3709: output . push_back ( new Token ( '\"' + s + '\"' , loc ) ) ; }
3710: else if ( output . back ( ) ) {
3711: output . back ( ) . setstr ( output . cback ( ) . str ( ) + s ) ; }
3712: else {
3713: output . push_back ( new Token ( s , loc ) ) ; }
3714: } else {
3715: output . takeTokens ( tokens ) ;
3716: }
3717: }
3718:
3719: if ( macroUsage ) {
3720: for ( std :: unordered_map < std :: string , Macro > :: const_iterator macroIt = macros . begin ( ) ; macroIt != macros . end ( ) ; ++ macroIt ) {
3721: const Macro & macro = macroIt . second ;
3722: std :: list < Location > usage ; usage = macro . usage ( ) ;
3723: const std :: list < Location > & temp = maybeUsedMacros [ macro . name ( ) ] ;
3724: usage . insert ( usage . end ( ) , temp . begin ( ) , temp . end ( ) ) ;
3725: for ( std :: list < Location > :: const_iterator usageIt = usage . begin ( ) ; usageIt != usage . end ( ) ; ++ usageIt ) {
3726: MacroUsage mu ( usageIt . files , macro . valueDefinedInCode ( ) ) ;
3727: mu . macroName = macro . name ( ) ;
3728: mu . macroLocation = macro . defineLocation ( ) ;
3729: mu . useLocation = * usageIt ;
3730: macroUsage . push_back ( mu ) ;
3731: }
3732: }
3733: }
3734: }
3735:
3736: void simplecpp :: cleanup ( FileDataCache & cache )
3737: {
3738: cache . clear ( ) ;
3739: }
3740:
3741: simplecpp :: cstd_t simplecpp :: getCStd ( const std :: string & std )
3742: {
3743: if ( std == "c90" || std == "c89" || std == "iso9899:1990" || std == "iso9899:199409" || std == "gnu90" || std == "gnu89" ) {
3744: return C89 ; }
3745: if ( std == "c99" || std == "c9x" || std == "iso9899:1999" || std == "iso9899:199x" || std == "gnu99" || std == "gnu9x" ) {
3746: return C99 ; }
3747: if ( std == "c11" || std == "c1x" || std == "iso9899:2011" || std == "gnu11" || std == "gnu1x" ) {
3748: return C11 ; }
3749: if ( std == "c17" || std == "c18" || std == "iso9899:2017" || std == "iso9899:2018" || std == "gnu17" || std == "gnu18" ) {
3750: return C17 ; }
3751: if ( std == "c23" || std == "gnu23" || std == "c2x" || std == "gnu2x" ) {
3752: return C23 ; }
3753: return CUnknown ;
3754: }
3755:
3756: std :: string simplecpp :: getCStdString ( cstd_t std )
3757: {
3758: switch ( std ) {
3759: case C89 : ;
3760:
3761: return "" ;
3762: case C99 : ;
3763: return "199901L" ;
3764: case C11 : ;
3765: return "201112L" ;
3766: case C17 : ;
3767: return "201710L" ;
3768: case C23 : ;
3769:
|
3772:
3773: return "202311L" ;
3774: case CUnknown : ;
3775: return "" ;
3776: }
3777: return "" ;
3778: }
3779:
3780: std :: string simplecpp :: getCStdString ( const std :: string & std )
3781: {
3782: return getCStdString ( getCStd ( std ) ) ;
3783: }
3784:
3785: simplecpp :: cppstd_t simplecpp :: getCppStd ( const std :: string & std )
3786: {
3787: if ( std == "c++98" || std == "c++03" || std == "gnu++98" || std == "gnu++03" ) {
3788: return CPP03 ; }
3789: if ( std == "c++11" || std == "gnu++11" || std == "c++0x" || std == "gnu++0x" ) {
3790: return CPP11 ; }
3791: if ( std == "c++14" || std == "c++1y" || std == "gnu++14" || std == "gnu++1y" ) {
3792: return CPP14 ; }
3793: if ( std == "c++17" || std == "c++1z" || std == "gnu++17" || std == "gnu++1z" ) {
3794: return CPP17 ; }
3795: if ( std == "c++20" || std == "c++2a" || std == "gnu++20" || std == "gnu++2a" ) {
3796: return CPP20 ; }
3797: if ( std == "c++23" || std == "c++2b" || std == "gnu++23" || std == "gnu++2b" ) {
3798: return CPP23 ; }
3799: if ( std == "c++26" || std == "c++2c" || std == "gnu++26" || std == "gnu++2c" ) {
3800: return CPP26 ; }
3801: return CPPUnknown ;
3802: }
3803:
3804: std :: string simplecpp :: getCppStdString ( cppstd_t std )
3805: {
3806: switch ( std ) {
3807: case CPP03 : ;
3808: return "199711L" ;
3809: case CPP11 : ;
3810: return "201103L" ;
3811: case CPP14 : ;
3812: return "201402L" ;
3813: case CPP17 : ;
3814: return "201703L" ;
3815: case CPP20 : ;
3816:
3817: return "202002L" ;
3818: case CPP23 : ;
3819:
|
3822:
3823: return "202302L" ;
3824: case CPP26 : ;
3825:
3826: return "202400L" ;
3827: case CPPUnknown : ;
3828: return "" ;
3829: }
3830: return "" ;
3831: }
3832:
3833: std :: string simplecpp :: getCppStdString ( const std :: string & std )
3834: {
3835: return getCppStdString ( getCppStd ( std ) ) ;
3836: }


### Template Simplifier pass 1 ###

mTemplateDeclarations: 1
mTemplateDeclarations[0]:
    token: "template" [simplecpp-1.5.1/simplecpp.cpp:94]
    scope: ""
    name: "toString"
    fullName: "toString"
    nameToken: "toString" [simplecpp-1.5.1/simplecpp.cpp:94]
    paramEnd: ">" [simplecpp-1.5.1/simplecpp.cpp:94]
    flags:  isFunction
mTemplateForwardDeclarations: 0
mTemplateForwardDeclarationsMap: 0
mTemplateSpecializationMap: 0
mTemplatePartialSpecializationMap: 0
mTemplateInstantiations: 155
mTemplateInstantiations[0]:
    token: "vector" [simplecpp-1.5.1/simplecpp.h:65]
    scope: "std"
    name: "vector"
    fullName: "std :: vector"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <std::string>
mTemplateInstantiations[1]:
    token: "vector" [simplecpp-1.5.1/simplecpp.h:97]
    scope: "std"
    name: "vector"
    fullName: "std :: vector"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <std::string>
mTemplateInstantiations[2]:
    token: "set" [simplecpp-1.5.1/simplecpp.h:184]
    scope: "std"
    name: "set"
    fullName: "std :: set"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <constMacro*>
mTemplateInstantiations[3]:
    token: "vector" [simplecpp-1.5.1/simplecpp.h:192]
    scope: "std"
    name: "vector"
    fullName: "std :: vector"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <std::string>
mTemplateInstantiations[4]:
    token: "vector" [simplecpp-1.5.1/simplecpp.h:205]
    scope: "std"
    name: "vector"
    fullName: "std :: vector"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <std::string>
mTemplateInstantiations[5]:
    token: "vector" [simplecpp-1.5.1/simplecpp.h:217]
    scope: "std"
    name: "vector"
    fullName: "std :: vector"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <std::string>
mTemplateInstantiations[6]:
    token: "vector" [simplecpp-1.5.1/simplecpp.h:219]
    scope: "std"
    name: "vector"
    fullName: "std :: vector"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <std::string>
mTemplateInstantiations[7]:
    token: "list" [simplecpp-1.5.1/simplecpp.h:219]
    scope: "std"
    name: "list"
    fullName: "std :: list"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <Output>
mTemplateInstantiations[8]:
    token: "vector" [simplecpp-1.5.1/simplecpp.h:221]
    scope: "std"
    name: "vector"
    fullName: "std :: vector"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <std::string>
mTemplateInstantiations[9]:
    token: "list" [simplecpp-1.5.1/simplecpp.h:221]
    scope: "std"
    name: "list"
    fullName: "std :: list"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <Output>
mTemplateInstantiations[10]:
    token: "vector" [simplecpp-1.5.1/simplecpp.h:223]
    scope: "std"
    name: "vector"
    fullName: "std :: vector"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <std::string>
mTemplateInstantiations[11]:
    token: "list" [simplecpp-1.5.1/simplecpp.h:223]
    scope: "std"
    name: "list"
    fullName: "std :: list"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <Output>
mTemplateInstantiations[12]:
    token: "vector" [simplecpp-1.5.1/simplecpp.h:225]
    scope: "std"
    name: "vector"
    fullName: "std :: vector"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <std::string>
mTemplateInstantiations[13]:
    token: "list" [simplecpp-1.5.1/simplecpp.h:225]
    scope: "std"
    name: "list"
    fullName: "std :: list"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <Output>
mTemplateInstantiations[14]:
    token: "list" [simplecpp-1.5.1/simplecpp.h:241]
    scope: "std"
    name: "list"
    fullName: "std :: list"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <Output>
mTemplateInstantiations[15]:
    token: "map" [simplecpp-1.5.1/simplecpp.h:292]
    scope: "std"
    name: "map"
    fullName: "std :: map"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <std::string,unsignedlong>
mTemplateInstantiations[16]:
    token: "vector" [simplecpp-1.5.1/simplecpp.h:294]
    scope: "std"
    name: "vector"
    fullName: "std :: vector"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <std::string>
mTemplateInstantiations[17]:
    token: "list" [simplecpp-1.5.1/simplecpp.h:310]
    scope: "std"
    name: "list"
    fullName: "std :: list"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <Output>
mTemplateInstantiations[18]:
    token: "vector" [simplecpp-1.5.1/simplecpp.h:321]
    scope: "std"
    name: "vector"
    fullName: "std :: vector"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <std::string>
mTemplateInstantiations[19]:
    token: "vector" [simplecpp-1.5.1/simplecpp.h:326]
    scope: "std"
    name: "vector"
    fullName: "std :: vector"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <std::string>
mTemplateInstantiations[20]:
    token: "list" [simplecpp-1.5.1/simplecpp.h:347]
    scope: "std"
    name: "list"
    fullName: "std :: list"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <std::string>
mTemplateInstantiations[21]:
    token: "set" [simplecpp-1.5.1/simplecpp.h:348]
    scope: "std"
    name: "set"
    fullName: "std :: set"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <std::string>
mTemplateInstantiations[22]:
    token: "list" [simplecpp-1.5.1/simplecpp.h:349]
    scope: "std"
    name: "list"
    fullName: "std :: list"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <std::string>
mTemplateInstantiations[23]:
    token: "list" [simplecpp-1.5.1/simplecpp.h:350]
    scope: "std"
    name: "list"
    fullName: "std :: list"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <std::string>
mTemplateInstantiations[24]:
    token: "vector" [simplecpp-1.5.1/simplecpp.h:358]
    scope: "std"
    name: "vector"
    fullName: "std :: vector"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <std::string>
mTemplateInstantiations[25]:
    token: "list" [simplecpp-1.5.1/simplecpp.h:358]
    scope: "std"
    name: "list"
    fullName: "std :: list"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <Output>
mTemplateInstantiations[26]:
    token: "vector" [simplecpp-1.5.1/simplecpp.h:372]
    scope: "std"
    name: "vector"
    fullName: "std :: vector"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <std::string>
mTemplateInstantiations[27]:
    token: "list" [simplecpp-1.5.1/simplecpp.h:372]
    scope: "std"
    name: "list"
    fullName: "std :: list"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <Output>
mTemplateInstantiations[28]:
    token: "list" [simplecpp-1.5.1/simplecpp.h:372]
    scope: "std"
    name: "list"
    fullName: "std :: list"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <MacroUsage>
mTemplateInstantiations[29]:
    token: "list" [simplecpp-1.5.1/simplecpp.h:372]
    scope: "std"
    name: "list"
    fullName: "std :: list"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <IfCond>
mTemplateInstantiations[30]:
    token: "pair" [simplecpp-1.5.1/simplecpp.h:418]
    scope: "std"
    name: "pair"
    fullName: "std :: pair"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <FileData*,bool>
mTemplateInstantiations[31]:
    token: "vector" [simplecpp-1.5.1/simplecpp.h:418]
    scope: "std"
    name: "vector"
    fullName: "std :: vector"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <std::string>
mTemplateInstantiations[32]:
    token: "list" [simplecpp-1.5.1/simplecpp.h:418]
    scope: "std"
    name: "list"
    fullName: "std :: list"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <Output>
mTemplateInstantiations[33]:
    token: "vector" [simplecpp-1.5.1/simplecpp.h:438]
    scope: "std"
    name: "vector"
    fullName: "std :: vector"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <std::unique_ptr<FileData>>
mTemplateInstantiations[34]:
    token: "unique_ptr" [simplecpp-1.5.1/simplecpp.h:438]
    scope: "std"
    name: "unique_ptr"
    fullName: "std :: unique_ptr"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <FileData>
mTemplateInstantiations[35]:
    token: "vector" [simplecpp-1.5.1/simplecpp.h:441]
    scope: "std"
    name: "vector"
    fullName: "std :: vector"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <std::unique_ptr<FileData>>
mTemplateInstantiations[36]:
    token: "unique_ptr" [simplecpp-1.5.1/simplecpp.h:441]
    scope: "std"
    name: "unique_ptr"
    fullName: "std :: unique_ptr"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <FileData>
mTemplateInstantiations[37]:
    token: "vector" [simplecpp-1.5.1/simplecpp.h:444]
    scope: "std"
    name: "vector"
    fullName: "std :: vector"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <std::unique_ptr<FileData>>
mTemplateInstantiations[38]:
    token: "unique_ptr" [simplecpp-1.5.1/simplecpp.h:444]
    scope: "std"
    name: "unique_ptr"
    fullName: "std :: unique_ptr"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <FileData>
mTemplateInstantiations[39]:
    token: "vector" [simplecpp-1.5.1/simplecpp.h:447]
    scope: "std"
    name: "vector"
    fullName: "std :: vector"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <std::unique_ptr<FileData>>
mTemplateInstantiations[40]:
    token: "unique_ptr" [simplecpp-1.5.1/simplecpp.h:447]
    scope: "std"
    name: "unique_ptr"
    fullName: "std :: unique_ptr"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <FileData>
mTemplateInstantiations[41]:
    token: "vector" [simplecpp-1.5.1/simplecpp.h:450]
    scope: "std"
    name: "vector"
    fullName: "std :: vector"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <std::unique_ptr<FileData>>
mTemplateInstantiations[42]:
    token: "unique_ptr" [simplecpp-1.5.1/simplecpp.h:450]
    scope: "std"
    name: "unique_ptr"
    fullName: "std :: unique_ptr"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <FileData>
mTemplateInstantiations[43]:
    token: "vector" [simplecpp-1.5.1/simplecpp.h:453]
    scope: "std"
    name: "vector"
    fullName: "std :: vector"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <std::unique_ptr<FileData>>
mTemplateInstantiations[44]:
    token: "unique_ptr" [simplecpp-1.5.1/simplecpp.h:453]
    scope: "std"
    name: "unique_ptr"
    fullName: "std :: unique_ptr"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <FileData>
mTemplateInstantiations[45]:
    token: "vector" [simplecpp-1.5.1/simplecpp.h:456]
    scope: "std"
    name: "vector"
    fullName: "std :: vector"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <std::unique_ptr<FileData>>
mTemplateInstantiations[46]:
    token: "unique_ptr" [simplecpp-1.5.1/simplecpp.h:456]
    scope: "std"
    name: "unique_ptr"
    fullName: "std :: unique_ptr"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <FileData>
mTemplateInstantiations[47]:
    token: "pair" [simplecpp-1.5.1/simplecpp.h:501]
    scope: "std"
    name: "pair"
    fullName: "std :: pair"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <FileData*,bool>
mTemplateInstantiations[48]:
    token: "unordered_map" [simplecpp-1.5.1/simplecpp.h:501]
    scope: "std"
    name: "unordered_map"
    fullName: "std :: unordered_map"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <std::string,FileData*>
mTemplateInstantiations[49]:
    token: "vector" [simplecpp-1.5.1/simplecpp.h:501]
    scope: "std"
    name: "vector"
    fullName: "std :: vector"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <std::string>
mTemplateInstantiations[50]:
    token: "list" [simplecpp-1.5.1/simplecpp.h:501]
    scope: "std"
    name: "list"
    fullName: "std :: list"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <Output>
mTemplateInstantiations[51]:
    token: "vector" [simplecpp-1.5.1/simplecpp.h:503]
    scope: "std"
    name: "vector"
    fullName: "std :: vector"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <std::unique_ptr<FileData>>
mTemplateInstantiations[52]:
    token: "unique_ptr" [simplecpp-1.5.1/simplecpp.h:503]
    scope: "std"
    name: "unique_ptr"
    fullName: "std :: unique_ptr"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <FileData>
mTemplateInstantiations[53]:
    token: "unordered_map" [simplecpp-1.5.1/simplecpp.h:504]
    scope: "std"
    name: "unordered_map"
    fullName: "std :: unordered_map"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <std::string,FileData*>
mTemplateInstantiations[54]:
    token: "unordered_map" [simplecpp-1.5.1/simplecpp.h:505]
    scope: "std"
    name: "unordered_map"
    fullName: "std :: unordered_map"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <FileID,FileData*,FileID::Hasher>
mTemplateInstantiations[55]:
    token: "vector" [simplecpp-1.5.1/simplecpp.cpp:409]
    scope: "std"
    name: "vector"
    fullName: "std :: vector"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <std::string>
mTemplateInstantiations[56]:
    token: "vector" [simplecpp-1.5.1/simplecpp.cpp:460]
    scope: "std"
    name: "vector"
    fullName: "std :: vector"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <std::string>
mTemplateInstantiations[57]:
    token: "vector" [simplecpp-1.5.1/simplecpp.cpp:462]
    scope: "std"
    name: "vector"
    fullName: "std :: vector"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <std::string>
mTemplateInstantiations[58]:
    token: "list" [simplecpp-1.5.1/simplecpp.cpp:462]
    scope: "std"
    name: "list"
    fullName: "std :: list"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <Output>
mTemplateInstantiations[59]:
    token: "vector" [simplecpp-1.5.1/simplecpp.cpp:469]
    scope: "std"
    name: "vector"
    fullName: "std :: vector"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <std::string>
mTemplateInstantiations[60]:
    token: "list" [simplecpp-1.5.1/simplecpp.cpp:469]
    scope: "std"
    name: "list"
    fullName: "std :: list"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <Output>
mTemplateInstantiations[61]:
    token: "vector" [simplecpp-1.5.1/simplecpp.cpp:476]
    scope: "std"
    name: "vector"
    fullName: "std :: vector"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <std::string>
mTemplateInstantiations[62]:
    token: "list" [simplecpp-1.5.1/simplecpp.cpp:476]
    scope: "std"
    name: "list"
    fullName: "std :: list"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <Output>
mTemplateInstantiations[63]:
    token: "vector" [simplecpp-1.5.1/simplecpp.cpp:483]
    scope: "std"
    name: "vector"
    fullName: "std :: vector"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <std::string>
mTemplateInstantiations[64]:
    token: "list" [simplecpp-1.5.1/simplecpp.cpp:483]
    scope: "std"
    name: "list"
    fullName: "std :: list"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <Output>
mTemplateInstantiations[65]:
    token: "list" [simplecpp-1.5.1/simplecpp.cpp:606]
    scope: "std"
    name: "list"
    fullName: "std :: list"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <Output>
mTemplateInstantiations[66]:
    token: "vector" [simplecpp-1.5.1/simplecpp.cpp:606]
    scope: "std"
    name: "vector"
    fullName: "std :: vector"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <std::string>
mTemplateInstantiations[67]:
    token: "list" [simplecpp-1.5.1/simplecpp.cpp:642]
    scope: "std"
    name: "list"
    fullName: "std :: list"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <Output>
mTemplateInstantiations[68]:
    token: "stack" [simplecpp-1.5.1/simplecpp.cpp:644]
    scope: "std"
    name: "stack"
    fullName: "std :: stack"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <simplecpp::Location>
mTemplateInstantiations[69]:
    token: "stack" [simplecpp-1.5.1/simplecpp.cpp:975]
    scope: "std"
    name: "stack"
    fullName: "std :: stack"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <bool>
mTemplateInstantiations[70]:
    token: "list" [simplecpp-1.5.1/simplecpp.cpp:1359]
    scope: "std"
    name: "list"
    fullName: "std :: list"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <Output>
mTemplateInstantiations[71]:
    token: "vector" [simplecpp-1.5.1/simplecpp.cpp:1475]
    scope: "std"
    name: "vector"
    fullName: "std :: vector"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <std::string>
mTemplateInstantiations[72]:
    token: "vector" [simplecpp-1.5.1/simplecpp.cpp:1477]
    scope: "std"
    name: "vector"
    fullName: "std :: vector"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <std::string>
mTemplateInstantiations[73]:
    token: "vector" [simplecpp-1.5.1/simplecpp.cpp:1493]
    scope: "std"
    name: "vector"
    fullName: "std :: vector"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <std::string>
mTemplateInstantiations[74]:
    token: "unordered_map" [simplecpp-1.5.1/simplecpp.cpp:1540]
    scope: "std"
    name: "unordered_map"
    fullName: "std :: unordered_map"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <std::string,Macro>
mTemplateInstantiations[75]:
    token: "vector" [simplecpp-1.5.1/simplecpp.cpp:1541]
    scope: "std"
    name: "vector"
    fullName: "std :: vector"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <std::string>
mTemplateInstantiations[76]:
    token: "set" [simplecpp-1.5.1/simplecpp.cpp:1542]
    scope: "std"
    name: "set"
    fullName: "std :: set"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <std::string>
mTemplateInstantiations[77]:
    token: "list" [simplecpp-1.5.1/simplecpp.cpp:1639]
    scope: "std"
    name: "list"
    fullName: "std :: list"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <Location>
mTemplateInstantiations[78]:
    token: "vector" [simplecpp-1.5.1/simplecpp.cpp:1798]
    scope: "std"
    name: "vector"
    fullName: "std :: vector"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <constToken*>
mTemplateInstantiations[79]:
    token: "vector" [simplecpp-1.5.1/simplecpp.cpp:1800]
    scope: "std"
    name: "vector"
    fullName: "std :: vector"
    nameToken: nullptr
    paramEnd: nullptr
    flags:  isFunction
    type: <constToken*>
mTemplateInstantiations[80]:
    token: "vector" [simplecpp-1.5.1/simplecpp.cpp:1802]
    scope: "std"
    name: "vector"
    fullName: "std :: vector"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <constToken*>
mTemplateInstantiations[81]:
    token: "unordered_map" [simplecpp-1.5.1/simplecpp.cpp:1823]
    scope: "std"
    name: "unordered_map"
    fullName: "std :: unordered_map"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <std::string,Macro>
mTemplateInstantiations[82]:
    token: "set" [simplecpp-1.5.1/simplecpp.cpp:1824]
    scope: "std"
    name: "set"
    fullName: "std :: set"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <std::string>
mTemplateInstantiations[83]:
    token: "vector" [simplecpp-1.5.1/simplecpp.cpp:1825]
    scope: "std"
    name: "vector"
    fullName: "std :: vector"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <constToken*>
mTemplateInstantiations[84]:
    token: "unordered_map" [simplecpp-1.5.1/simplecpp.cpp:1858]
    scope: "std"
    name: "unordered_map"
    fullName: "std :: unordered_map"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <std::string,Macro>
mTemplateInstantiations[85]:
    token: "set" [simplecpp-1.5.1/simplecpp.cpp:1858]
    scope: "std"
    name: "set"
    fullName: "std :: set"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <std::string>
mTemplateInstantiations[86]:
    token: "vector" [simplecpp-1.5.1/simplecpp.cpp:1883]
    scope: "std"
    name: "vector"
    fullName: "std :: vector"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <constToken*>
mTemplateInstantiations[87]:
    token: "vector" [simplecpp-1.5.1/simplecpp.cpp:1905]
    scope: "std"
    name: "vector"
    fullName: "std :: vector"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <constToken*>
mTemplateInstantiations[88]:
    token: "unordered_map" [simplecpp-1.5.1/simplecpp.cpp:2028]
    scope: "std"
    name: "unordered_map"
    fullName: "std :: unordered_map"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <std::string,Macro>
mTemplateInstantiations[89]:
    token: "set" [simplecpp-1.5.1/simplecpp.cpp:2028]
    scope: "std"
    name: "set"
    fullName: "std :: set"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <std::string>
mTemplateInstantiations[90]:
    token: "vector" [simplecpp-1.5.1/simplecpp.cpp:2028]
    scope: "std"
    name: "vector"
    fullName: "std :: vector"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <constToken*>
mTemplateInstantiations[91]:
    token: "unordered_map" [simplecpp-1.5.1/simplecpp.cpp:2039]
    scope: "std"
    name: "unordered_map"
    fullName: "std :: unordered_map"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <std::string,Macro>
mTemplateInstantiations[92]:
    token: "unordered_map" [simplecpp-1.5.1/simplecpp.cpp:2063]
    scope: "std"
    name: "unordered_map"
    fullName: "std :: unordered_map"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <std::string,Macro>
mTemplateInstantiations[93]:
    token: "set" [simplecpp-1.5.1/simplecpp.cpp:2063]
    scope: "std"
    name: "set"
    fullName: "std :: set"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <std::string>
mTemplateInstantiations[94]:
    token: "vector" [simplecpp-1.5.1/simplecpp.cpp:2063]
    scope: "std"
    name: "vector"
    fullName: "std :: vector"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <constToken*>
mTemplateInstantiations[95]:
    token: "unordered_map" [simplecpp-1.5.1/simplecpp.cpp:2082]
    scope: "std"
    name: "unordered_map"
    fullName: "std :: unordered_map"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <std::string,Macro>
mTemplateInstantiations[96]:
    token: "set" [simplecpp-1.5.1/simplecpp.cpp:2084]
    scope: "std"
    name: "set"
    fullName: "std :: set"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <std::string>
mTemplateInstantiations[97]:
    token: "vector" [simplecpp-1.5.1/simplecpp.cpp:2150]
    scope: "std"
    name: "vector"
    fullName: "std :: vector"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <constToken*>
mTemplateInstantiations[98]:
    token: "unordered_map" [simplecpp-1.5.1/simplecpp.cpp:2168]
    scope: "std"
    name: "unordered_map"
    fullName: "std :: unordered_map"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <std::string,Macro>
mTemplateInstantiations[99]:
    token: "set" [simplecpp-1.5.1/simplecpp.cpp:2168]
    scope: "std"
    name: "set"
    fullName: "std :: set"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <std::string>
mTemplateInstantiations[100]:
    token: "vector" [simplecpp-1.5.1/simplecpp.cpp:2168]
    scope: "std"
    name: "vector"
    fullName: "std :: vector"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <constToken*>
mTemplateInstantiations[101]:
    token: "set" [simplecpp-1.5.1/simplecpp.cpp:2179]
    scope: "std"
    name: "set"
    fullName: "std :: set"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <std::string>
mTemplateInstantiations[102]:
    token: "set" [simplecpp-1.5.1/simplecpp.cpp:2202]
    scope: "std"
    name: "set"
    fullName: "std :: set"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <std::string>
mTemplateInstantiations[103]:
    token: "vector" [simplecpp-1.5.1/simplecpp.cpp:2202]
    scope: "std"
    name: "vector"
    fullName: "std :: vector"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <constToken*>
mTemplateInstantiations[104]:
    token: "unordered_map" [simplecpp-1.5.1/simplecpp.cpp:2204]
    scope: "std"
    name: "unordered_map"
    fullName: "std :: unordered_map"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <std::string,Macro>
mTemplateInstantiations[105]:
    token: "unordered_map" [simplecpp-1.5.1/simplecpp.cpp:2231]
    scope: "std"
    name: "unordered_map"
    fullName: "std :: unordered_map"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <std::string,Macro>
mTemplateInstantiations[106]:
    token: "set" [simplecpp-1.5.1/simplecpp.cpp:2231]
    scope: "std"
    name: "set"
    fullName: "std :: set"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <std::string>
mTemplateInstantiations[107]:
    token: "vector" [simplecpp-1.5.1/simplecpp.cpp:2231]
    scope: "std"
    name: "vector"
    fullName: "std :: vector"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <constToken*>
mTemplateInstantiations[108]:
    token: "set" [simplecpp-1.5.1/simplecpp.cpp:2340]
    scope: "std"
    name: "set"
    fullName: "std :: set"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <std::string>
mTemplateInstantiations[109]:
    token: "set" [simplecpp-1.5.1/simplecpp.cpp:2342]
    scope: "std"
    name: "set"
    fullName: "std :: set"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <std::string>
mTemplateInstantiations[110]:
    token: "vector" [simplecpp-1.5.1/simplecpp.cpp:2353]
    scope: "std"
    name: "vector"
    fullName: "std :: vector"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <std::string>
mTemplateInstantiations[111]:
    token: "vector" [simplecpp-1.5.1/simplecpp.cpp:2362]
    scope: "std"
    name: "vector"
    fullName: "std :: vector"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <std::string>
mTemplateInstantiations[112]:
    token: "list" [simplecpp-1.5.1/simplecpp.cpp:2368]
    scope: "std"
    name: "list"
    fullName: "std :: list"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <Location>
mTemplateInstantiations[113]:
    token: "map" [simplecpp-1.5.1/simplecpp.cpp:2510]
    scope: "std"
    name: "map"
    fullName: "std :: map"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <std::string,unsignedlong>
mTemplateInstantiations[114]:
    token: "map" [simplecpp-1.5.1/simplecpp.cpp:2544]
    scope: "std"
    name: "map"
    fullName: "std :: map"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <std::string,unsignedlong>
mTemplateInstantiations[115]:
    token: "set" [simplecpp-1.5.1/simplecpp.cpp:2634]
    scope: "std"
    name: "set"
    fullName: "std :: set"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <std::string>
mTemplateInstantiations[116]:
    token: "numeric_limits" [simplecpp-1.5.1/simplecpp.cpp:2876]
    scope: "std"
    name: "numeric_limits"
    fullName: "std :: numeric_limits"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <unsignedchar>
mTemplateInstantiations[117]:
    token: "map" [simplecpp-1.5.1/simplecpp.cpp:2925]
    scope: "std"
    name: "map"
    fullName: "std :: map"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <std::string,unsignedlong>
mTemplateInstantiations[118]:
    token: "pair" [simplecpp-1.5.1/simplecpp.cpp:3013]
    scope: "std"
    name: "pair"
    fullName: "std :: pair"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <simplecpp::FileData*,bool>
mTemplateInstantiations[119]:
    token: "unordered_map" [simplecpp-1.5.1/simplecpp.cpp:3013]
    scope: "std"
    name: "unordered_map"
    fullName: "std :: unordered_map"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <std::string,FileData*>
mTemplateInstantiations[120]:
    token: "vector" [simplecpp-1.5.1/simplecpp.cpp:3013]
    scope: "std"
    name: "vector"
    fullName: "std :: vector"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <std::string>
mTemplateInstantiations[121]:
    token: "list" [simplecpp-1.5.1/simplecpp.cpp:3013]
    scope: "std"
    name: "list"
    fullName: "std :: list"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <Output>
mTemplateInstantiations[122]:
    token: "pair" [simplecpp-1.5.1/simplecpp.cpp:3040]
    scope: "std"
    name: "pair"
    fullName: "std :: pair"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <simplecpp::FileData*,bool>
mTemplateInstantiations[123]:
    token: "vector" [simplecpp-1.5.1/simplecpp.cpp:3040]
    scope: "std"
    name: "vector"
    fullName: "std :: vector"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <std::string>
mTemplateInstantiations[124]:
    token: "list" [simplecpp-1.5.1/simplecpp.cpp:3040]
    scope: "std"
    name: "list"
    fullName: "std :: list"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <Output>
mTemplateInstantiations[125]:
    token: "vector" [simplecpp-1.5.1/simplecpp.cpp:3112]
    scope: "std"
    name: "vector"
    fullName: "std :: vector"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <std::string>
mTemplateInstantiations[126]:
    token: "list" [simplecpp-1.5.1/simplecpp.cpp:3112]
    scope: "std"
    name: "list"
    fullName: "std :: list"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <Output>
mTemplateInstantiations[127]:
    token: "list" [simplecpp-1.5.1/simplecpp.cpp:3121]
    scope: "std"
    name: "list"
    fullName: "std :: list"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <constToken*>
mTemplateInstantiations[128]:
    token: "list" [simplecpp-1.5.1/simplecpp.cpp:3124]
    scope: "std"
    name: "list"
    fullName: "std :: list"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <std::string>
mTemplateInstantiations[129]:
    token: "unordered_map" [simplecpp-1.5.1/simplecpp.cpp:3190]
    scope: "std"
    name: "unordered_map"
    fullName: "std :: unordered_map"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <std::string,Macro>
mTemplateInstantiations[130]:
    token: "vector" [simplecpp-1.5.1/simplecpp.cpp:3190]
    scope: "std"
    name: "vector"
    fullName: "std :: vector"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <std::string>
mTemplateInstantiations[131]:
    token: "list" [simplecpp-1.5.1/simplecpp.cpp:3190]
    scope: "std"
    name: "list"
    fullName: "std :: list"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <Output>
mTemplateInstantiations[132]:
    token: "unordered_map" [simplecpp-1.5.1/simplecpp.cpp:3193]
    scope: "std"
    name: "unordered_map"
    fullName: "std :: unordered_map"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <std::string,Macro>
mTemplateInstantiations[133]:
    token: "vector" [simplecpp-1.5.1/simplecpp.cpp:3243]
    scope: "std"
    name: "vector"
    fullName: "std :: vector"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <std::string>
mTemplateInstantiations[134]:
    token: "list" [simplecpp-1.5.1/simplecpp.cpp:3243]
    scope: "std"
    name: "list"
    fullName: "std :: list"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <Output>
mTemplateInstantiations[135]:
    token: "list" [simplecpp-1.5.1/simplecpp.cpp:3243]
    scope: "std"
    name: "list"
    fullName: "std :: list"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <simplecpp::MacroUsage>
mTemplateInstantiations[136]:
    token: "list" [simplecpp-1.5.1/simplecpp.cpp:3243]
    scope: "std"
    name: "list"
    fullName: "std :: list"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <simplecpp::IfCond>
mTemplateInstantiations[137]:
    token: "map" [simplecpp-1.5.1/simplecpp.cpp:3250]
    scope: "std"
    name: "map"
    fullName: "std :: map"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <std::string,unsignedlong>
mTemplateInstantiations[138]:
    token: "vector" [simplecpp-1.5.1/simplecpp.cpp:3273]
    scope: "std"
    name: "vector"
    fullName: "std :: vector"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <std::string>
mTemplateInstantiations[139]:
    token: "unordered_map" [simplecpp-1.5.1/simplecpp.cpp:3276]
    scope: "std"
    name: "unordered_map"
    fullName: "std :: unordered_map"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <std::string,Macro>
mTemplateInstantiations[140]:
    token: "list" [simplecpp-1.5.1/simplecpp.cpp:3278]
    scope: "std"
    name: "list"
    fullName: "std :: list"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <std::string>
mTemplateInstantiations[141]:
    token: "pair" [simplecpp-1.5.1/simplecpp.cpp:3290]
    scope: "std"
    name: "pair"
    fullName: "std :: pair"
    nameToken: nullptr
    paramEnd: nullptr
    flags:  isFunction
    type: <std::string,Macro>
mTemplateInstantiations[142]:
    token: "pair" [simplecpp-1.5.1/simplecpp.cpp:3295]
    scope: "std"
    name: "pair"
    fullName: "std :: pair"
    nameToken: nullptr
    paramEnd: nullptr
    flags:  isFunction
    type: <std::string,Macro>
mTemplateInstantiations[143]:
    token: "stack" [simplecpp-1.5.1/simplecpp.cpp:3333]
    scope: "std"
    name: "stack"
    fullName: "std :: stack"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <int>
mTemplateInstantiations[144]:
    token: "stack" [simplecpp-1.5.1/simplecpp.cpp:3334]
    scope: "std"
    name: "stack"
    fullName: "std :: stack"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <constToken*>
mTemplateInstantiations[145]:
    token: "stack" [simplecpp-1.5.1/simplecpp.cpp:3337]
    scope: "std"
    name: "stack"
    fullName: "std :: stack"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <constToken*>
mTemplateInstantiations[146]:
    token: "set" [simplecpp-1.5.1/simplecpp.cpp:3339]
    scope: "std"
    name: "set"
    fullName: "std :: set"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <std::string>
mTemplateInstantiations[147]:
    token: "list" [simplecpp-1.5.1/simplecpp.cpp:3342]
    scope: "std"
    name: "list"
    fullName: "std :: list"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <std::string>
mTemplateInstantiations[148]:
    token: "map" [simplecpp-1.5.1/simplecpp.cpp:3348]
    scope: "std"
    name: "map"
    fullName: "std :: map"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <std::string,std::list<Location>>
mTemplateInstantiations[149]:
    token: "list" [simplecpp-1.5.1/simplecpp.cpp:3348]
    scope: "std"
    name: "list"
    fullName: "std :: list"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <Location>
mTemplateInstantiations[150]:
    token: "pair" [simplecpp-1.5.1/simplecpp.cpp:3407]
    scope: "std"
    name: "pair"
    fullName: "std :: pair"
    nameToken: nullptr
    paramEnd: nullptr
    flags:  isFunction
    type: <std::string,Macro>
mTemplateInstantiations[151]:
    token: "unordered_map" [simplecpp-1.5.1/simplecpp.cpp:3720]
    scope: "std"
    name: "unordered_map"
    fullName: "std :: unordered_map"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <std::string,Macro>
mTemplateInstantiations[152]:
    token: "list" [simplecpp-1.5.1/simplecpp.cpp:3722]
    scope: "std"
    name: "list"
    fullName: "std :: list"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <Location>
mTemplateInstantiations[153]:
    token: "list" [simplecpp-1.5.1/simplecpp.cpp:3723]
    scope: "std"
    name: "list"
    fullName: "std :: list"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <Location>
mTemplateInstantiations[154]:
    token: "list" [simplecpp-1.5.1/simplecpp.cpp:3725]
    scope: "std"
    name: "list"
    fullName: "std :: list"
    nameToken: nullptr
    paramEnd: nullptr
    flags: 
    type: <Location>


##file simplecpp-1.5.1/simplecpp.h

1:
|
48:
49: namespace simplecpp {
50:
51: enum cstd_t { CUnknown = -1 , C89 , C99 , C11 , C17 , C23 } ;
52:
53:
54: enum cppstd_t { CPPUnknown = -1 , CPP03 , CPP11 , CPP14 , CPP17 , CPP20 , CPP23 , CPP26 } ;
55:
56:
57: class Macro ;
58: class FileDataCache ;
59:
|
62:
63: class Location {
64: public:
65: explicit Location ( const std :: vector < std :: string > & f@var1 ) : files@var19 ( f@var1 ) , fileIndex@var20 ( 0 ) , line@var21 ( 1U ) , col@var22 ( 0U ) { }
66:
67: Location ( const Location & loc@var2 ) : files@var19 ( loc@var2 . files@var3 ) , fileIndex@var20 ( loc@var2 . fileIndex@var4 ) , line@var21 ( loc@var2 . line@var5 ) , col@var22 ( loc@var2 . col@var6 ) { }
68:
69: Location & operator= ( const Location & other@var7 ) {
70: if ( this !=@exprUNIQUE &@exprUNIQUE other@var7 ) {
71: fileIndex@var20 =@exprUNIQUE other@var7 .@exprUNIQUE fileIndex@var8 ;
72: line@var21 =@exprUNIQUE other@var7 .@exprUNIQUE line@var9 ;
73: col@var22 =@exprUNIQUE other@var7 .@exprUNIQUE col@var10 ;
74: }
75: return *@exprUNIQUE this ;
76: }
77:
78:
79: void adjust ( const std :: string & str@var11 ) ;
80:
81: bool operator< ( const Location & rhs@var12 ) const {
82: if ( fileIndex@var20 !=@exprUNIQUE rhs@var12 .@expr1350 fileIndex@var13 ) {
83: return fileIndex@var20 <@exprUNIQUE rhs@var12 .@expr1350 fileIndex@var13 ; }
84: if ( line@var21 !=@exprUNIQUE rhs@var12 .@expr1353 line@var14 ) {
85: return line@var21 <@exprUNIQUE rhs@var12 .@expr1353 line@var14 ; }
86: return col@var22 <@exprUNIQUE rhs@var12 .@exprUNIQUE col@var15 ;
87: }
88:
89: bool sameline ( const Location & other@var16 ) const {
90: return fileIndex@var20 ==@exprUNIQUE other@var16 .@exprUNIQUE fileIndex@var17 &&@exprUNIQUE line@var21 ==@exprUNIQUE other@var16 .@exprUNIQUE line@var18 ;
91: }
92:
93: const std :: string & file ( ) const {
94: return fileIndex@var20 <@exprUNIQUE files@var19 .@exprUNIQUE size (@exprUNIQUE ) ?@exprUNIQUE files@var19 [@exprUNIQUE fileIndex@var20 ] :@exprUNIQUE emptyFileName@var23 ;
95: }
96:
97: const std :: vector < std :: string > & files@var19 ;
98: unsigned int fileIndex@var20 ;
99: unsigned int line@var21 ;
100: unsigned int col@var22 ;
101: private:
102: static const std :: string emptyFileName@var23 ;
103: } ;
104:
|
108:
109: class Token {
110: public:
111: Token ( const std :: string & s@var24 , const Location & loc@var25 , bool wsahead@var26 = false ) :
112: whitespaceahead@var47 ( wsahead@var26 ) , location@var48 ( loc@var25 ) , previous@var49 ( nullptr ) , next@var50 ( nullptr ) , nextcond@var51 ( nullptr ) , string@var63 ( s@var24 ) {
113: flags (@exprUNIQUE ) ;
114: }
115:
116: Token ( const Token & tok@var27 ) :
117: macro@var42 ( tok@var27 . macro@var28 ) , op@var43 ( tok@var27 . op@var29 ) , comment@var44 ( tok@var27 . comment@var30 ) , name@var45 ( tok@var27 . name@var31 ) , number@var46 ( tok@var27 . number@var32 ) , whitespaceahead@var47 ( tok@var27 . whitespaceahead@var33 ) , location@var48 ( tok@var27 . location@var34 ) , previous@var49 ( nullptr ) , next@var50 ( nullptr ) , nextcond@var51 ( nullptr ) , string@var63 ( tok@var27 . string@var35 ) , mExpandedFrom@var64 ( tok@var27 . mExpandedFrom@var36 ) {
118: }
119:
120: void flags ( ) {
121: name@var45 =@exprUNIQUE ( std ::@exprUNIQUE isalpha (@exprUNIQUE static_cast < unsigned char > (@exprUNIQUE string@var63 [@expr1377 0 ] ) ) ||@exprUNIQUE string@var63 [@expr1377 0 ] ==@exprUNIQUE '_'@exprUNIQUE ||@exprUNIQUE string@var63 [@expr1377 0 ] ==@exprUNIQUE '$'@exprUNIQUE )
122: &&@exprUNIQUE ( std ::@exprUNIQUE memchr (@exprUNIQUE string@var63 .@exprUNIQUE c_str (@exprUNIQUE ) ,@exprUNIQUE '\''@exprUNIQUE ,@exprUNIQUE string@var63 .@expr1394 size (@expr1395 ) ) ==@exprUNIQUE nullptr ) ;
123: comment@var44 =@exprUNIQUE string@var63 .@expr1394 size (@expr1395 ) >@exprUNIQUE 1U &&@exprUNIQUE string@var63 [@expr1377 0 ] ==@exprUNIQUE '/'@expr1404 &&@exprUNIQUE ( string@var63 [@expr1408 1 ] ==@exprUNIQUE '/'@expr1404 ||@exprUNIQUE string@var63 [@expr1408 1 ] ==@exprUNIQUE '*'@exprUNIQUE ) ;
124: number@var46 =@exprUNIQUE isNumberLike (@exprUNIQUE string@var63 ) ;
125: op@var43 =@exprUNIQUE ( string@var63 .@expr1394 size (@expr1395 ) ==@exprUNIQUE 1U &&@exprUNIQUE !@exprUNIQUE name@var45 &&@exprUNIQUE !@exprUNIQUE comment@var44 &&@exprUNIQUE !@exprUNIQUE number@var46 ) ?@exprUNIQUE string@var63 [@expr1377 0 ] :@exprUNIQUE '\0'@exprUNIQUE ;
126: }
127:
128: const std :: string & str ( ) const {
129: return string@var63 ;
130: }
131: void setstr ( const std :: string & s@var37 ) {
132: string@var63 =@exprUNIQUE s@var37 ;
133: flags (@exprUNIQUE ) ;
134: }
135:
136: bool isOneOf ( const char ops@var38 [ ] ) const ;
137: bool startsWithOneOf ( const char c@var39 [ ] ) const ;
138: bool endsWithOneOf ( const char c@var40 [ ] ) const ;
139: static bool isNumberLike ( const std :: string & str@var41 ) {
140: return std ::@expr1434 isdigit (@exprUNIQUE static_cast < unsigned char > (@exprUNIQUE str@var41 [@expr1437 0 ] ) ) ||@exprUNIQUE
141: ( str@var41 .@exprUNIQUE size (@exprUNIQUE ) >@exprUNIQUE 1U &&@exprUNIQUE ( str@var41 [@expr1437 0 ] ==@exprUNIQUE '-'@exprUNIQUE ||@exprUNIQUE str@var41 [@expr1437 0 ] ==@exprUNIQUE '+'@exprUNIQUE ) &&@exprUNIQUE std ::@expr1434 isdigit (@exprUNIQUE static_cast < unsigned char > (@exprUNIQUE str@var41 [@exprUNIQUE 1 ] ) ) ) ;
142: }
143:
144: std :: string macro@var42 ;
145: char op@var43 ;
146: bool comment@var44 ;
147: bool name@var45 ;
148: bool number@var46 ;
149: bool whitespaceahead@var47 ;
150: Location location@var48 ;
151: Token * previous@var49 ;
152: Token * next@var50 ;
153: const mutable Token * nextcond@var51 ;
154:
155: const Token * previousSkipComments ( ) const {
156: const Token * tok@var52 ; tok@var52 =@exprUNIQUE this .@exprUNIQUE previous@var49 ;
157: while ( tok@var52 &&@exprUNIQUE tok@var52 .@exprUNIQUE comment@var53 ) {
158: tok@var52 =@exprUNIQUE tok@var52 .@exprUNIQUE previous@var54 ; }
159: return tok@var52 ;
160: }
161:
162: const Token * nextSkipComments ( ) const {
163: const Token * tok@var55 ; tok@var55 =@exprUNIQUE this .@exprUNIQUE next@var50 ;
164: while ( tok@var55 &&@exprUNIQUE tok@var55 .@exprUNIQUE comment@var56 ) {
165: tok@var55 =@exprUNIQUE tok@var55 .@exprUNIQUE next@var57 ; }
166: return tok@var55 ;
167: }
168:
169: void setExpandedFrom ( const Token * tok@var58 , const Macro * m@var59 ) {
170: mExpandedFrom@var64 =@exprUNIQUE tok@var58 .@exprUNIQUE mExpandedFrom@var60 ;
171: mExpandedFrom@var64 .@exprUNIQUE insert (@exprUNIQUE m@var59 ) ;
172: if ( tok@var58 .@exprUNIQUE whitespaceahead@var61 ) {
173: whitespaceahead@var47 = true ; }
174: }
175: bool isExpandedFrom ( const Macro * m@var62 ) const {
176: return mExpandedFrom@var64 .@exprUNIQUE find (@exprUNIQUE m@var62 ) !=@exprUNIQUE mExpandedFrom@var64 .@exprUNIQUE end (@exprUNIQUE ) ;
177: }
178:
179: void printAll ( ) const ;
180: void printOut ( ) const ;
181: private:
182: std :: string string@var63 ;
183:
184: std :: set < const Macro * > mExpandedFrom@var64 ;
185:
186:
187: Token & operator= ( const Token & tok@var65 ) ;
188: } ;
189:
190:
191: struct Output {
192: explicit Output ( const std :: vector < std :: string > & files@var66 ) : type@var67 ( ERROR ) , location@var71 ( files@var66 ) { }
193: enum Type {
194: ERROR ,
195: WARNING ,
196: MISSING_HEADER ,
197: INCLUDE_NESTED_TOO_DEEPLY ,
198: SYNTAX_ERROR ,
199: PORTABILITY_BACKSLASH ,
200: UNHANDLED_CHAR_ERROR ,
201: EXPLICIT_INCLUDE_NOT_FOUND ,
202: FILE_NOT_FOUND ,
203: DUI_ERROR
204: } ; enum Type type@var67 ;
205: explicit Output ( const std :: vector < std :: string > & files@var68 , Type type@var69 , const std :: string & msg@var70 ) : type@var67 ( type@var69 ) , location@var71 ( files@var68 ) , msg@var72 ( msg@var70 ) { }
206: Location location@var71 ;
207: std :: string msg@var72 ;
208: } ;
209:
|
212:
213: class TokenList {
214: public:
215: class Stream ;
216:
217: explicit TokenList ( std :: vector < std :: string > & filenames@var73 ) ;
218:
219: TokenList ( std :: istream & istr@var74 , std :: vector < std :: string > & filenames@var75 , const std :: string & filename@var76 = std :: string ( ) , std :: list < Output > * outputList@var77 = nullptr ) ;
220:
221: TokenList ( const unsigned char * data@var78 , unsigned long size@var79 , std :: vector < std :: string > & filenames@var80 , const std :: string & filename@var81 = std :: string ( ) , std :: list < Output > * outputList@var82 = nullptr ) ;
222:
223: TokenList ( const char * data@var83 , unsigned long size@var84 , std :: vector < std :: string > & filenames@var85 , const std :: string & filename@var86 = std :: string ( ) , std :: list < Output > * outputList@var87 = nullptr ) ;
224:
225: TokenList ( const std :: string & filename@var88 , std :: vector < std :: string > & filenames@var89 , std :: list < Output > * outputList@var90 = nullptr ) ;
226: TokenList ( const TokenList & other@var91 ) ;
227: TokenList ( TokenList && other@var92 ) ;
228: ~ TokenList ( ) ;
229: TokenList & operator= ( const TokenList & other@var93 ) ;
230: TokenList & operator= ( TokenList && other@var94 ) ;
231:
232: void clear ( ) ;
233: bool empty ( ) const {
234: return !@exprUNIQUE frontToken@var131 ;
235: }
236: void push_back ( Token * tok@var95 ) ;
237:
238: void dump ( ) const ;
239: std :: string stringify ( ) const ;
240:
241: void readfile ( Stream & stream@var96 , const std :: string & filename@var97 = std :: string ( ) , std :: list < Output > * outputList@var98 = nullptr ) ;
242: void constFold ( ) ;
243:
244: void removeComments ( ) ;
245:
246: Token * front ( ) {
247: return frontToken@var131 ;
248: }
249:
250: const Token * cfront ( ) const {
251: return frontToken@var131 ;
252: }
253:
254: Token * back ( ) {
255: return backToken@var132 ;
256: }
257:
258: const Token * cback ( ) const {
259: return backToken@var132 ;
260: }
261:
262: void deleteToken ( Token * tok@var99 ) {
263: if ( !@exprUNIQUE tok@var99 ) {
264: return ; }
265: Token * const prev@var100 ; prev@var100 =@exprUNIQUE tok@var99 .@exprUNIQUE previous@var101 ;
266: Token * const next@var102 ; next@var102 =@exprUNIQUE tok@var99 .@exprUNIQUE next@var103 ;
267: if ( prev@var100 ) {
268: prev@var100 .@exprUNIQUE next@var104 =@exprUNIQUE next@var102 ; }
269: if ( next@var102 ) {
270: next@var102 .@exprUNIQUE previous@var105 =@exprUNIQUE prev@var100 ; }
271: if ( frontToken@var131 ==@exprUNIQUE tok@var99 ) {
272: frontToken@var131 =@exprUNIQUE next@var102 ; }
273: if ( backToken@var132 ==@exprUNIQUE tok@var99 ) {
274: backToken@var132 =@exprUNIQUE prev@var100 ; }
275: delete@exprUNIQUE tok@var99 ;
276: }
277:
278: void takeTokens ( TokenList & other@var106 ) {
279: if ( !@exprUNIQUE other@var106 .@expr1500 frontToken@var107 ) {
280: return ; }
281: if ( !@exprUNIQUE frontToken@var131 ) {
282: frontToken@var131 =@exprUNIQUE other@var106 .@expr1500 frontToken@var107 ;
283: } else {
284: backToken@var132 .@exprUNIQUE next@var134 =@exprUNIQUE other@var106 .@expr1500 frontToken@var107 ;
285: other@var106 .@expr1500 frontToken@var107 .@exprUNIQUE previous@var108 =@exprUNIQUE backToken@var132 ;
286: }
287: backToken@var132 =@exprUNIQUE other@var106 .@expr1508 backToken@var109 ;
288: other@var106 .@expr1500 frontToken@var107 =@exprUNIQUE other@var106 .@expr1508 backToken@var109 =@exprUNIQUE nullptr ;
289: }
290:
291:
292: std :: map < std :: string , unsigned long > sizeOfType@var110 ;
293:
294: const std :: vector < std :: string > & getFiles ( ) const {
295: return files@var133 ;
296: }
297:
298: private:
299: void combineOperators ( ) ;
300:
301: void constFoldUnaryNotPosNeg ( Token * tok@var111 ) ;
302: void constFoldMulDivRem ( Token * tok@var112 ) ;
303: void constFoldAddSub ( Token * tok@var113 ) ;
304: void constFoldShift ( Token * tok@var114 ) ;
305: void constFoldComparison ( Token * tok@var115 ) ;
306: void constFoldBitwise ( Token * tok@var116 ) ;
307: void constFoldLogicalOp ( Token * tok@var117 ) ;
308: void constFoldQuestionOp ( Token * * tok1@var118 ) ;
309:
310: std :: string readUntil ( Stream & stream@var119 , const Location & location@var120 , char start@var121 , char end@var122 , std :: list < Output > * outputList@var123 ) ;
311: void lineDirective ( unsigned int fileIndex@var124 , unsigned int line@var125 , Location * location@var126 ) ;
312:
313: std :: string lastLine ( int maxsize@var127 = 1000 ) const ;
314: const Token * lastLineTok ( int maxsize@var128 = 1000 ) const ;
315: bool isLastLinePreprocessor ( int maxsize@var129 = 1000 ) const ;
316:
317: unsigned int fileIndex ( const std :: string & filename@var130 ) ;
318:
319: Token * frontToken@var131 ;
320: Token * backToken@var132 ;
321: std :: vector < std :: string > & files@var133 ;
322: } ;
323:
324:
325: struct MacroUsage {
326: explicit MacroUsage ( const std :: vector < std :: string > & f@var135 , bool macroValueKnown_@var136 ) : macroLocation@var138 ( f@var135 ) , useLocation@var139 ( f@var135 ) , macroValueKnown@var140 ( macroValueKnown_@var136 ) { }
327: std :: string macroName@var137 ;
328: Location macroLocation@var138 ;
329: Location useLocation@var139 ;
330: bool macroValueKnown@var140 ;
331: } ;
332:
333:
334: struct IfCond {
335: explicit IfCond ( const Location & location@var141 , const std :: string & E@var142 , long long result@var143 ) : location@var144 ( location@var141 ) , E@var145 ( E@var142 ) , result@var146 ( result@var143 ) { }
336: Location location@var144 ;
337: std :: string E@var145 ;
338: long long result@var146 ;
339: } ;
340:
|
344:
345: struct DUI {
346: DUI ( ) : clearIncludeCache@var152 ( false ) , removeComments@var153 ( false ) { }
347: std :: list < std :: string > defines@var147 ;
348: std :: set < std :: string > undefined@var148 ;
349: std :: list < std :: string > includePaths@var149 ;
350: std :: list < std :: string > includes@var150 ;
351: std :: string std@var151 ;
352: bool clearIncludeCache@var152 ;
353: bool removeComments@var153 ;
354: } ;
355:
356: long long characterLiteralToLL ( const std :: string & str@var154 ) ;
357:
358: FileDataCache load ( const TokenList & rawtokens@var155 , std :: vector < std :: string > & filenames@var156 , const DUI & dui@var157 , std :: list < Output > * outputList@var158 = nullptr ) ;
359:
|
371:
372: void preprocess ( TokenList & output@var159 , const TokenList & rawtokens@var160 , std :: vector < std :: string > & files@var161 , FileDataCache & cache@var162 , const DUI & dui@var163 , std :: list < Output > * outputList@var164 = nullptr , std :: list < MacroUsage > * macroUsage@var165 = nullptr , std :: list < IfCond > * ifCond@var166 = nullptr ) ;
373:
|
376:
377: void cleanup ( FileDataCache & cache@var167 ) ;
378:
379:
380: std :: string simplifyPath ( std :: string path@var168 ) ;
381:
382:
383: std :: string convertCygwinToWindowsPath ( const std :: string & cygwinPath@var169 ) ;
384:
385:
386: cstd_t getCStd ( const std :: string & std@var170 ) ;
387:
388:
389: cppstd_t getCppStd ( const std :: string & std@var171 ) ;
390:
391:
392: std :: string getCStdString ( const std :: string & std@var172 ) ;
393: std :: string getCStdString ( cstd_t std@var173 ) ;
394:
395:
396: std :: string getCppStdString ( const std :: string & std@var174 ) ;
397: std :: string getCppStdString ( cppstd_t std@var175 ) ;
398:
399: struct FileData {
400:
401: std :: string filename@var176 ;
402:
403: TokenList tokens@var177 ;
404: } ;
405:
406: class FileDataCache {
407: public:
408: FileDataCache ( ) = default ;
409:
410: FileDataCache ( const FileDataCache & ) = delete ;
411: FileDataCache ( FileDataCache && ) = default ;
412:
413: FileDataCache & operator= ( const FileDataCache & ) = delete ;
414: FileDataCache & operator= ( FileDataCache && ) = default ;
415:
416:
417:
418: std :: pair < FileData * , bool > get ( const std :: string & sourcefile@var178 , const std :: string & header@var179 , const DUI & dui@var180 , bool systemheader@var181 , std :: vector < std :: string > & filenames@var182 , std :: list < Output > * outputList@var183 ) ;
419:
420: void insert ( FileData data@var184 ) {
421: FileData * const newdata@var185 ; newdata@var185 =@exprUNIQUE new@exprUNIQUE FileData (@exprUNIQUE std ::@exprUNIQUE move (@exprUNIQUE data@var184 ) ) ;
422:
423: mData@var201 .@exprUNIQUE emplace_back (@exprUNIQUE newdata@var185 ) ;
424: mNameMap@var202 .@exprUNIQUE emplace (@exprUNIQUE newdata@var185 .@exprUNIQUE filename@var186 ,@exprUNIQUE newdata@var185 ) ;
425: }
426:
427: void clear ( ) {
428: mNameMap@var202 .@exprUNIQUE clear (@exprUNIQUE ) ;
429: mIdMap@var203 .@exprUNIQUE clear (@exprUNIQUE ) ;
430: mData@var201 .@exprUNIQUE clear (@exprUNIQUE ) ;
431: }
432:
|
437:
438: std :: vector < std :: unique_ptr < FileData > > :: size_type size ( ) const {
439: return mData@var201 .@exprUNIQUE size (@exprUNIQUE ) ;
440: }
441: std :: vector < std :: unique_ptr < FileData > > :: iterator begin ( ) {
442: return mData@var201 .@exprUNIQUE begin (@exprUNIQUE ) ;
443: }
444: std :: vector < std :: unique_ptr < FileData > > :: iterator end ( ) {
445: return mData@var201 .@exprUNIQUE end (@exprUNIQUE ) ;
446: }
447: std :: vector < std :: unique_ptr < FileData > > :: const_iterator begin ( ) const {
448: return mData@var201 .@exprUNIQUE begin (@exprUNIQUE ) ;
449: }
450: std :: vector < std :: unique_ptr < FileData > > :: const_iterator end ( ) const {
451: return mData@var201 .@exprUNIQUE end (@exprUNIQUE ) ;
452: }
453: std :: vector < std :: unique_ptr < FileData > > :: const_iterator cbegin ( ) const {
454: return mData@var201 .@exprUNIQUE cbegin (@exprUNIQUE ) ;
455: }
456: std :: vector < std :: unique_ptr < FileData > > :: const_iterator cend ( ) const {
457: return mData@var201 .@exprUNIQUE cend (@exprUNIQUE ) ;
458: }
459:
460: private:
461: struct FileID {
462:
|
476:
477: dev_t dev@var187 ;
478: ino_t ino@var188 ;
479:
480: bool operator== ( const FileID & that@var189 ) const noexcept ( true ) {
481: return dev@var187 ==@exprUNIQUE that@var189 .@exprUNIQUE dev@var190 &&@exprUNIQUE ino@var188 ==@exprUNIQUE that@var189 .@exprUNIQUE ino@var191 ;
482: }
483:
484: struct Hasher {
485: unsigned long operator() ( const FileID & id@var192 ) const {
486:
|
489:
490: return static_cast < unsigned long > (@exprUNIQUE id@var192 .@exprUNIQUE dev@var193 ) ^@exprUNIQUE static_cast < unsigned long > (@exprUNIQUE id@var192 .@exprUNIQUE ino@var194 ) ;
491:
492: }
493: } ;
494: } ;
495:
|
498:
499: static bool getFileId ( const std :: string & path@var195 , FileID & id@var196 ) ;
500:
501: std :: pair < FileData * , bool > tryload ( std :: unordered_map < std :: string , FileData * > :: iterator & name_it@var197 , const DUI & dui@var198 , std :: vector < std :: string > & filenames@var199 , std :: list < Output > * outputList@var200 ) ;
502:
503: std :: vector < std :: unique_ptr < FileData > > mData@var201 ;
504: std :: unordered_map < std :: string , FileData * > mNameMap@var202 ;
505: std :: unordered_map < FileID , FileData * , FileID :: Hasher > mIdMap@var203 ;
506:
507: } ;
508: }

##file simplecpp-1.5.1/simplecpp.cpp

1:
|
48:
49: static bool isHex ( const std :: string & s@var204 )
50: {
51: return s@var204 .@exprUNIQUE size (@exprUNIQUE ) >@exprUNIQUE 2 &&@exprUNIQUE ( s@var204 .@expr1574 compare (@exprUNIQUE 0 ,@expr1576 2 ,@exprUNIQUE "0x"@exprUNIQUE ) ==@exprUNIQUE 0 ||@exprUNIQUE s@var204 .@expr1574 compare (@exprUNIQUE 0 ,@expr1576 2 ,@exprUNIQUE "0X"@exprUNIQUE ) ==@exprUNIQUE 0 ) ;
52: }
53:
54: static bool isOct ( const std :: string & s@var205 )
55: {
56: return s@var205 .@exprUNIQUE size (@exprUNIQUE ) >@exprUNIQUE 1 &&@exprUNIQUE ( s@var205 [@exprUNIQUE 0 ] ==@exprUNIQUE '0'@expr1594 ) &&@exprUNIQUE ( s@var205 [@expr1597 1 ] >=@exprUNIQUE '0'@expr1594 ) &&@exprUNIQUE ( s@var205 [@expr1597 1 ] <@exprUNIQUE '8'@exprUNIQUE ) ;
57: }
58:
59:
60: static bool isStringLiteral_ ( const std :: string & s@var206 )
61: {
62: return s@var206 .@exprUNIQUE size (@exprUNIQUE ) >@exprUNIQUE 1 &&@exprUNIQUE ( s@var206 [@exprUNIQUE 0 ] ==@exprUNIQUE '\"'@expr1610 ) &&@exprUNIQUE ( *@exprUNIQUE s@var206 .@exprUNIQUE rbegin (@exprUNIQUE ) ==@exprUNIQUE '\"'@expr1610 ) ;
63: }
64:
65:
66: static bool isCharLiteral_ ( const std :: string & s@var207 )
67: {
68:
69:
70: return s@var207 .@exprUNIQUE size (@exprUNIQUE ) >@exprUNIQUE 1 &&@exprUNIQUE ( s@var207 [@exprUNIQUE 0 ] ==@exprUNIQUE '\''@expr1626 ) &&@exprUNIQUE ( *@exprUNIQUE s@var207 .@exprUNIQUE rbegin (@exprUNIQUE ) ==@exprUNIQUE '\''@expr1626 ) ;
71: }
72:
73: static const std :: string DEFINE@var208 ( "define" ) ;
74: static const std :: string UNDEF@var209 ( "undef" ) ;
75:
76: static const std :: string INCLUDE@var210 ( "include" ) ;
77:
78: static const std :: string ERROR@var211 ( "error" ) ;
79: static const std :: string WARNING@var212 ( "warning" ) ;
80:
81: static const std :: string IF@var213 ( "if" ) ;
82: static const std :: string IFDEF@var214 ( "ifdef" ) ;
83: static const std :: string IFNDEF@var215 ( "ifndef" ) ;
84: static const std :: string DEFINED@var216 ( "defined" ) ;
85: static const std :: string ELSE@var217 ( "else" ) ;
86: static const std :: string ELIF@var218 ( "elif" ) ;
87: static const std :: string ENDIF@var219 ( "endif" ) ;
88:
89: static const std :: string PRAGMA@var220 ( "pragma" ) ;
90: static const std :: string ONCE@var221 ( "once" ) ;
91:
92: static const std :: string HAS_INCLUDE@var222 ( "__has_include" ) ;
93:
94: template < class T > static std :: string toString ( T t@var223 )
95: {
96:
97: std ::@exprUNIQUE ostringstream ostr@var224 ;
98: ostr@var224 <<@exprUNIQUE t@var223 ;
99: return ostr@var224 .@exprUNIQUE str (@exprUNIQUE ) ;
100: }
101:
|
110:
111: static long long stringToLL ( const std :: string & s@var225 )
112: {
113: long long ret@var226 ;
114: const bool hex@var227 =@exprUNIQUE isHex (@exprUNIQUE s@var225 ) ;
115: const bool oct@var228 =@exprUNIQUE isOct (@exprUNIQUE s@var225 ) ;
116: std ::@exprUNIQUE istringstream istr@var229 (@exprUNIQUE hex@var227 ?@exprUNIQUE s@var225 .@expr1652 substr (@exprUNIQUE 2 ) :@exprUNIQUE oct@var228 ?@exprUNIQUE s@var225 .@expr1652 substr (@exprUNIQUE 1 ) :@exprUNIQUE s@var225 ) ;
117: if ( hex@var227 ) {
118: istr@var229 >>@exprUNIQUE std ::@exprUNIQUE hex ; }
119: else { if ( oct@var228 ) {
120: istr@var229 >>@exprUNIQUE std ::@exprUNIQUE oct ; } }
121: istr@var229 >>@exprUNIQUE ret@var226 ;
122: return ret@var226 ;
123: }
124:
125: static unsigned long long stringToULL ( const std :: string & s@var230 )
126: {
127: unsigned long long ret@var231 ;
128: const bool hex@var232 =@exprUNIQUE isHex (@exprUNIQUE s@var230 ) ;
129: const bool oct@var233 =@exprUNIQUE isOct (@exprUNIQUE s@var230 ) ;
130: std ::@exprUNIQUE istringstream istr@var234 (@exprUNIQUE hex@var232 ?@exprUNIQUE s@var230 .@expr1684 substr (@exprUNIQUE 2 ) :@exprUNIQUE oct@var233 ?@exprUNIQUE s@var230 .@expr1684 substr (@exprUNIQUE 1 ) :@exprUNIQUE s@var230 ) ;
131: if ( hex@var232 ) {
132: istr@var234 >>@exprUNIQUE std ::@exprUNIQUE hex ; }
133: else { if ( oct@var233 ) {
134: istr@var234 >>@exprUNIQUE std ::@exprUNIQUE oct ; } }
135: istr@var234 >>@exprUNIQUE ret@var231 ;
136: return ret@var231 ;
137: }
138:
139: static bool endsWith ( const std :: string & s@var235 , const std :: string & e@var236 )
140: {
141: return ( s@var235 .@exprUNIQUE size (@exprUNIQUE ) >=@exprUNIQUE e@var236 .@exprUNIQUE size (@exprUNIQUE ) ) &&@exprUNIQUE std ::@exprUNIQUE equal (@exprUNIQUE e@var236 .@exprUNIQUE rbegin (@exprUNIQUE ) ,@exprUNIQUE e@var236 .@exprUNIQUE rend (@exprUNIQUE ) ,@exprUNIQUE s@var235 .@exprUNIQUE rbegin (@exprUNIQUE ) ) ;
142: }
143:
144: static bool sameline ( const simplecpp :: Token * tok1@var237 , const simplecpp :: Token * tok2@var238 )
145: {
146: return tok1@var237 &&@exprUNIQUE tok2@var238 &&@exprUNIQUE tok1@var237 .@exprUNIQUE location@var239 .@exprUNIQUE sameline (@exprUNIQUE tok2@var238 .@exprUNIQUE location@var240 ) ;
147: }
148:
149: static bool isAlternativeBinaryOp ( const simplecpp :: Token * tok@var241 , const std :: string & alt@var242 )
150: {
151: return ( tok@var241 .@exprUNIQUE name@var243 &&@exprUNIQUE
152: tok@var241 .@exprUNIQUE str (@exprUNIQUE ) ==@exprUNIQUE alt@var242 &&@exprUNIQUE
153: tok@var241 .@expr1739 previous@var244 &&@exprUNIQUE
154: tok@var241 .@expr1741 next@var245 &&@exprUNIQUE
155: ( tok@var241 .@expr1739 previous@var244 .@exprUNIQUE number@var246 ||@exprUNIQUE tok@var241 .@expr1739 previous@var244 .@exprUNIQUE name@var247 ||@exprUNIQUE tok@var241 .@expr1739 previous@var244 .@exprUNIQUE op@var248 ==@exprUNIQUE ')'@exprUNIQUE ) &&@exprUNIQUE
156: ( tok@var241 .@expr1741 next@var245 .@exprUNIQUE number@var249 ||@exprUNIQUE tok@var241 .@expr1741 next@var245 .@exprUNIQUE name@var250 ||@exprUNIQUE tok@var241 .@expr1741 next@var245 .@exprUNIQUE op@var251 ==@exprUNIQUE '('@exprUNIQUE ) ) ;
157: }
158:
159: static bool isAlternativeUnaryOp ( const simplecpp :: Token * tok@var252 , const std :: string & alt@var253 )
160: {
161: return ( ( tok@var252 .@exprUNIQUE name@var254 &&@exprUNIQUE tok@var252 .@exprUNIQUE str (@exprUNIQUE ) ==@exprUNIQUE alt@var253 ) &&@exprUNIQUE
162: ( !@exprUNIQUE tok@var252 .@expr1765 previous@var255 ||@exprUNIQUE tok@var252 .@expr1765 previous@var255 .@exprUNIQUE op@var256 ==@exprUNIQUE '('@exprUNIQUE ) &&@exprUNIQUE
163: ( tok@var252 .@expr1772 next@var257 &&@exprUNIQUE ( tok@var252 .@expr1772 next@var257 .@exprUNIQUE name@var258 ||@exprUNIQUE tok@var252 .@expr1772 next@var257 .@exprUNIQUE number@var259 ) ) ) ;
164: }
165:
166: static std :: string replaceAll ( std :: string s@var260 , const std :: string & from@var261 , const std :: string & to@var262 )
167: {
168: for ( unsigned long pos@var263 =@exprUNIQUE s@var260 .@expr1780 find (@exprUNIQUE from@var261 ) ;@exprUNIQUE pos@var263 !=@exprUNIQUE std ::@exprUNIQUE string ::@exprUNIQUE npos ;@exprUNIQUE pos@var263 =@exprUNIQUE s@var260 .@expr1780 find (@exprUNIQUE from@var261 ,@exprUNIQUE pos@var263 +@exprUNIQUE to@var262 .@exprUNIQUE size (@exprUNIQUE ) ) ) {
169: s@var260 .@exprUNIQUE replace (@exprUNIQUE pos@var263 ,@exprUNIQUE from@var261 .@exprUNIQUE size (@exprUNIQUE ) ,@exprUNIQUE to@var262 ) ; }
170: return s@var260 ;
171: }
172:
173: const std :: string simplecpp :: Location :: emptyFileName@var23 ;
174:
175: void simplecpp :: Location :: adjust ( const std :: string & str@var264 )
176: {
177: if ( strpbrk (@exprUNIQUE str@var264 .@exprUNIQUE c_str (@exprUNIQUE ) ,@exprUNIQUE "\r\n"@exprUNIQUE ) ==@exprUNIQUE nullptr ) {
178: col@var22 +=@exprUNIQUE str@var264 .@expr1817 size (@expr1818 ) ;
179: return ;
180: }
181:
182: for ( unsigned long i@var265 = 0U ; i@var265 <@exprUNIQUE str@var264 .@expr1817 size (@expr1818 ) ;@exprUNIQUE ++@exprUNIQUE i@var265 ) {
183: col@var22 ++@exprUNIQUE ;
184: if ( str@var264 [@expr1824 i@var265 ] ==@exprUNIQUE '\n'@expr1825 ||@exprUNIQUE str@var264 [@expr1824 i@var265 ] ==@expr1828 '\r'@expr1827 ) {
185: col@var22 = 1 ;
186: line@var21 ++@exprUNIQUE ;
187: if ( str@var264 [@expr1824 i@var265 ] ==@expr1828 '\r'@expr1827 &&@exprUNIQUE ( i@var265 +@expr1832 1 ) <@exprUNIQUE str@var264 .@expr1817 size (@expr1818 ) &&@exprUNIQUE str@var264 [@exprUNIQUE i@var265 +@expr1832 1 ] ==@exprUNIQUE '\n'@expr1825 ) {
188: ++@exprUNIQUE i@var265 ; }
189: }
190: }
191: }
192:
193: bool simplecpp :: Token :: isOneOf ( const char ops@var266 [ ] ) const
194: {
195: return ( op@var43 !=@exprUNIQUE '\0'@exprUNIQUE ) &&@exprUNIQUE ( std ::@exprUNIQUE strchr (@exprUNIQUE ops@var266 ,@exprUNIQUE op@var43 ) !=@exprUNIQUE nullptr ) ;
196: }
197:
198: bool simplecpp :: Token :: startsWithOneOf ( const char c@var267 [ ] ) const
199: {
200: return std ::@exprUNIQUE strchr (@exprUNIQUE c@var267 ,@exprUNIQUE string@var63 [@exprUNIQUE 0 ] ) !=@exprUNIQUE nullptr ;
201: }
202:
203: bool simplecpp :: Token :: endsWithOneOf ( const char c@var268 [ ] ) const
204: {
205: return std ::@exprUNIQUE strchr (@exprUNIQUE c@var268 ,@exprUNIQUE string@var63 [@exprUNIQUE string@var63 .@exprUNIQUE size (@exprUNIQUE ) -@exprUNIQUE 1U ] ) !=@exprUNIQUE nullptr ;
206: }
207:
208: void simplecpp :: Token :: printAll ( ) const
209: {
210: const Token * tok@var269 ; tok@var269 = this ;
211: while ( tok@var269 .@expr1873 previous@var270 ) {
212: tok@var269 =@exprUNIQUE tok@var269 .@expr1873 previous@var270 ; }
213: for ( ;@exprUNIQUE tok@var269 ;@exprUNIQUE tok@var269 =@exprUNIQUE tok@var269 .@exprUNIQUE next@var271 ) {
214: if ( tok@var269 .@expr1873 previous@var270 ) {
215: std ::@expr1882 cout <<@exprUNIQUE ( sameline (@exprUNIQUE tok@var269 ,@exprUNIQUE tok@var269 .@expr1873 previous@var270 ) ?@exprUNIQUE ' '@exprUNIQUE :@exprUNIQUE '\n'@exprUNIQUE ) ;
216: }
217: std ::@expr1882 cout <<@exprUNIQUE tok@var269 .@exprUNIQUE str (@exprUNIQUE ) ;
218: }
219: std ::@expr1882 cout <<@exprUNIQUE std ::@exprUNIQUE endl ;
220: }
221:
222: void simplecpp :: Token :: printOut ( ) const
223: {
224: for ( const Token * tok@var272 = this ; tok@var272 ;@exprUNIQUE tok@var272 =@exprUNIQUE tok@var272 .@exprUNIQUE next@var273 ) {
225: if ( tok@var272 !=@exprUNIQUE this ) {
226: std ::@expr1910 cout <<@exprUNIQUE ( sameline (@exprUNIQUE tok@var272 ,@exprUNIQUE tok@var272 .@exprUNIQUE previous@var274 ) ?@exprUNIQUE ' '@exprUNIQUE :@exprUNIQUE '\n'@exprUNIQUE ) ;
227: }
228: std ::@expr1910 cout <<@exprUNIQUE tok@var272 .@exprUNIQUE str (@exprUNIQUE ) ;
229: }
230: std ::@expr1910 cout <<@exprUNIQUE std ::@exprUNIQUE endl ;
231: }
232:
233:
234: class simplecpp :: TokenList :: Stream {
235: public:
236: virtual ~ Stream ( ) { }
237:
238: virtual int get ( ) = 0 ;
239: virtual int peek ( ) = 0 ;
240: virtual void unget ( ) = 0 ;
241: virtual bool good ( ) = 0 ;
242:
243: unsigned char readChar ( ) {
244: unsigned char ch@var275 ; ch@var275 =@exprUNIQUE static_cast < unsigned char > (@exprUNIQUE get (@expr1931 ) ) ;
245:
246:
247:
248: if ( isUtf16@var288 ) {
249: const unsigned char ch2@var276 =@exprUNIQUE static_cast < unsigned char > (@exprUNIQUE get (@expr1931 ) ) ;
250: const int ch16@var277 =@exprUNIQUE makeUtf16Char (@exprUNIQUE ch@var275 ,@exprUNIQUE ch2@var276 ) ;
251: ch@var275 =@exprUNIQUE static_cast < unsigned char > (@exprUNIQUE ( ch16@var277 >=@exprUNIQUE 0x80 ) ?@exprUNIQUE 0xff :@exprUNIQUE ch16@var277 ) ;
252: }
253:
254:
255: if ( ch@var275 ==@exprUNIQUE '\r'@exprUNIQUE ) {
256: ch@var275 = '\n' ;
257:
258: int ch2@var278 ; ch2@var278 =@exprUNIQUE get (@expr1931 ) ;
259: if ( isUtf16@var288 ) {
260: const int c2@var279 =@exprUNIQUE get (@expr1931 ) ;
261: ch2@var278 =@exprUNIQUE makeUtf16Char (@exprUNIQUE ch2@var278 ,@exprUNIQUE c2@var279 ) ;
262: }
263:
264: if ( ch2@var278 !=@exprUNIQUE '\n'@exprUNIQUE ) {
265: ungetChar (@exprUNIQUE ) ; }
266: }
267:
268: return ch@var275 ;
269: }
270:
271: unsigned char peekChar ( ) {
272: unsigned char ch@var280 ; ch@var280 =@exprUNIQUE static_cast < unsigned char > (@exprUNIQUE peek (@expr1962 ) ) ;
273:
274:
275:
276: if ( isUtf16@var288 ) {
277: (@exprUNIQUE void ) get (@exprUNIQUE ) ;
278: const unsigned char ch2@var281 =@exprUNIQUE static_cast < unsigned char > (@exprUNIQUE peek (@expr1962 ) ) ;
279: unget (@exprUNIQUE ) ;
280: const int ch16@var282 =@exprUNIQUE makeUtf16Char (@exprUNIQUE ch@var280 ,@exprUNIQUE ch2@var281 ) ;
281: ch@var280 =@exprUNIQUE static_cast < unsigned char > (@exprUNIQUE ( ch16@var282 >=@exprUNIQUE 0x80 ) ?@exprUNIQUE 0xff :@exprUNIQUE ch16@var282 ) ;
282: }
283:
284:
285: if ( ch@var280 ==@exprUNIQUE '\r'@exprUNIQUE ) {
286: ch@var280 = '\n' ; }
287:
288: return ch@var280 ;
289: }
290:
291: void ungetChar ( ) {
292: unget (@expr1988 ) ;
293: if ( isUtf16@var288 ) {
294: unget (@expr1988 ) ; }
295: }
296:
297: protected:
298: void init ( ) {
299:
300: isUtf16@var288 = false ;
301: bom@var287 =@exprUNIQUE getAndSkipBOM (@exprUNIQUE ) ;
302: isUtf16@var288 =@exprUNIQUE bom@var287 ==@exprUNIQUE 0xfeff ||@exprUNIQUE bom@var287 ==@exprUNIQUE 0xfffe ;
303: }
304:
305: private:
306: int makeUtf16Char ( const unsigned char ch@var283 , const unsigned char ch2@var284 ) const {
307: return ( bom@var287 ==@exprUNIQUE 0xfeff ) ?@exprUNIQUE ( ch@var283 <<@exprUNIQUE 8 |@exprUNIQUE ch2@var284 ) :@exprUNIQUE ( ch2@var284 <<@exprUNIQUE 8 |@exprUNIQUE ch@var283 ) ;
308: }
309:
310: unsigned short getAndSkipBOM ( ) {
311: const int ch1@var285 =@exprUNIQUE peek (@expr2008 ) ;
312:
313:
314: if ( ch1@var285 >=@exprUNIQUE 0xfe ) {
315: (@expr2014 void ) get (@expr2013 ) ;
316: const unsigned short byte@var286 =@exprUNIQUE static_cast < unsigned char > (@exprUNIQUE ch1@var285 ) <<@exprUNIQUE 8 ;
317: if ( peek (@expr2008 ) >=@exprUNIQUE 0xfe ) {
318: return byte@var286 |@exprUNIQUE static_cast < unsigned char > (@exprUNIQUE get (@expr2013 ) ) ; }
319: unget (@expr2025 ) ;
320: return 0 ;
321: }
322:
323:
324: if ( ch1@var285 ==@exprUNIQUE 0xef ) {
325: (@expr2014 void ) get (@expr2013 ) ;
326: if ( peek (@expr2008 ) ==@exprUNIQUE 0xbb ) {
327: (@expr2014 void ) get (@expr2013 ) ;
328: if ( peek (@expr2008 ) ==@exprUNIQUE 0xbf ) {
329: (@expr2014 void ) get (@expr2013 ) ;
330: return 0 ;
331: }
332: unget (@expr2025 ) ;
333: }
334: unget (@expr2025 ) ;
335: }
336:
337: return 0 ;
338: }
339:
340: unsigned short bom@var287 ;
341: protected:
342: bool isUtf16@var288 ;
343: } ;
344:
345: class StdIStream : public simplecpp :: TokenList :: Stream {
346: public:
347:
348: explicit StdIStream ( std :: istream & istr@var289 )
349: : istr@var290 ( istr@var289 ) {
350: assert (@exprUNIQUE istr@var289 .@exprUNIQUE good (@exprUNIQUE ) ) ;
351: init (@exprUNIQUE ) ;
352: }
353:
354: virtual int get ( ) override {
355: return istr@var290 .@exprUNIQUE get (@exprUNIQUE ) ;
356: }
357: virtual int peek ( ) override {
358: return istr@var290 .@exprUNIQUE peek (@exprUNIQUE ) ;
359: }
360: virtual void unget ( ) override {
361: istr@var290 .@exprUNIQUE unget (@exprUNIQUE ) ;
362: }
363: virtual bool good ( ) override {
364: return istr@var290 .@exprUNIQUE good (@exprUNIQUE ) ;
365: }
366:
367: private:
368: std :: istream & istr@var290 ;
369: } ;
370:
371: class StdCharBufStream : public simplecpp :: TokenList :: Stream {
372: public:
373:
374: StdCharBufStream ( const unsigned char * str@var291 , unsigned long size@var292 )
375: : str@var293 ( str@var291 )
376: , size@var294 ( size@var292 )
377: , pos@var295 ( 0 )
378: , lastStatus@var296 ( 0 ) {
379: init (@exprUNIQUE ) ;
380: }
381:
382: virtual int get ( ) override {
383: if ( pos@var295 >=@exprUNIQUE size@var294 ) {
384: return lastStatus@var296 =@exprUNIQUE EOF@exprUNIQUE ; }
385: return str@var293 [@exprUNIQUE pos@var295 ++@exprUNIQUE ] ;
386: }
387: virtual int peek ( ) override {
388: if ( pos@var295 >=@exprUNIQUE size@var294 ) {
389: return lastStatus@var296 =@exprUNIQUE EOF@exprUNIQUE ; }
390: return str@var293 [@exprUNIQUE pos@var295 ] ;
391: }
392: virtual void unget ( ) override {
393: --@exprUNIQUE pos@var295 ;
394: }
395: virtual bool good ( ) override {
396: return lastStatus@var296 !=@exprUNIQUE EOF@exprUNIQUE ;
397: }
398:
399: private:
400: const unsigned char * str@var293 ;
401: const unsigned long size@var294 ;
402: unsigned long pos@var295 ;
403: int lastStatus@var296 ;
404: } ;
405:
406: class FileStream : public simplecpp :: TokenList :: Stream {
407: public:
408:
409: explicit FileStream ( const std :: string & filename@var297 , std :: vector < std :: string > & files@var298 )
410: : file@var301 ( fopen ( filename@var297 . c_str ( ) , "rb" ) )
411: , lastCh@var302 ( 0 )
412: , lastStatus@var303 ( 0 ) {
413: if ( !@exprUNIQUE file@var301 ) {
414: files@var298 .@exprUNIQUE push_back (@exprUNIQUE filename@var297 ) ;
415: throw@exprUNIQUE simplecpp ::@expr2074 Output (@exprUNIQUE files@var298 ,@exprUNIQUE simplecpp ::@expr2074 Output ::@exprUNIQUE FILE_NOT_FOUND ,@exprUNIQUE "File is missing: "@exprUNIQUE +@exprUNIQUE filename@var297 ) ;
416: }
417: init (@exprUNIQUE ) ;
418: }
419:
420: ~ FileStream ( ) override {
421: fclose (@exprUNIQUE file@var301 ) ;
422: file@var301 = nullptr ;
423: }
424:
425: virtual int get ( ) override {
426: lastStatus@var303 =@exprUNIQUE lastCh@var302 =@exprUNIQUE fgetc (@exprUNIQUE file@var301 ) ;
427: return lastCh@var302 ;
428: }
429: virtual int peek ( ) override {
430:
431: const int ch@var299 =@exprUNIQUE fgetc (@exprUNIQUE file@var301 ) ;
432: unget_internal (@exprUNIQUE ch@var299 ) ;
433: return ch@var299 ;
434: }
435: virtual void unget ( ) override {
436: unget_internal (@exprUNIQUE lastCh@var302 ) ;
437: }
438: virtual bool good ( ) override {
439: return lastStatus@var303 !=@exprUNIQUE EOF@exprUNIQUE ;
440: }
441:
442: private:
443: void unget_internal ( int ch@var300 ) {
444: if ( isUtf16@var288 ) {
445:
446:
447: fseek (@exprUNIQUE file@var301 ,@exprUNIQUE -1 ,@exprUNIQUE $1 ) ;
448: } else {
449: ungetc (@exprUNIQUE ch@var300 ,@exprUNIQUE file@var301 ) ; }
450: }
451:
452: FileStream ( const FileStream & ) ;
453: FileStream & operator= ( const FileStream & ) ;
454:
455: FILE * file@var301 ;
456: int lastCh@var302 ;
457: int lastStatus@var303 ;
458: } ;
459:
460: simplecpp :: TokenList :: TokenList ( std :: vector < std :: string > & filenames@var304 ) : frontToken@var131 ( nullptr ) , backToken@var132 ( nullptr ) , files@var133 ( filenames@var304 ) { }
461:
462: simplecpp :: TokenList :: TokenList ( std :: istream & istr@var305 , std :: vector < std :: string > & filenames@var306 , const std :: string & filename@var307 , std :: list < Output > * outputList@var308 )
463: : frontToken@var131 ( nullptr ) , backToken@var132 ( nullptr ) , files@var133 ( filenames@var306 )
464: {
465: StdIStream stream@var309 (@exprUNIQUE istr@var305 ) ;
466: readfile (@exprUNIQUE stream@var309 ,@exprUNIQUE filename@var307 ,@exprUNIQUE outputList@var308 ) ;
467: }
468:
469: simplecpp :: TokenList :: TokenList ( const unsigned char * data@var310 , unsigned long size@var311 , std :: vector < std :: string > & filenames@var312 , const std :: string & filename@var313 , std :: list < Output > * outputList@var314 )
470: : frontToken@var131 ( nullptr ) , backToken@var132 ( nullptr ) , files@var133 ( filenames@var312 )
471: {
472: StdCharBufStream stream@var315 (@exprUNIQUE data@var310 ,@exprUNIQUE size@var311 ) ;
473: readfile (@exprUNIQUE stream@var315 ,@exprUNIQUE filename@var313 ,@exprUNIQUE outputList@var314 ) ;
474: }
475:
476: simplecpp :: TokenList :: TokenList ( const char * data@var316 , unsigned long size@var317 , std :: vector < std :: string > & filenames@var318 , const std :: string & filename@var319 , std :: list < Output > * outputList@var320 )
477: : frontToken@var131 ( nullptr ) , backToken@var132 ( nullptr ) , files@var133 ( filenames@var318 )
478: {
479: StdCharBufStream stream@var321 (@exprUNIQUE reinterpret_cast < const unsigned char * > (@exprUNIQUE data@var316 ) ,@exprUNIQUE size@var317 ) ;
480: readfile (@exprUNIQUE stream@var321 ,@exprUNIQUE filename@var319 ,@exprUNIQUE outputList@var320 ) ;
481: }
482:
483: simplecpp :: TokenList :: TokenList ( const std :: string & filename@var322 , std :: vector < std :: string > & filenames@var323 , std :: list < Output > * outputList@var324 )
484: : frontToken@var131 ( nullptr ) , backToken@var132 ( nullptr ) , files@var133 ( filenames@var323 )
485: {
486: try {
487: FileStream stream@var325 (@exprUNIQUE filename@var322 ,@exprUNIQUE filenames@var323 ) ;
488: readfile (@exprUNIQUE stream@var325 ,@exprUNIQUE filename@var322 ,@exprUNIQUE outputList@var324 ) ;
489: } catch (@exprUNIQUE const simplecpp ::@exprUNIQUE Output &@exprUNIQUE e@var326 ) {
490: outputList@var324 .@exprUNIQUE push_back (@exprUNIQUE e@var326 ) ;
491: }
492: }
493:
494: simplecpp :: TokenList :: TokenList ( const TokenList & other@var327 ) : frontToken@var131 ( nullptr ) , backToken@var132 ( nullptr ) , files@var133 ( other@var327 . files@var328 )
495: {
496: *@exprUNIQUE this =@exprUNIQUE other@var327 ;
497: }
498:
499: simplecpp :: TokenList :: TokenList ( TokenList && other@var329 ) : frontToken@var131 ( nullptr ) , backToken@var132 ( nullptr ) , files@var133 ( other@var329 . files@var330 )
500: {
501: *@exprUNIQUE this =@exprUNIQUE std ::@exprUNIQUE move (@exprUNIQUE other@var329 ) ;
502: }
503:
504: simplecpp :: TokenList :: ~ TokenList ( )
505: {
506: clear (@exprUNIQUE ) ;
507: }
508:
509: simplecpp :: TokenList & simplecpp :: TokenList :: operator= ( const TokenList & other@var331 )
510: {
511: if ( this !=@exprUNIQUE &@exprUNIQUE other@var331 ) {
512: clear (@exprUNIQUE ) ;
513: files@var133 =@exprUNIQUE other@var331 .@exprUNIQUE files@var332 ;
514: for ( const Token * tok@var333 =@exprUNIQUE other@var331 .@exprUNIQUE cfront (@exprUNIQUE ) ;@exprUNIQUE tok@var333 ;@exprUNIQUE tok@var333 =@exprUNIQUE tok@var333 .@exprUNIQUE next@var334 ) {
515: push_back (@exprUNIQUE new@exprUNIQUE Token (@exprUNIQUE *@exprUNIQUE tok@var333 ) ) ; }
516: sizeOfType@var110 =@exprUNIQUE other@var331 .@exprUNIQUE sizeOfType@var335 ;
517: }
518: return *@exprUNIQUE this ;
519: }
520:
521: simplecpp :: TokenList & simplecpp :: TokenList :: operator= ( TokenList && other@var336 )
522: {
523: if ( this !=@exprUNIQUE &@exprUNIQUE other@var336 ) {
524: clear (@exprUNIQUE ) ;
525: frontToken@var131 =@exprUNIQUE other@var336 .@expr2188 frontToken@var337 ;
526: other@var336 .@expr2188 frontToken@var337 = nullptr ;
527: backToken@var132 =@exprUNIQUE other@var336 .@expr2190 backToken@var338 ;
528: other@var336 .@expr2190 backToken@var338 = nullptr ;
529: files@var133 =@exprUNIQUE other@var336 .@exprUNIQUE files@var339 ;
530: sizeOfType@var110 =@exprUNIQUE std ::@exprUNIQUE move (@exprUNIQUE other@var336 .@exprUNIQUE sizeOfType@var340 ) ;
531: }
532: return *@exprUNIQUE this ;
533: }
534:
535: void simplecpp :: TokenList :: clear ( )
536: {
537: backToken@var132 = nullptr ;
538: while ( frontToken@var131 ) {
539: Token * const next@var341 ; next@var341 =@exprUNIQUE frontToken@var131 .@exprUNIQUE next@var1322 ;
540: delete@exprUNIQUE frontToken@var131 ;
541: frontToken@var131 =@exprUNIQUE next@var341 ;
542: }
543: sizeOfType@var110 .@exprUNIQUE clear (@exprUNIQUE ) ;
544: }
545:
546: void simplecpp :: TokenList :: push_back ( Token * tok@var342 )
547: {
548: if ( !@exprUNIQUE frontToken@var131 ) {
549: frontToken@var131 =@exprUNIQUE tok@var342 ; }
550: else {
551: backToken@var132 .@exprUNIQUE next@var1323 =@exprUNIQUE tok@var342 ; }
552: tok@var342 .@exprUNIQUE previous@var343 =@exprUNIQUE backToken@var132 ;
553: backToken@var132 =@exprUNIQUE tok@var342 ;
554: }
555:
556: void simplecpp :: TokenList :: dump ( ) const
557: {
558: std ::@exprUNIQUE cout <<@exprUNIQUE stringify (@exprUNIQUE ) <<@exprUNIQUE std ::@exprUNIQUE endl ;
559: }
560:
561: std :: string simplecpp :: TokenList :: stringify ( ) const
562: {
563: std ::@exprUNIQUE ostringstream ret@var344 ;
564: Location loc@var345 (@exprUNIQUE files@var133 ) ;
565: for ( const Token * tok@var346 =@exprUNIQUE cfront (@exprUNIQUE ) ;@exprUNIQUE tok@var346 ;@exprUNIQUE tok@var346 =@exprUNIQUE tok@var346 .@exprUNIQUE next@var347 ) {
566: if ( tok@var346 .@expr2239 location@var348 .@expr2240 line@var349 <@exprUNIQUE loc@var345 .@expr2241 line@var350 ||@exprUNIQUE tok@var346 .@expr2239 location@var348 .@exprUNIQUE fileIndex@var351 !=@exprUNIQUE loc@var345 .@exprUNIQUE fileIndex@var352 ) {
567: ret@var344 <<@exprUNIQUE "\n#line "@exprUNIQUE <<@exprUNIQUE tok@var346 .@expr2239 location@var348 .@expr2240 line@var349 <<@exprUNIQUE " \""@exprUNIQUE <<@exprUNIQUE tok@var346 .@expr2239 location@var348 .@exprUNIQUE file (@exprUNIQUE ) <<@exprUNIQUE "\"\n"@exprUNIQUE ;
568: loc@var345 =@exprUNIQUE tok@var346 .@expr2239 location@var348 ;
569: }
570:
571: while ( tok@var346 .@expr2239 location@var348 .@expr2240 line@var349 >@exprUNIQUE loc@var345 .@expr2241 line@var350 ) {
572: ret@var344 <<@exprUNIQUE '\n'@exprUNIQUE ;
573: loc@var345 .@expr2241 line@var350 ++@exprUNIQUE ;
574: }
575:
576: if ( sameline (@exprUNIQUE tok@var346 .@exprUNIQUE previous@var353 ,@exprUNIQUE tok@var346 ) ) {
577: ret@var344 <<@exprUNIQUE ' '@exprUNIQUE ; }
578:
579: ret@var344 <<@exprUNIQUE tok@var346 .@expr2270 str (@expr2271 ) ;
580:
581: loc@var345 .@exprUNIQUE adjust (@exprUNIQUE tok@var346 .@expr2270 str (@expr2271 ) ) ;
582: }
583:
584: return ret@var344 .@exprUNIQUE str (@exprUNIQUE ) ;
585: }
586:
587: static bool isNameChar ( unsigned char ch@var354 )
588: {
589: return std ::@exprUNIQUE isalnum (@exprUNIQUE ch@var354 ) ||@exprUNIQUE ch@var354 ==@exprUNIQUE '_'@exprUNIQUE ||@exprUNIQUE ch@var354 ==@exprUNIQUE '$'@exprUNIQUE ;
590: }
591:
592: static std :: string escapeString ( const std :: string & str@var355 )
593: {
594: std ::@exprUNIQUE ostringstream ostr@var356 ;
595: ostr@var356 <<@expr2291 '\"'@expr2290 ;
596: for ( unsigned long i@var357 = 1U ; i@var357 <@exprUNIQUE str@var355 .@exprUNIQUE size (@exprUNIQUE ) -@exprUNIQUE 1 ;@exprUNIQUE ++@exprUNIQUE i@var357 ) {
597: const char c@var358 =@exprUNIQUE str@var355 [@exprUNIQUE i@var357 ] ;
598: if ( c@var358 ==@exprUNIQUE '\\'@expr2302 ||@exprUNIQUE c@var358 ==@exprUNIQUE '\"'@expr2290 ||@exprUNIQUE c@var358 ==@exprUNIQUE '\''@exprUNIQUE ) {
599: ostr@var356 <<@exprUNIQUE '\\'@expr2302 ; }
600: ostr@var356 <<@exprUNIQUE c@var358 ;
601: }
602: ostr@var356 <<@expr2291 '\"'@expr2290 ;
603: return ostr@var356 .@exprUNIQUE str (@exprUNIQUE ) ;
604: }
605:
606: static void portabilityBackslash ( std :: list < Output > * outputList@var359 , const std :: vector < std :: string > & files@var360 , const simplecpp :: Location & location@var361 )
607: {
608: if ( !@exprUNIQUE outputList@var359 ) {
609: return ; }
610: simplecpp ::@exprUNIQUE Output err@var362 (@exprUNIQUE files@var360 ) ;
611: err@var362 .@exprUNIQUE type@var363 =@exprUNIQUE simplecpp ::@exprUNIQUE Output ::@exprUNIQUE PORTABILITY_BACKSLASH ;
612: err@var362 .@exprUNIQUE location@var364 =@exprUNIQUE location@var361 ;
613: err@var362 .@exprUNIQUE msg@var365 = "Combination 'backslash space newline' is not portable." ;
614: outputList@var359 .@exprUNIQUE push_back (@exprUNIQUE err@var362 ) ;
615: }
616:
617: static bool isStringLiteralPrefix ( const std :: string & str@var366 )
618: {
619: return str@var366 ==@exprUNIQUE "u"@exprUNIQUE ||@exprUNIQUE str@var366 ==@exprUNIQUE "U"@exprUNIQUE ||@exprUNIQUE str@var366 ==@exprUNIQUE "L"@exprUNIQUE ||@exprUNIQUE str@var366 ==@exprUNIQUE "u8"@exprUNIQUE ||@exprUNIQUE
620: str@var366 ==@exprUNIQUE "R"@exprUNIQUE ||@exprUNIQUE str@var366 ==@exprUNIQUE "uR"@exprUNIQUE ||@exprUNIQUE str@var366 ==@exprUNIQUE "UR"@exprUNIQUE ||@exprUNIQUE str@var366 ==@exprUNIQUE "LR"@exprUNIQUE ||@exprUNIQUE str@var366 ==@exprUNIQUE "u8R"@exprUNIQUE ;
621: }
622:
623: void simplecpp :: TokenList :: lineDirective ( unsigned int fileIndex@var367 , unsigned int line@var368 , Location * location@var369 )
624: {
625: if ( fileIndex@var367 !=@exprUNIQUE location@var369 .@expr2356 fileIndex@var370 ||@exprUNIQUE line@var368 >=@exprUNIQUE location@var369 .@expr2358 line@var371 ) {
626: location@var369 .@expr2356 fileIndex@var370 =@exprUNIQUE fileIndex@var367 ;
627: location@var369 .@expr2358 line@var371 =@expr2362 line@var368 ;
628: return ;
629: }
630:
631: if ( line@var368 +@exprUNIQUE 2 >=@exprUNIQUE location@var369 .@expr2358 line@var371 ) {
632: location@var369 .@expr2358 line@var371 =@expr2362 line@var368 ;
633: while ( cback (@exprUNIQUE ) .@exprUNIQUE op@var1324 !=@exprUNIQUE '#'@exprUNIQUE ) {
634: deleteToken (@expr2374 back (@expr2373 ) ) ; }
635: deleteToken (@expr2374 back (@expr2373 ) ) ;
636: return ;
637: }
638: }
639:
640: static const std :: string COMMENT_END@var372 ( "*/" ) ;
641:
642: void simplecpp :: TokenList :: readfile ( Stream & stream@var373 , const std :: string & filename@var374 , std :: list < Output > * outputList@var375 )
643: {
644: std ::@exprUNIQUE stack < simplecpp :: Location > loc@var376 ;
645:
646: unsigned int multiline@var377 ; multiline@var377 = 0U ;
647:
648: const Token * oldLastToken@var378 ; oldLastToken@var378 = nullptr ;
649:
650: Location location@var379 (@exprUNIQUE files@var133 ) ;
651: location@var379 .@expr2379 fileIndex@var380 =@exprUNIQUE fileIndex (@exprUNIQUE filename@var374 ) ;
652: location@var379 .@expr2383 line@var381 = 1U ;
653: location@var379 .@expr2384 col@var382 = 1U ;
654: while ( stream@var373 .@expr2386 good (@expr2387 ) ) {
655: unsigned char ch@var383 ; ch@var383 =@expr2391 stream@var373 .@expr2389 readChar (@expr2390 ) ;
656: if ( !@expr2392 stream@var373 .@expr2386 good (@expr2387 ) ) {
657: break ; }
658:
659: if ( ch@var383 >=@exprUNIQUE 0x80 ) {
660: if ( outputList@var375 ) {
661: simplecpp ::@exprUNIQUE Output err@var384 (@exprUNIQUE files@var133 ) ;
662: err@var384 .@exprUNIQUE type@var385 =@exprUNIQUE simplecpp ::@exprUNIQUE Output ::@exprUNIQUE UNHANDLED_CHAR_ERROR ;
663: err@var384 .@exprUNIQUE location@var386 =@exprUNIQUE location@var379 ;
664: std ::@exprUNIQUE ostringstream s@var387 ;
665: s@var387 <<@exprUNIQUE static_cast < int > (@exprUNIQUE ch@var383 ) ;
666: err@var384 .@exprUNIQUE msg@var388 =@exprUNIQUE "The code contains unhandled character(s) (character code="@exprUNIQUE +@exprUNIQUE s@var387 .@exprUNIQUE str (@exprUNIQUE ) +@exprUNIQUE "). Neither unicode nor extended ascii is supported."@exprUNIQUE ;
667: outputList@var375 .@expr2420 push_back (@exprUNIQUE err@var384 ) ;
668: }
669: clear (@exprUNIQUE ) ;
670: return ;
671: }
672:
673: if ( ch@var383 ==@expr2425 '\n'@expr2424 ) {
674: if ( cback (@expr2427 ) &&@exprUNIQUE cback (@expr2427 ) .@exprUNIQUE op@var1324 ==@exprUNIQUE '\\'@expr2429 ) {
675: if ( location@var379 .@expr2384 col@var382 >@exprUNIQUE cback (@expr2427 ) .@expr2432 location@var1325 .@expr2433 col@var1326 +@exprUNIQUE 1U ) {
676: portabilityBackslash (@exprUNIQUE outputList@var375 ,@expr2438 files@var133 ,@exprUNIQUE cback (@expr2427 ) .@expr2432 location@var1325 ) ; }
677: ++@exprUNIQUE multiline@var377 ;
678: deleteToken (@exprUNIQUE back (@expr2444 ) ) ;
679: } else {
680: location@var379 .@expr2383 line@var381 +=@exprUNIQUE multiline@var377 +@exprUNIQUE 1 ;
681: multiline@var377 = 0U ;
682: }
683: if ( !@exprUNIQUE multiline@var377 ) {
684: location@var379 .@expr2384 col@var382 = 1 ; }
685:
686: if ( oldLastToken@var378 !=@exprUNIQUE cback (@expr2427 ) ) {
687: oldLastToken@var378 =@exprUNIQUE cback (@expr2427 ) ;
688: if ( !@exprUNIQUE isLastLinePreprocessor (@expr2453 ) ) {
689: continue ; }
690: const std ::@exprUNIQUE string lastline@var389 (@exprUNIQUE lastLine (@exprUNIQUE ) ) ;
691: if ( lastline@var389 ==@exprUNIQUE "# file %str%"@exprUNIQUE ) {
692: const Token * strtok@var390 ; strtok@var390 =@exprUNIQUE cback (@expr2427 ) ;
693: while ( strtok@var390 .@exprUNIQUE comment@var391 ) {
694: strtok@var390 =@exprUNIQUE strtok@var390 .@exprUNIQUE previous@var392 ; }
695: loc@var376 .@exprUNIQUE push (@exprUNIQUE location@var379 ) ;
696: location@var379 .@expr2379 fileIndex@var380 =@exprUNIQUE fileIndex (@exprUNIQUE strtok@var390 .@expr2468 str (@expr2469 ) .@exprUNIQUE substr (@exprUNIQUE 1U ,@exprUNIQUE strtok@var390 .@expr2468 str (@expr2469 ) .@exprUNIQUE size (@exprUNIQUE ) -@exprUNIQUE 2U ) ) ;
697: location@var379 .@expr2383 line@var381 = 1U ;
698: } else { if ( lastline@var389 ==@exprUNIQUE "# line %num%"@exprUNIQUE ) {
699: const Token * numtok@var393 ; numtok@var393 =@exprUNIQUE cback (@expr2427 ) ;
700: while ( numtok@var393 .@exprUNIQUE comment@var394 ) {
701: numtok@var393 =@exprUNIQUE numtok@var393 .@exprUNIQUE previous@var395 ; }
702: lineDirective (@exprUNIQUE location@var379 .@expr2379 fileIndex@var380 ,@exprUNIQUE std ::@expr2489 atol (@exprUNIQUE numtok@var393 .@exprUNIQUE str (@exprUNIQUE ) .@exprUNIQUE c_str (@exprUNIQUE ) ) ,@exprUNIQUE &@expr2497 location@var379 ) ;
703: } else { if ( lastline@var389 ==@exprUNIQUE "# %num% %str%"@exprUNIQUE ||@exprUNIQUE lastline@var389 ==@exprUNIQUE "# line %num% %str%"@exprUNIQUE ) {
704: const Token * strtok@var396 ; strtok@var396 =@exprUNIQUE cback (@expr2427 ) ;
705: while ( strtok@var396 .@exprUNIQUE comment@var397 ) {
706: strtok@var396 =@exprUNIQUE strtok@var396 .@expr2507 previous@var398 ; }
707: const Token * numtok@var399 ; numtok@var399 =@exprUNIQUE strtok@var396 .@expr2507 previous@var398 ;
708: while ( numtok@var399 .@exprUNIQUE comment@var400 ) {
709: numtok@var399 =@exprUNIQUE numtok@var399 .@exprUNIQUE previous@var401 ; }
710: lineDirective (@exprUNIQUE fileIndex (@exprUNIQUE replaceAll (@exprUNIQUE strtok@var396 .@expr2514 str (@expr2515 ) .@exprUNIQUE substr (@exprUNIQUE 1U ,@exprUNIQUE strtok@var396 .@expr2514 str (@expr2515 ) .@exprUNIQUE size (@exprUNIQUE ) -@exprUNIQUE 2U ) ,@exprUNIQUE "\\\\"@exprUNIQUE ,@exprUNIQUE "\\"@exprUNIQUE ) ) ,@exprUNIQUE
711: std ::@expr2489 atol (@exprUNIQUE numtok@var399 .@exprUNIQUE str (@exprUNIQUE ) .@exprUNIQUE c_str (@exprUNIQUE ) ) ,@exprUNIQUE &@expr2497 location@var379 ) ;
712: }
713:
714: else { if ( lastline@var389 ==@exprUNIQUE "# endfile"@exprUNIQUE &&@exprUNIQUE !@exprUNIQUE loc@var376 .@exprUNIQUE empty (@exprUNIQUE ) ) {
715: location@var379 =@exprUNIQUE loc@var376 .@exprUNIQUE top (@exprUNIQUE ) ;
716: loc@var376 .@exprUNIQUE pop (@exprUNIQUE ) ;
717: } } } }
718: }
719:
720: continue ;
721: }
722:
723: if ( ch@var383 <=@exprUNIQUE ' '@expr2550 ) {
724: location@var379 .@expr2384 col@var382 ++@exprUNIQUE ;
725: continue ;
726: }
727:
728: std ::@exprUNIQUE string currentToken@var402 ;
729:
730: if ( cback (@expr2427 ) &&@exprUNIQUE cback (@expr2427 ) .@expr2432 location@var1325 .@expr2554 line@var1327 ==@expr2555 location@var379 .@expr2383 line@var381 &&@exprUNIQUE cback (@expr2427 ) .@expr2557 previous@var1328 &&@exprUNIQUE cback (@expr2427 ) .@expr2557 previous@var1328 .@exprUNIQUE op@var1329 ==@exprUNIQUE '#'@expr2560 ) {
731: const Token * const llTok@var403 ; llTok@var403 =@exprUNIQUE lastLineTok (@expr2564 ) ;
732: if ( llTok@var403 &&@exprUNIQUE llTok@var403 .@exprUNIQUE op@var404 ==@exprUNIQUE '#'@expr2560 &&@exprUNIQUE llTok@var403 .@expr2569 next@var405 &&@exprUNIQUE ( llTok@var403 .@expr2569 next@var405 .@expr2571 str (@expr2572 ) ==@exprUNIQUE "error"@exprUNIQUE ||@exprUNIQUE llTok@var403 .@expr2569 next@var405 .@expr2571 str (@expr2572 ) ==@exprUNIQUE "warning"@exprUNIQUE ) ) {
733: char prev@var406 ; prev@var406 = ' ' ;
734: while ( stream@var373 .@expr2386 good (@expr2387 ) &&@exprUNIQUE ( prev@var406 ==@exprUNIQUE '\\'@expr2429 ||@exprUNIQUE ( ch@var383 !=@exprUNIQUE '\r'@exprUNIQUE &&@exprUNIQUE ch@var383 !=@expr2582 '\n'@expr2424 ) ) ) {
735: currentToken@var402 +=@expr2586 ch@var383 ;
736: prev@var406 =@exprUNIQUE ch@var383 ;
737: ch@var383 =@expr2391 stream@var373 .@expr2389 readChar (@expr2390 ) ;
738: }
739: stream@var373 .@expr2589 ungetChar (@expr2590 ) ;
740: push_back (@exprUNIQUE new@exprUNIQUE Token (@exprUNIQUE currentToken@var402 ,@expr2592 location@var379 ) ) ;
741: location@var379 .@expr2597 adjust (@expr2598 currentToken@var402 ) ;
742: continue ;
743: }
744: }
745:
746:
747: if ( isNameChar (@expr2600 ch@var383 ) ) {
748: const bool num@var407 =@exprUNIQUE std ::@exprUNIQUE isdigit (@exprUNIQUE ch@var383 ) ;
749: while ( stream@var373 .@expr2386 good (@expr2387 ) &&@exprUNIQUE isNameChar (@expr2600 ch@var383 ) ) {
750: currentToken@var402 +=@expr2586 ch@var383 ;
751: ch@var383 =@expr2391 stream@var373 .@expr2389 readChar (@expr2390 ) ;
752: if ( num@var407 &&@exprUNIQUE ch@var383 ==@expr2607 '\''@expr2606 &&@exprUNIQUE isNameChar (@exprUNIQUE stream@var373 .@expr2610 peekChar (@expr2611 ) ) ) {
753: ch@var383 =@expr2391 stream@var373 .@expr2389 readChar (@expr2390 ) ; }
754: }
755:
756: stream@var373 .@expr2589 ungetChar (@expr2590 ) ;
757: }
758:
759:
760: else { if ( ch@var383 ==@expr2615 '/'@expr2614 &&@exprUNIQUE stream@var373 .@expr2610 peekChar (@expr2611 ) ==@exprUNIQUE '/'@expr2614 ) {
761: while ( stream@var373 .@expr2386 good (@expr2387 ) &&@exprUNIQUE ch@var383 !=@expr2582 '\n'@expr2424 ) {
762: currentToken@var402 +=@expr2586 ch@var383 ;
763: ch@var383 =@expr2391 stream@var373 .@expr2389 readChar (@expr2390 ) ;
764: if ( ch@var383 ==@exprUNIQUE '\\'@expr2429 ) {
765: std ::@exprUNIQUE string tmp@var408 ;
766: char tmp_ch@var409 ; tmp_ch@var409 =@exprUNIQUE ch@var383 ;
767: while ( ( stream@var373 .@expr2386 good (@expr2387 ) ) &&@exprUNIQUE ( tmp_ch@var409 ==@exprUNIQUE '\\'@expr2429 ||@exprUNIQUE tmp_ch@var409 ==@exprUNIQUE ' '@expr2550 ||@exprUNIQUE tmp_ch@var409 ==@exprUNIQUE '\t'@exprUNIQUE ) ) {
768: tmp@var408 +=@exprUNIQUE tmp_ch@var409 ;
769: tmp_ch@var409 =@expr2630 stream@var373 .@expr2389 readChar (@expr2390 ) ;
770: }
771: if ( !@expr2392 stream@var373 .@expr2386 good (@expr2387 ) ) {
772: break ;
773: }
774:
775: if ( tmp_ch@var409 !=@exprUNIQUE '\n'@expr2424 ) {
776: currentToken@var402 +=@exprUNIQUE tmp@var408 ;
777: } else {
778: const std :: string check_portability@var410 =@exprUNIQUE currentToken@var402 +@exprUNIQUE tmp@var408 ;
779: const std :: string :: size_type pos@var411 =@exprUNIQUE check_portability@var410 .@exprUNIQUE find_last_not_of (@exprUNIQUE " \t"@exprUNIQUE ) ;
780: if ( pos@var411 <@exprUNIQUE check_portability@var410 .@exprUNIQUE size (@exprUNIQUE ) -@exprUNIQUE 1U &&@exprUNIQUE check_portability@var410 [@exprUNIQUE pos@var411 ] ==@exprUNIQUE '\\'@expr2429 ) {
781: portabilityBackslash (@exprUNIQUE outputList@var375 ,@expr2438 files@var133 ,@exprUNIQUE location@var379 ) ; }
782: ++@exprUNIQUE multiline@var377 ;
783: tmp_ch@var409 =@expr2630 stream@var373 .@expr2389 readChar (@expr2390 ) ;
784: currentToken@var402 +=@exprUNIQUE '\n'@expr2424 ;
785: }
786: ch@var383 =@exprUNIQUE tmp_ch@var409 ;
787: }
788: }
789: if ( ch@var383 ==@expr2425 '\n'@expr2424 ) {
790: stream@var373 .@expr2589 ungetChar (@expr2590 ) ;
791: }
792: }
793:
794:
795: else { if ( ch@var383 ==@expr2615 '/'@expr2614 &&@exprUNIQUE stream@var373 .@expr2610 peekChar (@expr2611 ) ==@exprUNIQUE '*'@exprUNIQUE ) {
796: currentToken@var402 = "/*" ;
797: (@exprUNIQUE void ) stream@var373 .@expr2389 readChar (@expr2390 ) ;
798: ch@var383 =@expr2391 stream@var373 .@expr2389 readChar (@expr2390 ) ;
799: while ( stream@var373 .@expr2386 good (@expr2387 ) ) {
800: currentToken@var402 +=@expr2586 ch@var383 ;
801: if ( currentToken@var402 .@expr2656 size (@expr2657 ) >=@exprUNIQUE 4U &&@exprUNIQUE endsWith (@exprUNIQUE currentToken@var402 ,@exprUNIQUE COMMENT_END@var372 ) ) {
802: break ; }
803: ch@var383 =@expr2391 stream@var373 .@expr2389 readChar (@expr2390 ) ;
804: }
805:
806:
807: std ::@expr2665 string ::@exprUNIQUE size_type pos@var412 ; pos@var412 = 0 ;
808: while ( ( pos@var412 =@exprUNIQUE currentToken@var402 .@expr2668 find (@exprUNIQUE "\\\n"@exprUNIQUE ,@exprUNIQUE pos@var412 ) ) !=@exprUNIQUE std ::@expr2665 string ::@expr2676 npos ) {
809: currentToken@var402 .@expr2679 erase (@exprUNIQUE pos@var412 ,@exprUNIQUE 2 ) ;
810: ++@exprUNIQUE multiline@var377 ;
811: }
812: if ( multiline@var377 ||@exprUNIQUE isLastLinePreprocessor (@expr2453 ) ) {
813: pos@var412 = 0 ;
814: while ( ( pos@var412 =@exprUNIQUE currentToken@var402 .@expr2668 find (@exprUNIQUE '\n'@expr2424 ,@exprUNIQUE pos@var412 ) ) !=@exprUNIQUE std ::@expr2665 string ::@expr2676 npos ) {
815: currentToken@var402 .@expr2679 erase (@exprUNIQUE pos@var412 ,@exprUNIQUE 1 ) ;
816: ++@exprUNIQUE multiline@var377 ;
817: }
818: }
819: }
820:
821:
822: else { if ( ch@var383 ==@expr2694 '\"'@expr2693 ||@exprUNIQUE ch@var383 ==@expr2607 '\''@expr2606 ) {
823: std ::@exprUNIQUE string prefix@var413 ;
824: if ( cback (@expr2427 ) &&@exprUNIQUE cback (@expr2427 ) .@exprUNIQUE name@var1330 &&@exprUNIQUE isStringLiteralPrefix (@exprUNIQUE cback (@expr2427 ) .@expr2700 str (@expr2701 ) ) &&@exprUNIQUE
825: ( ( cback (@expr2427 ) .@expr2432 location@var1325 .@expr2433 col@var1326 +@exprUNIQUE cback (@expr2427 ) .@expr2700 str (@expr2701 ) .@exprUNIQUE size (@exprUNIQUE ) ) ==@exprUNIQUE location@var379 .@expr2384 col@var382 ) &&@exprUNIQUE
826: ( cback (@expr2427 ) .@expr2432 location@var1325 .@expr2554 line@var1327 ==@expr2555 location@var379 .@expr2383 line@var381 ) ) {
827: prefix@var413 =@exprUNIQUE cback (@expr2427 ) .@expr2700 str (@expr2701 ) ;
828: }
829:
830: if ( ch@var383 ==@expr2694 '\"'@expr2693 &&@exprUNIQUE !@exprUNIQUE prefix@var413 .@expr2711 empty (@expr2712 ) &&@exprUNIQUE *@exprUNIQUE cback (@expr2427 ) .@expr2700 str (@expr2701 ) .@exprUNIQUE rbegin (@exprUNIQUE ) ==@exprUNIQUE 'R'@exprUNIQUE ) {
831: std ::@exprUNIQUE string delim@var414 ;
832: currentToken@var402 =@exprUNIQUE ch@var383 ;
833: prefix@var413 .@exprUNIQUE resize (@exprUNIQUE prefix@var413 .@exprUNIQUE size (@exprUNIQUE ) -@exprUNIQUE 1 ) ;
834: ch@var383 =@expr2391 stream@var373 .@expr2389 readChar (@expr2390 ) ;
835: while ( stream@var373 .@expr2386 good (@expr2387 ) &&@exprUNIQUE ch@var383 !=@exprUNIQUE '('@exprUNIQUE &&@exprUNIQUE ch@var383 !=@expr2582 '\n'@expr2424 ) {
836: delim@var414 +=@exprUNIQUE ch@var383 ;
837: ch@var383 =@expr2391 stream@var373 .@expr2389 readChar (@expr2390 ) ;
838: }
839: if ( !@expr2392 stream@var373 .@expr2386 good (@expr2387 ) ||@exprUNIQUE ch@var383 ==@expr2425 '\n'@expr2424 ) {
840: if ( outputList@var375 ) {
841: Output err@var415 (@exprUNIQUE files@var133 ) ;
842: err@var415 .@exprUNIQUE type@var416 =@exprUNIQUE Output ::@expr2739 SYNTAX_ERROR ;
843: err@var415 .@exprUNIQUE location@var417 =@exprUNIQUE location@var379 ;
844: err@var415 .@exprUNIQUE msg@var418 = "Invalid newline in raw string delimiter." ;
845: outputList@var375 .@expr2420 push_back (@exprUNIQUE err@var415 ) ;
846: }
847: return ;
848: }
849: const std ::@exprUNIQUE string endOfRawString@var419 (@exprUNIQUE ')'@exprUNIQUE +@exprUNIQUE delim@var414 +@exprUNIQUE currentToken@var402 ) ;
850: while ( stream@var373 .@expr2386 good (@expr2387 ) &&@exprUNIQUE !@exprUNIQUE ( endsWith (@expr2751 currentToken@var402 ,@expr2750 endOfRawString@var419 ) &&@exprUNIQUE currentToken@var402 .@expr2656 size (@expr2657 ) >@exprUNIQUE 1 ) ) {
851: currentToken@var402 +=@exprUNIQUE stream@var373 .@expr2389 readChar (@expr2390 ) ; }
852: if ( !@exprUNIQUE endsWith (@expr2751 currentToken@var402 ,@expr2750 endOfRawString@var419 ) ) {
853: if ( outputList@var375 ) {
854: Output err@var420 (@exprUNIQUE files@var133 ) ;
855: err@var420 .@exprUNIQUE type@var421 =@exprUNIQUE Output ::@expr2739 SYNTAX_ERROR ;
856: err@var420 .@exprUNIQUE location@var422 =@exprUNIQUE location@var379 ;
857: err@var420 .@exprUNIQUE msg@var423 = "Raw string missing terminating delimiter." ;
858: outputList@var375 .@expr2420 push_back (@exprUNIQUE err@var420 ) ;
859: }
860: return ;
861: }
862: currentToken@var402 .@expr2679 erase (@exprUNIQUE currentToken@var402 .@expr2656 size (@expr2657 ) -@exprUNIQUE endOfRawString@var419 .@expr2765 size (@expr2766 ) ,@exprUNIQUE endOfRawString@var419 .@expr2765 size (@expr2766 ) -@exprUNIQUE 1U ) ;
863: currentToken@var402 =@exprUNIQUE escapeString (@exprUNIQUE currentToken@var402 ) ;
864: currentToken@var402 .@exprUNIQUE insert (@exprUNIQUE 0 ,@exprUNIQUE prefix@var413 ) ;
865: back (@expr2444 ) .@expr2780 setstr (@exprUNIQUE currentToken@var402 ) ;
866: location@var379 .@expr2597 adjust (@expr2598 currentToken@var402 ) ;
867: if ( currentToken@var402 .@exprUNIQUE find_first_of (@exprUNIQUE "\r\n"@expr2784 ) ==@exprUNIQUE std ::@expr2665 string ::@expr2676 npos ) {
868: location@var379 .@expr2384 col@var382 +=@exprUNIQUE 2 +@exprUNIQUE 2 *@exprUNIQUE delim@var414 .@expr2788 size (@expr2789 ) ; }
869: else {
870: location@var379 .@expr2384 col@var382 +=@exprUNIQUE 1 +@exprUNIQUE delim@var414 .@expr2788 size (@expr2789 ) ; }
871:
872: continue ;
873: }
874:
875: currentToken@var402 =@exprUNIQUE readUntil (@exprUNIQUE stream@var373 ,@expr2796 location@var379 ,@exprUNIQUE ch@var383 ,@exprUNIQUE ch@var383 ,@exprUNIQUE outputList@var375 ) ;
876: if ( currentToken@var402 .@expr2656 size (@expr2657 ) <@expr2802 2U ) {
877:
878: return ; }
879:
880: std ::@exprUNIQUE string s@var424 ; s@var424 =@exprUNIQUE currentToken@var402 ;
881: std ::@expr2665 string ::@exprUNIQUE size_type pos@var425 ;
882: int newlines@var426 ; newlines@var426 = 0 ;
883: while ( ( pos@var425 =@exprUNIQUE s@var424 .@exprUNIQUE find_first_of (@exprUNIQUE "\r\n"@expr2784 ) ) !=@exprUNIQUE std ::@expr2665 string ::@expr2676 npos ) {
884: s@var424 .@exprUNIQUE erase (@exprUNIQUE pos@var425 ,@exprUNIQUE 1 ) ;
885: newlines@var426 ++@exprUNIQUE ;
886: }
887:
888: if ( prefix@var413 .@expr2711 empty (@expr2712 ) ) {
889: push_back (@exprUNIQUE new@exprUNIQUE Token (@exprUNIQUE s@var424 ,@exprUNIQUE location@var379 ,@exprUNIQUE std ::@expr2817 isspace (@expr2818 stream@var373 .@expr2610 peekChar (@expr2611 ) ) ) ) ; }
890: else {
891: back (@expr2444 ) .@expr2780 setstr (@exprUNIQUE prefix@var413 +@exprUNIQUE s@var424 ) ; }
892:
893: if ( newlines@var426 >@exprUNIQUE 0 ) {
894: const Token * const llTok@var427 ; llTok@var427 =@exprUNIQUE lastLineTok (@expr2564 ) ;
895: if ( llTok@var427 &&@exprUNIQUE llTok@var427 .@exprUNIQUE op@var428 ==@exprUNIQUE '#'@expr2560 &&@exprUNIQUE llTok@var427 .@expr2830 next@var429 &&@exprUNIQUE ( llTok@var427 .@expr2830 next@var429 .@expr2832 str (@expr2833 ) ==@exprUNIQUE "define"@exprUNIQUE ||@exprUNIQUE llTok@var427 .@expr2830 next@var429 .@expr2832 str (@expr2833 ) ==@exprUNIQUE "pragma"@exprUNIQUE ) &&@exprUNIQUE llTok@var427 .@expr2830 next@var429 .@exprUNIQUE next@var430 ) {
896: multiline@var377 +=@exprUNIQUE newlines@var426 ;
897: location@var379 .@expr2597 adjust (@exprUNIQUE s@var424 ) ;
898: continue ;
899: }
900: }
901:
902: location@var379 .@expr2597 adjust (@expr2598 currentToken@var402 ) ;
903: continue ;
904: }
905:
906: else {
907: currentToken@var402 +=@expr2586 ch@var383 ;
908: } } } }
909:
910: if ( *@exprUNIQUE currentToken@var402 .@exprUNIQUE begin (@exprUNIQUE ) ==@exprUNIQUE '<'@expr2848 ) {
911: const Token * const llTok@var431 ; llTok@var431 =@exprUNIQUE lastLineTok (@expr2564 ) ;
912: if ( llTok@var431 &&@exprUNIQUE llTok@var431 .@exprUNIQUE op@var432 ==@exprUNIQUE '#'@expr2560 &&@exprUNIQUE llTok@var431 .@expr2854 next@var433 &&@exprUNIQUE llTok@var431 .@expr2854 next@var433 .@exprUNIQUE str (@exprUNIQUE ) ==@exprUNIQUE "include"@exprUNIQUE ) {
913: currentToken@var402 =@exprUNIQUE readUntil (@exprUNIQUE stream@var373 ,@expr2796 location@var379 ,@exprUNIQUE '<'@expr2848 ,@exprUNIQUE '>'@exprUNIQUE ,@exprUNIQUE outputList@var375 ) ;
914: if ( currentToken@var402 .@expr2656 size (@expr2657 ) <@expr2802 2U ) {
915: return ; }
916: }
917: }
918:
919: push_back (@exprUNIQUE new@exprUNIQUE Token (@exprUNIQUE currentToken@var402 ,@expr2592 location@var379 ,@exprUNIQUE std ::@expr2817 isspace (@expr2818 stream@var373 .@expr2610 peekChar (@expr2611 ) ) ) ) ;
920:
921: if ( multiline@var377 ) {
922: location@var379 .@expr2384 col@var382 +=@exprUNIQUE currentToken@var402 .@expr2656 size (@expr2657 ) ; }
923: else {
924: location@var379 .@expr2597 adjust (@expr2598 currentToken@var402 ) ; }
925: }
926:
927: combineOperators (@exprUNIQUE ) ;
928: }
929:
930: void simplecpp :: TokenList :: constFold ( )
931: {
932: while ( cfront (@exprUNIQUE ) ) {
933:
934: Token@exprUNIQUE *@exprUNIQUE tok@var434 ; tok@var434 =@exprUNIQUE back (@exprUNIQUE ) ;
935: while ( tok@var434 &&@exprUNIQUE tok@var434 .@expr2881 op@var435 !=@expr2883 '('@expr2882 ) {
936: tok@var434 =@exprUNIQUE tok@var434 .@expr2885 previous@var436 ; }
937:
938:
939: if ( !@exprUNIQUE tok@var434 ) {
940: tok@var434 =@exprUNIQUE front (@exprUNIQUE ) ; }
941:
942:
943: constFoldUnaryNotPosNeg (@exprUNIQUE tok@var434 ) ;
944: constFoldMulDivRem (@exprUNIQUE tok@var434 ) ;
945: constFoldAddSub (@exprUNIQUE tok@var434 ) ;
946: constFoldShift (@exprUNIQUE tok@var434 ) ;
947: constFoldComparison (@exprUNIQUE tok@var434 ) ;
948: constFoldBitwise (@exprUNIQUE tok@var434 ) ;
949: constFoldLogicalOp (@exprUNIQUE tok@var434 ) ;
950: constFoldQuestionOp (@exprUNIQUE &@exprUNIQUE tok@var434 ) ;
951:
952:
953: if ( tok@var434 .@expr2881 op@var435 !=@expr2883 '('@expr2882 ) {
954: break ; }
955:
956: if ( !@exprUNIQUE tok@var434 .@expr2908 next@var437 ||@exprUNIQUE !@exprUNIQUE tok@var434 .@expr2908 next@var437 .@expr2910 next@var438 ||@exprUNIQUE tok@var434 .@expr2908 next@var437 .@expr2910 next@var438 .@exprUNIQUE op@var439 !=@exprUNIQUE ')'@exprUNIQUE ) {
957: break ; }
958:
959: tok@var434 =@exprUNIQUE tok@var434 .@expr2908 next@var437 ;
960: deleteToken (@exprUNIQUE tok@var434 .@expr2885 previous@var436 ) ;
961: deleteToken (@exprUNIQUE tok@var434 .@expr2908 next@var437 ) ;
962: }
963: }
964:
965: static bool isFloatSuffix ( const simplecpp :: Token * tok@var440 )
966: {
967: if ( !@exprUNIQUE tok@var440 ||@exprUNIQUE tok@var440 .@expr2923 str (@expr2924 ) .@exprUNIQUE size (@exprUNIQUE ) !=@exprUNIQUE 1U ) {
968: return false@exprUNIQUE ; }
969: const char c@var441 =@exprUNIQUE std ::@exprUNIQUE tolower (@exprUNIQUE tok@var440 .@expr2923 str (@expr2924 ) [@exprUNIQUE 0 ] ) ;
970: return c@var441 ==@exprUNIQUE 'f'@exprUNIQUE ||@exprUNIQUE c@var441 ==@exprUNIQUE 'l'@exprUNIQUE ;
971: }
972:
973: void simplecpp :: TokenList :: combineOperators ( )
974: {
975: std ::@exprUNIQUE stack < bool > executableScope@var442 ;
976: executableScope@var442 .@expr2948 push (@exprUNIQUE false@exprUNIQUE ) ;
977: for ( Token * tok@var443 =@exprUNIQUE front (@exprUNIQUE ) ;@exprUNIQUE tok@var443 ;@exprUNIQUE tok@var443 =@exprUNIQUE tok@var443 .@expr2954 next@var444 ) {
978: if ( tok@var443 .@expr2958 op@var445 ==@exprUNIQUE '{'@exprUNIQUE ) {
979: if ( executableScope@var442 .@expr2962 top (@expr2963 ) ) {
980: executableScope@var442 .@expr2948 push (@exprUNIQUE true@exprUNIQUE ) ;
981: continue ;
982: }
983: const Token * prev@var446 ; prev@var446 =@exprUNIQUE tok@var443 .@expr2966 previous@var447 ;
984: while ( prev@var446 &&@exprUNIQUE prev@var446 .@exprUNIQUE isOneOf (@exprUNIQUE ";{}()"@exprUNIQUE ) ) {
985: prev@var446 =@exprUNIQUE prev@var446 .@exprUNIQUE previous@var448 ; }
986: executableScope@var442 .@expr2948 push (@exprUNIQUE prev@var446 &&@exprUNIQUE prev@var446 .@exprUNIQUE op@var449 ==@exprUNIQUE ')'@expr2976 ) ;
987: continue ;
988: }
989: if ( tok@var443 .@expr2958 op@var445 ==@exprUNIQUE '}'@exprUNIQUE ) {
990: if ( executableScope@var442 .@exprUNIQUE size (@exprUNIQUE ) >@exprUNIQUE 1 ) {
991: executableScope@var442 .@exprUNIQUE pop (@exprUNIQUE ) ; }
992: continue ;
993: }
994:
995: if ( tok@var443 .@expr2958 op@var445 ==@exprUNIQUE '.'@expr2990 ) {
996:
997: if ( tok@var443 .@expr2954 next@var444 &&@exprUNIQUE tok@var443 .@expr2954 next@var444 .@expr2992 op@var450 ==@exprUNIQUE '.'@expr2990 &&@exprUNIQUE tok@var443 .@expr2954 next@var444 .@expr2995 location@var451 .@expr2996 col@var452 ==@exprUNIQUE ( tok@var443 .@expr2997 location@var453 .@expr2998 col@var454 +@exprUNIQUE 1 ) &&@exprUNIQUE
998: tok@var443 .@expr2954 next@var444 .@expr3002 next@var455 &&@exprUNIQUE tok@var443 .@expr2954 next@var444 .@expr3002 next@var455 .@expr3004 op@var456 ==@exprUNIQUE '.'@expr2990 &&@exprUNIQUE tok@var443 .@expr2954 next@var444 .@expr3002 next@var455 .@exprUNIQUE location@var457 .@exprUNIQUE col@var458 ==@exprUNIQUE ( tok@var443 .@expr2997 location@var453 .@expr2998 col@var454 +@exprUNIQUE 2 ) ) {
999: tok@var443 .@expr3014 setstr (@exprUNIQUE "..."@exprUNIQUE ) ;
1000: deleteToken (@expr3018 tok@var443 .@expr2954 next@var444 ) ;
1001: deleteToken (@expr3018 tok@var443 .@expr2954 next@var444 ) ;
1002: continue ;
1003: }
1004:
1005: if ( tok@var443 .@expr2966 previous@var447 &&@expr3020 tok@var443 .@expr2966 previous@var447 .@expr3019 number@var459 &&@exprUNIQUE sameline (@exprUNIQUE tok@var443 .@expr2966 previous@var447 ,@exprUNIQUE tok@var443 ) &&@exprUNIQUE tok@var443 .@expr2966 previous@var447 .@expr3026 str (@expr3027 ) .@exprUNIQUE find_first_of (@exprUNIQUE "._"@exprUNIQUE ) ==@exprUNIQUE std ::@exprUNIQUE string ::@exprUNIQUE npos ) {
1006: tok@var443 .@expr3014 setstr (@exprUNIQUE tok@var443 .@expr2966 previous@var447 .@expr3026 str (@expr3027 ) +@exprUNIQUE '.'@expr2990 ) ;
1007: deleteToken (@exprUNIQUE tok@var443 .@expr2966 previous@var447 ) ;
1008: if ( sameline (@expr3045 tok@var443 ,@expr3044 tok@var443 .@expr2954 next@var444 ) &&@exprUNIQUE ( isFloatSuffix (@exprUNIQUE tok@var443 .@expr2954 next@var444 ) ||@exprUNIQUE ( tok@var443 .@expr2954 next@var444 &&@exprUNIQUE tok@var443 .@expr2954 next@var444 .@exprUNIQUE startsWithOneOf (@exprUNIQUE "AaBbCcDdEeFfPp"@exprUNIQUE ) ) ) ) {
1009: tok@var443 .@expr3014 setstr (@expr3060 tok@var443 .@expr3055 str (@expr3056 ) +@expr3059 tok@var443 .@expr2954 next@var444 .@expr3057 str (@expr3058 ) ) ;
1010: deleteToken (@expr3018 tok@var443 .@expr2954 next@var444 ) ;
1011: }
1012: }
1013: if ( tok@var443 .@expr2954 next@var444 &&@exprUNIQUE tok@var443 .@expr2954 next@var444 .@exprUNIQUE number@var460 ) {
1014: tok@var443 .@expr3014 setstr (@expr3060 tok@var443 .@expr3055 str (@expr3056 ) +@expr3059 tok@var443 .@expr2954 next@var444 .@expr3057 str (@expr3058 ) ) ;
1015: deleteToken (@expr3018 tok@var443 .@expr2954 next@var444 ) ;
1016: }
1017: }
1018:
1019: const char lastChar@var461 =@exprUNIQUE tok@var443 .@expr3055 str (@expr3056 ) [@exprUNIQUE tok@var443 .@expr3055 str (@expr3056 ) .@exprUNIQUE size (@exprUNIQUE ) -@exprUNIQUE 1 ] ;
1020: if ( tok@var443 .@exprUNIQUE number@var462 &&@exprUNIQUE !@exprUNIQUE isOct (@exprUNIQUE tok@var443 .@expr3055 str (@expr3056 ) ) &&@exprUNIQUE
1021: ( ( !@exprUNIQUE isHex (@expr3074 tok@var443 .@expr3055 str (@expr3056 ) ) &&@exprUNIQUE ( lastChar@var461 ==@exprUNIQUE 'E'@exprUNIQUE ||@exprUNIQUE lastChar@var461 ==@exprUNIQUE 'e'@exprUNIQUE ) ) ||@exprUNIQUE
1022: ( isHex (@expr3074 tok@var443 .@expr3055 str (@expr3056 ) ) &&@exprUNIQUE ( lastChar@var461 ==@exprUNIQUE 'P'@exprUNIQUE ||@exprUNIQUE lastChar@var461 ==@exprUNIQUE 'p'@exprUNIQUE ) ) ) &&@exprUNIQUE
1023: tok@var443 .@expr2954 next@var444 &&@exprUNIQUE tok@var443 .@expr2954 next@var444 .@exprUNIQUE isOneOf (@exprUNIQUE "+-"@exprUNIQUE ) &&@exprUNIQUE tok@var443 .@expr2954 next@var444 .@expr3002 next@var455 &&@exprUNIQUE tok@var443 .@expr2954 next@var444 .@expr3002 next@var455 .@expr3096 number@var463 ) {
1024: tok@var443 .@expr3014 setstr (@exprUNIQUE tok@var443 .@expr3055 str (@expr3056 ) +@exprUNIQUE tok@var443 .@expr2954 next@var444 .@expr2992 op@var450 +@exprUNIQUE tok@var443 .@expr2954 next@var444 .@expr3002 next@var455 .@exprUNIQUE str (@exprUNIQUE ) ) ;
1025: deleteToken (@expr3018 tok@var443 .@expr2954 next@var444 ) ;
1026: deleteToken (@expr3018 tok@var443 .@expr2954 next@var444 ) ;
1027: }
1028:
1029: if ( tok@var443 .@expr2958 op@var445 ==@exprUNIQUE '\0'@expr3103 ||@exprUNIQUE !@exprUNIQUE tok@var443 .@expr2954 next@var444 ||@exprUNIQUE tok@var443 .@expr2954 next@var444 .@expr2992 op@var450 ==@exprUNIQUE '\0'@expr3103 ) {
1030: continue ; }
1031: if ( !@exprUNIQUE sameline (@expr3045 tok@var443 ,@expr3044 tok@var443 .@expr2954 next@var444 ) ) {
1032: continue ; }
1033: if ( tok@var443 .@expr2997 location@var453 .@expr2998 col@var454 +@expr3111 1U !=@expr3112 tok@var443 .@expr2954 next@var444 .@expr2995 location@var451 .@expr2996 col@var452 ) {
1034: continue ; }
1035:
1036: if ( tok@var443 .@expr2954 next@var444 .@expr2992 op@var450 ==@expr3114 '='@expr3113 &&@exprUNIQUE tok@var443 .@exprUNIQUE isOneOf (@exprUNIQUE "=!<>+-*/%&|^"@exprUNIQUE ) ) {
1037: if ( tok@var443 .@expr2958 op@var445 ==@expr3120 '&'@expr3119 &&@exprUNIQUE !@exprUNIQUE executableScope@var442 .@expr2962 top (@expr2963 ) ) {
1038:
1039:
1040: int indentlevel@var464 ; indentlevel@var464 = 0 ;
1041: const Token * start@var465 ; start@var465 =@exprUNIQUE tok@var443 ;
1042: while ( indentlevel@var464 >=@exprUNIQUE 0 &&@exprUNIQUE start@var465 ) {
1043: if ( start@var465 .@expr3127 op@var466 ==@exprUNIQUE ')'@expr2976 ) {
1044: ++@exprUNIQUE indentlevel@var464 ; }
1045: else { if ( start@var465 .@expr3127 op@var466 ==@exprUNIQUE '('@exprUNIQUE ) {
1046: --@exprUNIQUE indentlevel@var464 ; }
1047: else { if ( start@var465 .@exprUNIQUE isOneOf (@exprUNIQUE ";{}"@exprUNIQUE ) ) {
1048: break ; } } }
1049: start@var465 =@expr3137 start@var465 .@expr3136 previous@var467 ;
1050: }
1051: if ( indentlevel@var464 ==@exprUNIQUE -1 &&@exprUNIQUE start@var465 ) {
1052: const Token * const ftok@var468 ; ftok@var468 =@exprUNIQUE start@var465 ;
1053: bool isFuncDecl@var469 ; isFuncDecl@var469 =@exprUNIQUE ftok@var468 .@exprUNIQUE name@var470 ;
1054: while ( isFuncDecl@var469 ) {
1055: if ( !@exprUNIQUE start@var465 .@expr3144 name@var471 &&@exprUNIQUE start@var465 .@exprUNIQUE str (@exprUNIQUE ) !=@exprUNIQUE "::"@exprUNIQUE &&@exprUNIQUE start@var465 .@expr3127 op@var466 !=@exprUNIQUE '*'@exprUNIQUE &&@exprUNIQUE start@var465 .@expr3127 op@var466 !=@exprUNIQUE '&'@expr3119 ) {
1056: isFuncDecl@var469 = false ; }
1057: if ( !@exprUNIQUE start@var465 .@expr3136 previous@var467 ) {
1058: break ; }
1059: if ( start@var465 .@expr3136 previous@var467 .@exprUNIQUE isOneOf (@exprUNIQUE ";{}:"@exprUNIQUE ) ) {
1060: break ; }
1061: start@var465 =@expr3137 start@var465 .@expr3136 previous@var467 ;
1062: }
1063: isFuncDecl@var469 &=@exprUNIQUE start@var465 !=@exprUNIQUE ftok@var468 &&@exprUNIQUE start@var465 .@expr3144 name@var471 ;
1064: if ( isFuncDecl@var469 ) {
1065:
1066: continue ;
1067: }
1068: }
1069: }
1070: tok@var443 .@expr3014 setstr (@exprUNIQUE tok@var443 .@expr3055 str (@expr3056 ) +@exprUNIQUE "="@exprUNIQUE ) ;
1071: deleteToken (@expr3018 tok@var443 .@expr2954 next@var444 ) ;
1072: } else { if ( ( tok@var443 .@expr2958 op@var445 ==@exprUNIQUE '|'@exprUNIQUE ||@exprUNIQUE tok@var443 .@expr2958 op@var445 ==@expr3120 '&'@expr3119 ) &&@exprUNIQUE tok@var443 .@expr2958 op@var445 ==@expr3169 tok@var443 .@expr2954 next@var444 .@expr2992 op@var450 ) {
1073: tok@var443 .@expr3014 setstr (@expr3060 tok@var443 .@expr3055 str (@expr3056 ) +@expr3059 tok@var443 .@expr2954 next@var444 .@expr3057 str (@expr3058 ) ) ;
1074: deleteToken (@expr3018 tok@var443 .@expr2954 next@var444 ) ;
1075: } else { if ( tok@var443 .@expr2958 op@var445 ==@exprUNIQUE ':'@expr3171 &&@exprUNIQUE tok@var443 .@expr2954 next@var444 .@expr2992 op@var450 ==@exprUNIQUE ':'@expr3171 ) {
1076: tok@var443 .@expr3014 setstr (@expr3060 tok@var443 .@expr3055 str (@expr3056 ) +@expr3059 tok@var443 .@expr2954 next@var444 .@expr3057 str (@expr3058 ) ) ;
1077: deleteToken (@expr3018 tok@var443 .@expr2954 next@var444 ) ;
1078: } else { if ( tok@var443 .@expr2958 op@var445 ==@expr3176 '-'@expr3175 &&@exprUNIQUE tok@var443 .@expr2954 next@var444 .@expr2992 op@var450 ==@exprUNIQUE '>'@expr3177 ) {
1079: tok@var443 .@expr3014 setstr (@expr3060 tok@var443 .@expr3055 str (@expr3056 ) +@expr3059 tok@var443 .@expr2954 next@var444 .@expr3057 str (@expr3058 ) ) ;
1080: deleteToken (@expr3018 tok@var443 .@expr2954 next@var444 ) ;
1081: } else { if ( ( tok@var443 .@expr2958 op@var445 ==@exprUNIQUE '<'@exprUNIQUE ||@exprUNIQUE tok@var443 .@expr2958 op@var445 ==@exprUNIQUE '>'@expr3177 ) &&@exprUNIQUE tok@var443 .@expr2958 op@var445 ==@expr3169 tok@var443 .@expr2954 next@var444 .@expr2992 op@var450 ) {
1082: tok@var443 .@expr3014 setstr (@expr3060 tok@var443 .@expr3055 str (@expr3056 ) +@expr3059 tok@var443 .@expr2954 next@var444 .@expr3057 str (@expr3058 ) ) ;
1083: deleteToken (@expr3018 tok@var443 .@expr2954 next@var444 ) ;
1084: if ( tok@var443 .@expr2954 next@var444 &&@exprUNIQUE tok@var443 .@expr2954 next@var444 .@expr2992 op@var450 ==@expr3114 '='@expr3113 &&@exprUNIQUE tok@var443 .@expr2954 next@var444 .@expr3002 next@var455 &&@exprUNIQUE tok@var443 .@expr2954 next@var444 .@expr3002 next@var455 .@expr3004 op@var456 !=@exprUNIQUE '='@expr3113 ) {
1085: tok@var443 .@expr3014 setstr (@expr3060 tok@var443 .@expr3055 str (@expr3056 ) +@expr3059 tok@var443 .@expr2954 next@var444 .@expr3057 str (@expr3058 ) ) ;
1086: deleteToken (@expr3018 tok@var443 .@expr2954 next@var444 ) ;
1087: }
1088: } else { if ( ( tok@var443 .@expr2958 op@var445 ==@exprUNIQUE '+'@exprUNIQUE ||@exprUNIQUE tok@var443 .@expr2958 op@var445 ==@expr3176 '-'@expr3175 ) &&@exprUNIQUE tok@var443 .@expr2958 op@var445 ==@expr3169 tok@var443 .@expr2954 next@var444 .@expr2992 op@var450 ) {
1089: if ( tok@var443 .@expr2997 location@var453 .@expr2998 col@var454 +@expr3111 1U !=@expr3112 tok@var443 .@expr2954 next@var444 .@expr2995 location@var451 .@expr2996 col@var452 ) {
1090: continue ; }
1091: if ( tok@var443 .@expr2966 previous@var447 &&@expr3020 tok@var443 .@expr2966 previous@var447 .@expr3019 number@var459 ) {
1092: continue ; }
1093: if ( tok@var443 .@expr2954 next@var444 .@expr3002 next@var455 &&@exprUNIQUE tok@var443 .@expr2954 next@var444 .@expr3002 next@var455 .@expr3096 number@var463 ) {
1094: continue ; }
1095: tok@var443 .@expr3014 setstr (@expr3060 tok@var443 .@expr3055 str (@expr3056 ) +@expr3059 tok@var443 .@expr2954 next@var444 .@expr3057 str (@expr3058 ) ) ;
1096: deleteToken (@expr3018 tok@var443 .@expr2954 next@var444 ) ;
1097: } } } } } }
1098: }
1099: }
1100:
1101: static const std :: string COMPL@var472 ( "compl" ) ;
1102: static const std :: string NOT@var473 ( "not" ) ;
1103: void simplecpp :: TokenList :: constFoldUnaryNotPosNeg ( simplecpp :: Token * tok@var474 )
1104: {
1105: for ( ;@exprUNIQUE tok@var474 &&@exprUNIQUE tok@var474 .@expr3194 op@var475 !=@exprUNIQUE ')'@exprUNIQUE ;@exprUNIQUE tok@var474 =@exprUNIQUE tok@var474 .@expr3198 next@var476 ) {
1106:
1107: if ( isAlternativeUnaryOp (@exprUNIQUE tok@var474 ,@exprUNIQUE NOT@var473 ) ) {
1108: tok@var474 .@expr3194 op@var475 = '!' ; }
1109:
1110: else { if ( isAlternativeUnaryOp (@exprUNIQUE tok@var474 ,@exprUNIQUE COMPL@var472 ) ) {
1111: tok@var474 .@expr3194 op@var475 = '~' ; } }
1112:
1113: if ( tok@var474 .@expr3194 op@var475 ==@exprUNIQUE '!'@exprUNIQUE &&@exprUNIQUE tok@var474 .@expr3198 next@var476 &&@exprUNIQUE tok@var474 .@expr3198 next@var476 .@expr3210 number@var477 ) {
1114: tok@var474 .@expr3213 setstr (@exprUNIQUE tok@var474 .@expr3198 next@var476 .@expr3215 str (@expr3216 ) ==@exprUNIQUE "0"@expr3217 ?@exprUNIQUE "1"@exprUNIQUE :@exprUNIQUE "0"@expr3217 ) ;
1115: deleteToken (@expr3224 tok@var474 .@expr3198 next@var476 ) ;
1116: } else { if ( tok@var474 .@expr3194 op@var475 ==@exprUNIQUE '~'@exprUNIQUE &&@exprUNIQUE tok@var474 .@expr3198 next@var476 &&@exprUNIQUE tok@var474 .@expr3198 next@var476 .@expr3210 number@var477 ) {
1117: tok@var474 .@expr3213 setstr (@exprUNIQUE toString (@exprUNIQUE ~@exprUNIQUE stringToLL (@exprUNIQUE tok@var474 .@expr3198 next@var476 .@expr3215 str (@expr3216 ) ) ) ) ;
1118: deleteToken (@expr3224 tok@var474 .@expr3198 next@var476 ) ;
1119: } else {
1120: if ( tok@var474 .@expr3235 previous@var478 &&@exprUNIQUE ( tok@var474 .@expr3235 previous@var478 .@exprUNIQUE number@var479 ||@exprUNIQUE tok@var474 .@expr3235 previous@var478 .@exprUNIQUE name@var480 ) ) {
1121: continue ; }
1122: if ( !@exprUNIQUE tok@var474 .@expr3198 next@var476 ||@exprUNIQUE !@exprUNIQUE tok@var474 .@expr3198 next@var476 .@expr3210 number@var477 ) {
1123: continue ; }
1124: switch ( tok@var474 .@expr3194 op@var475 ) {
1125: case '+'@exprUNIQUE : ;
1126: tok@var474 .@expr3213 setstr (@exprUNIQUE tok@var474 .@expr3198 next@var476 .@expr3215 str (@expr3216 ) ) ;
1127: deleteToken (@expr3224 tok@var474 .@expr3198 next@var476 ) ;
1128: break ;
1129: case '-'@exprUNIQUE : ;
1130: tok@var474 .@expr3213 setstr (@exprUNIQUE tok@var474 .@expr3194 op@var475 +@exprUNIQUE tok@var474 .@expr3198 next@var476 .@expr3215 str (@expr3216 ) ) ;
1131: deleteToken (@expr3224 tok@var474 .@expr3198 next@var476 ) ;
1132: break ;
1133: }
1134: } }
1135: }
1136: }
1137:
1138: void simplecpp :: TokenList :: constFoldMulDivRem ( Token * tok@var481 )
1139: {
1140: for ( ;@exprUNIQUE tok@var481 &&@exprUNIQUE tok@var481 .@expr3248 op@var482 !=@exprUNIQUE ')'@exprUNIQUE ;@exprUNIQUE tok@var481 =@exprUNIQUE tok@var481 .@expr3252 next@var483 ) {
1141: if ( !@exprUNIQUE tok@var481 .@expr3256 previous@var484 ||@exprUNIQUE !@exprUNIQUE tok@var481 .@expr3256 previous@var484 .@exprUNIQUE number@var485 ) {
1142: continue ; }
1143: if ( !@exprUNIQUE tok@var481 .@expr3252 next@var483 ||@exprUNIQUE !@exprUNIQUE tok@var481 .@expr3252 next@var483 .@exprUNIQUE number@var486 ) {
1144: continue ; }
1145:
1146: long long result@var487 ;
1147: if ( tok@var481 .@expr3248 op@var482 ==@exprUNIQUE '*'@exprUNIQUE ) {
1148: result@var487 =@exprUNIQUE stringToLL (@expr3271 tok@var481 .@expr3256 previous@var484 .@expr3269 str (@expr3270 ) ) *@exprUNIQUE stringToLL (@expr3274 tok@var481 .@expr3252 next@var483 .@expr3272 str (@expr3273 ) ) ; }
1149: else { if ( tok@var481 .@expr3248 op@var482 ==@expr3278 '/'@expr3277 ||@exprUNIQUE tok@var481 .@expr3248 op@var482 ==@exprUNIQUE '%'@exprUNIQUE ) {
1150: const long long rhs@var488 =@exprUNIQUE stringToLL (@expr3274 tok@var481 .@expr3252 next@var483 .@expr3272 str (@expr3273 ) ) ;
1151: if ( rhs@var488 ==@exprUNIQUE 0 ) {
1152: throw@exprUNIQUE std ::@expr3287 overflow_error (@exprUNIQUE "division/modulo by zero"@exprUNIQUE ) ; }
1153: const long long lhs@var489 =@exprUNIQUE stringToLL (@expr3271 tok@var481 .@expr3256 previous@var484 .@expr3269 str (@expr3270 ) ) ;
1154: if ( rhs@var488 ==@exprUNIQUE -1 &&@exprUNIQUE lhs@var489 ==@exprUNIQUE std ::@exprUNIQUE numeric_limits < long long > ::@exprUNIQUE min (@exprUNIQUE ) ) {
1155: throw@exprUNIQUE std ::@expr3287 overflow_error (@exprUNIQUE "division overflow"@exprUNIQUE ) ; }
1156: if ( tok@var481 .@expr3248 op@var482 ==@expr3278 '/'@expr3277 ) {
1157: result@var487 =@exprUNIQUE lhs@var489 /@exprUNIQUE rhs@var488 ; }
1158: else {
1159: result@var487 =@exprUNIQUE lhs@var489 %@exprUNIQUE rhs@var488 ; }
1160: } else {
1161: continue ; } }
1162:
1163: tok@var481 =@exprUNIQUE tok@var481 .@expr3256 previous@var484 ;
1164: tok@var481 .@exprUNIQUE setstr (@exprUNIQUE toString (@exprUNIQUE result@var487 ) ) ;
1165: deleteToken (@expr3315 tok@var481 .@expr3252 next@var483 ) ;
1166: deleteToken (@expr3315 tok@var481 .@expr3252 next@var483 ) ;
1167: }
1168: }
1169:
1170: void simplecpp :: TokenList :: constFoldAddSub ( Token * tok@var490 )
1171: {
1172: for ( ;@exprUNIQUE tok@var490 &&@exprUNIQUE tok@var490 .@expr3316 op@var491 !=@exprUNIQUE ')'@exprUNIQUE ;@exprUNIQUE tok@var490 =@exprUNIQUE tok@var490 .@expr3320 next@var492 ) {
1173: if ( !@exprUNIQUE tok@var490 .@expr3324 previous@var493 ||@exprUNIQUE !@exprUNIQUE tok@var490 .@expr3324 previous@var493 .@exprUNIQUE number@var494 ) {
1174: continue ; }
1175: if ( !@exprUNIQUE tok@var490 .@expr3320 next@var492 ||@exprUNIQUE !@exprUNIQUE tok@var490 .@expr3320 next@var492 .@exprUNIQUE number@var495 ) {
1176: continue ; }
1177:
1178: long long result@var496 ;
1179: if ( tok@var490 .@expr3316 op@var491 ==@exprUNIQUE '+'@exprUNIQUE ) {
1180: result@var496 =@exprUNIQUE stringToLL (@expr3339 tok@var490 .@expr3324 previous@var493 .@expr3337 str (@expr3338 ) ) +@exprUNIQUE stringToLL (@expr3342 tok@var490 .@expr3320 next@var492 .@expr3340 str (@expr3341 ) ) ; }
1181: else { if ( tok@var490 .@expr3316 op@var491 ==@exprUNIQUE '-'@exprUNIQUE ) {
1182: result@var496 =@exprUNIQUE stringToLL (@expr3339 tok@var490 .@expr3324 previous@var493 .@expr3337 str (@expr3338 ) ) -@exprUNIQUE stringToLL (@expr3342 tok@var490 .@expr3320 next@var492 .@expr3340 str (@expr3341 ) ) ; }
1183: else {
1184: continue ; } }
1185:
1186: tok@var490 =@exprUNIQUE tok@var490 .@expr3324 previous@var493 ;
1187: tok@var490 .@exprUNIQUE setstr (@exprUNIQUE toString (@exprUNIQUE result@var496 ) ) ;
1188: deleteToken (@expr3356 tok@var490 .@expr3320 next@var492 ) ;
1189: deleteToken (@expr3356 tok@var490 .@expr3320 next@var492 ) ;
1190: }
1191: }
1192:
1193: void simplecpp :: TokenList :: constFoldShift ( Token * tok@var497 )
1194: {
1195: for ( ;@exprUNIQUE tok@var497 &&@exprUNIQUE tok@var497 .@exprUNIQUE op@var498 !=@exprUNIQUE ')'@exprUNIQUE ;@exprUNIQUE tok@var497 =@exprUNIQUE tok@var497 .@expr3361 next@var499 ) {
1196: if ( !@exprUNIQUE tok@var497 .@expr3365 previous@var500 ||@exprUNIQUE !@exprUNIQUE tok@var497 .@expr3365 previous@var500 .@exprUNIQUE number@var501 ) {
1197: continue ; }
1198: if ( !@exprUNIQUE tok@var497 .@expr3361 next@var499 ||@exprUNIQUE !@exprUNIQUE tok@var497 .@expr3361 next@var499 .@exprUNIQUE number@var502 ) {
1199: continue ; }
1200:
1201: long long result@var503 ;
1202: if ( tok@var497 .@expr3375 str (@expr3376 ) ==@exprUNIQUE "<<"@exprUNIQUE ) {
1203: result@var503 =@exprUNIQUE stringToLL (@expr3382 tok@var497 .@expr3365 previous@var500 .@expr3380 str (@expr3381 ) ) <<@exprUNIQUE stringToLL (@expr3385 tok@var497 .@expr3361 next@var499 .@expr3383 str (@expr3384 ) ) ; }
1204: else { if ( tok@var497 .@expr3375 str (@expr3376 ) ==@exprUNIQUE ">>"@exprUNIQUE ) {
1205: result@var503 =@exprUNIQUE stringToLL (@expr3382 tok@var497 .@expr3365 previous@var500 .@expr3380 str (@expr3381 ) ) >>@exprUNIQUE stringToLL (@expr3385 tok@var497 .@expr3361 next@var499 .@expr3383 str (@expr3384 ) ) ; }
1206: else {
1207: continue ; } }
1208:
1209: tok@var497 =@exprUNIQUE tok@var497 .@expr3365 previous@var500 ;
1210: tok@var497 .@exprUNIQUE setstr (@exprUNIQUE toString (@exprUNIQUE result@var503 ) ) ;
1211: deleteToken (@expr3399 tok@var497 .@expr3361 next@var499 ) ;
1212: deleteToken (@expr3399 tok@var497 .@expr3361 next@var499 ) ;
1213: }
1214: }
1215:
1216: static const std :: string NOTEQ@var504 ( "not_eq" ) ;
1217: void simplecpp :: TokenList :: constFoldComparison ( Token * tok@var505 )
1218: {
1219: for ( ;@exprUNIQUE tok@var505 &&@exprUNIQUE tok@var505 .@exprUNIQUE op@var506 !=@exprUNIQUE ')'@exprUNIQUE ;@exprUNIQUE tok@var505 =@exprUNIQUE tok@var505 .@expr3404 next@var507 ) {
1220: if ( isAlternativeBinaryOp (@exprUNIQUE tok@var505 ,@exprUNIQUE NOTEQ@var504 ) ) {
1221: tok@var505 .@expr3412 setstr (@exprUNIQUE "!="@expr3413 ) ; }
1222:
1223: if ( !@exprUNIQUE tok@var505 .@exprUNIQUE startsWithOneOf (@exprUNIQUE "<>=!"@exprUNIQUE ) ) {
1224: continue ; }
1225: if ( !@exprUNIQUE tok@var505 .@expr3420 previous@var508 ||@exprUNIQUE !@exprUNIQUE tok@var505 .@expr3420 previous@var508 .@exprUNIQUE number@var509 ) {
1226: continue ; }
1227: if ( !@exprUNIQUE tok@var505 .@expr3404 next@var507 ||@exprUNIQUE !@exprUNIQUE tok@var505 .@expr3404 next@var507 .@exprUNIQUE number@var510 ) {
1228: continue ; }
1229:
1230: int result@var511 ;
1231: if ( tok@var505 .@expr3430 str (@expr3431 ) ==@exprUNIQUE "=="@exprUNIQUE ) {
1232: result@var511 =@exprUNIQUE stringToLL (@expr3437 tok@var505 .@expr3420 previous@var508 .@expr3435 str (@expr3436 ) ) ==@exprUNIQUE stringToLL (@expr3440 tok@var505 .@expr3404 next@var507 .@expr3438 str (@expr3439 ) ) ; }
1233: else { if ( tok@var505 .@expr3430 str (@expr3431 ) ==@exprUNIQUE "!="@expr3413 ) {
1234: result@var511 =@exprUNIQUE stringToLL (@expr3437 tok@var505 .@expr3420 previous@var508 .@expr3435 str (@expr3436 ) ) !=@exprUNIQUE stringToLL (@expr3440 tok@var505 .@expr3404 next@var507 .@expr3438 str (@expr3439 ) ) ; }
1235: else { if ( tok@var505 .@expr3430 str (@expr3431 ) ==@exprUNIQUE ">"@exprUNIQUE ) {
1236: result@var511 =@exprUNIQUE stringToLL (@expr3437 tok@var505 .@expr3420 previous@var508 .@expr3435 str (@expr3436 ) ) >@exprUNIQUE stringToLL (@expr3440 tok@var505 .@expr3404 next@var507 .@expr3438 str (@expr3439 ) ) ; }
1237: else { if ( tok@var505 .@expr3430 str (@expr3431 ) ==@exprUNIQUE ">="@exprUNIQUE ) {
1238: result@var511 =@exprUNIQUE stringToLL (@expr3437 tok@var505 .@expr3420 previous@var508 .@expr3435 str (@expr3436 ) ) >=@exprUNIQUE stringToLL (@expr3440 tok@var505 .@expr3404 next@var507 .@expr3438 str (@expr3439 ) ) ; }
1239: else { if ( tok@var505 .@expr3430 str (@expr3431 ) ==@exprUNIQUE "<"@exprUNIQUE ) {
1240: result@var511 =@exprUNIQUE stringToLL (@expr3437 tok@var505 .@expr3420 previous@var508 .@expr3435 str (@expr3436 ) ) <@exprUNIQUE stringToLL (@expr3440 tok@var505 .@expr3404 next@var507 .@expr3438 str (@expr3439 ) ) ; }
1241: else { if ( tok@var505 .@expr3430 str (@expr3431 ) ==@exprUNIQUE "<="@exprUNIQUE ) {
1242: result@var511 =@exprUNIQUE stringToLL (@expr3437 tok@var505 .@expr3420 previous@var508 .@expr3435 str (@expr3436 ) ) <=@exprUNIQUE stringToLL (@expr3440 tok@var505 .@expr3404 next@var507 .@expr3438 str (@expr3439 ) ) ; }
1243: else {
1244: continue ; } } } } } }
1245:
1246: tok@var505 =@exprUNIQUE tok@var505 .@expr3420 previous@var508 ;
1247: tok@var505 .@expr3412 setstr (@exprUNIQUE toString (@exprUNIQUE result@var511 ) ) ;
1248: deleteToken (@expr3467 tok@var505 .@expr3404 next@var507 ) ;
1249: deleteToken (@expr3467 tok@var505 .@expr3404 next@var507 ) ;
1250: }
1251: }
1252:
1253: static const std :: string BITAND@var512 ( "bitand" ) ;
1254: static const std :: string BITOR@var513 ( "bitor" ) ;
1255: static const std :: string XOR@var514 ( "xor" ) ;
1256: void simplecpp :: TokenList :: constFoldBitwise ( Token * tok@var515 )
1257: {
1258: Token * const tok1@var516 ; tok1@var516 =@exprUNIQUE tok@var515 ;
1259: for ( const char * op@var517 = "&^|" ; *@expr3469 op@var517 ;@exprUNIQUE op@var517 ++@exprUNIQUE ) {
1260: const std ::@exprUNIQUE string *@exprUNIQUE alternativeOp@var518 ;
1261: if ( *@expr3469 op@var517 ==@expr3477 '&'@expr3476 ) {
1262: alternativeOp@var518 =@exprUNIQUE &@exprUNIQUE BITAND@var512 ; }
1263: else { if ( *@expr3469 op@var517 ==@exprUNIQUE '|'@exprUNIQUE ) {
1264: alternativeOp@var518 =@exprUNIQUE &@exprUNIQUE BITOR@var513 ; }
1265: else {
1266: alternativeOp@var518 =@exprUNIQUE &@exprUNIQUE XOR@var514 ; } }
1267: for ( tok@var515 =@exprUNIQUE tok1@var516 ;@exprUNIQUE tok@var515 &&@exprUNIQUE tok@var515 .@expr3487 op@var519 !=@exprUNIQUE ')'@exprUNIQUE ;@exprUNIQUE tok@var515 =@exprUNIQUE tok@var515 .@expr3491 next@var520 ) {
1268: if ( tok@var515 .@expr3487 op@var519 !=@exprUNIQUE *@expr3469 op@var517 &&@exprUNIQUE !@exprUNIQUE isAlternativeBinaryOp (@exprUNIQUE tok@var515 ,@exprUNIQUE *@exprUNIQUE alternativeOp@var518 ) ) {
1269: continue ; }
1270: if ( !@exprUNIQUE tok@var515 .@expr3502 previous@var521 ||@exprUNIQUE !@exprUNIQUE tok@var515 .@expr3502 previous@var521 .@exprUNIQUE number@var522 ) {
1271: continue ; }
1272: if ( !@exprUNIQUE tok@var515 .@expr3491 next@var520 ||@exprUNIQUE !@exprUNIQUE tok@var515 .@expr3491 next@var520 .@exprUNIQUE number@var523 ) {
1273: continue ; }
1274: long long result@var524 ;
1275: if ( *@expr3469 op@var517 ==@expr3477 '&'@expr3476 ) {
1276: result@var524 =@exprUNIQUE stringToLL (@expr3515 tok@var515 .@expr3502 previous@var521 .@expr3513 str (@expr3514 ) ) &@exprUNIQUE stringToLL (@expr3518 tok@var515 .@expr3491 next@var520 .@expr3516 str (@expr3517 ) ) ; }
1277: else { if ( *@expr3469 op@var517 ==@exprUNIQUE '^'@exprUNIQUE ) {
1278: result@var524 =@exprUNIQUE stringToLL (@expr3515 tok@var515 .@expr3502 previous@var521 .@expr3513 str (@expr3514 ) ) ^@exprUNIQUE stringToLL (@expr3518 tok@var515 .@expr3491 next@var520 .@expr3516 str (@expr3517 ) ) ; }
1279: else {
1280: result@var524 =@exprUNIQUE stringToLL (@expr3515 tok@var515 .@expr3502 previous@var521 .@expr3513 str (@expr3514 ) ) |@exprUNIQUE stringToLL (@expr3518 tok@var515 .@expr3491 next@var520 .@expr3516 str (@expr3517 ) ) ; } }
1281: tok@var515 =@exprUNIQUE tok@var515 .@expr3502 previous@var521 ;
1282: tok@var515 .@exprUNIQUE setstr (@exprUNIQUE toString (@exprUNIQUE result@var524 ) ) ;
1283: deleteToken (@expr3534 tok@var515 .@expr3491 next@var520 ) ;
1284: deleteToken (@expr3534 tok@var515 .@expr3491 next@var520 ) ;
1285: }
1286: }
1287: }
1288:
1289: static const std :: string AND@var525 ( "and" ) ;
1290: static const std :: string OR@var526 ( "or" ) ;
1291: void simplecpp :: TokenList :: constFoldLogicalOp ( Token * tok@var527 )
1292: {
1293: for ( ;@exprUNIQUE tok@var527 &&@exprUNIQUE tok@var527 .@exprUNIQUE op@var528 !=@exprUNIQUE ')'@exprUNIQUE ;@exprUNIQUE tok@var527 =@exprUNIQUE tok@var527 .@expr3539 next@var529 ) {
1294: if ( tok@var527 .@exprUNIQUE name@var530 ) {
1295: if ( isAlternativeBinaryOp (@exprUNIQUE tok@var527 ,@exprUNIQUE AND@var525 ) ) {
1296: tok@var527 .@expr3548 setstr (@exprUNIQUE "&&"@expr3549 ) ; }
1297: else { if ( isAlternativeBinaryOp (@exprUNIQUE tok@var527 ,@exprUNIQUE OR@var526 ) ) {
1298: tok@var527 .@expr3548 setstr (@exprUNIQUE "||"@expr3553 ) ; } }
1299: }
1300: if ( tok@var527 .@expr3556 str (@expr3557 ) !=@exprUNIQUE "&&"@expr3549 &&@exprUNIQUE tok@var527 .@expr3556 str (@expr3557 ) !=@exprUNIQUE "||"@expr3553 ) {
1301: continue ; }
1302: if ( !@exprUNIQUE tok@var527 .@expr3561 previous@var531 ||@exprUNIQUE !@exprUNIQUE tok@var527 .@expr3561 previous@var531 .@exprUNIQUE number@var532 ) {
1303: continue ; }
1304: if ( !@exprUNIQUE tok@var527 .@expr3539 next@var529 ||@exprUNIQUE !@exprUNIQUE tok@var527 .@expr3539 next@var529 .@exprUNIQUE number@var533 ) {
1305: continue ; }
1306:
1307: int result@var534 ;
1308: if ( tok@var527 .@expr3556 str (@expr3557 ) ==@exprUNIQUE "||"@expr3553 ) {
1309: result@var534 =@exprUNIQUE stringToLL (@expr3574 tok@var527 .@expr3561 previous@var531 .@expr3572 str (@expr3573 ) ) ||@exprUNIQUE stringToLL (@expr3577 tok@var527 .@expr3539 next@var529 .@expr3575 str (@expr3576 ) ) ; }
1310: else {
1311: result@var534 =@exprUNIQUE stringToLL (@expr3574 tok@var527 .@expr3561 previous@var531 .@expr3572 str (@expr3573 ) ) &&@exprUNIQUE stringToLL (@expr3577 tok@var527 .@expr3539 next@var529 .@expr3575 str (@expr3576 ) ) ; }
1312:
1313: tok@var527 =@exprUNIQUE tok@var527 .@expr3561 previous@var531 ;
1314: tok@var527 .@expr3548 setstr (@exprUNIQUE toString (@exprUNIQUE result@var534 ) ) ;
1315: deleteToken (@expr3587 tok@var527 .@expr3539 next@var529 ) ;
1316: deleteToken (@expr3587 tok@var527 .@expr3539 next@var529 ) ;
1317: }
1318: }
1319:
1320: void simplecpp :: TokenList :: constFoldQuestionOp ( Token * * tok1@var535 )
1321: {
1322: bool gotoTok1@var536 ; gotoTok1@var536 = false ;
1323: for ( Token * tok@var537 =@expr3589 *@expr3588 tok1@var535 ;@exprUNIQUE tok@var537 &&@exprUNIQUE tok@var537 .@exprUNIQUE op@var538 !=@exprUNIQUE ')'@exprUNIQUE ;@exprUNIQUE tok@var537 =@expr3589 gotoTok1@var536 ?@exprUNIQUE *@expr3588 tok1@var535 :@exprUNIQUE tok@var537 .@expr3594 next@var539 ) {
1324: gotoTok1@var536 = false ;
1325: if ( tok@var537 .@exprUNIQUE str (@exprUNIQUE ) !=@exprUNIQUE "?"@exprUNIQUE ) {
1326: continue ; }
1327: if ( !@exprUNIQUE tok@var537 .@expr3604 previous@var540 ||@exprUNIQUE !@exprUNIQUE tok@var537 .@expr3594 next@var539 ||@exprUNIQUE !@exprUNIQUE tok@var537 .@expr3594 next@var539 .@expr3608 next@var541 ) {
1328: throw@expr3616 std ::@expr3613 runtime_error (@expr3615 "invalid expression"@expr3614 ) ; }
1329: if ( !@exprUNIQUE tok@var537 .@expr3604 previous@var540 .@exprUNIQUE number@var542 ) {
1330: continue ; }
1331: if ( tok@var537 .@expr3594 next@var539 .@expr3608 next@var541 .@exprUNIQUE op@var543 !=@exprUNIQUE ':'@exprUNIQUE ) {
1332: continue ; }
1333: Token * const condTok@var544 ; condTok@var544 =@exprUNIQUE tok@var537 .@expr3604 previous@var540 ;
1334: Token * const trueTok@var545 ; trueTok@var545 =@exprUNIQUE tok@var537 .@expr3594 next@var539 ;
1335: Token * const falseTok@var546 ; falseTok@var546 =@exprUNIQUE trueTok@var545 .@expr3624 next@var547 .@exprUNIQUE next@var548 ;
1336: if ( !@exprUNIQUE falseTok@var546 ) {
1337: throw@expr3616 std ::@expr3613 runtime_error (@expr3615 "invalid expression"@expr3614 ) ; }
1338: if ( condTok@var544 ==@exprUNIQUE *@expr3588 tok1@var535 ) {
1339: *@expr3588 tok1@var535 =@exprUNIQUE condTok@var544 .@expr3629 str (@expr3630 ) !=@exprUNIQUE "0"@expr3631 ?@exprUNIQUE trueTok@var545 :@expr3633 falseTok@var546 ; }
1340: deleteToken (@exprUNIQUE condTok@var544 .@exprUNIQUE next@var549 ) ;
1341: deleteToken (@exprUNIQUE trueTok@var545 .@expr3624 next@var547 ) ;
1342: deleteToken (@exprUNIQUE condTok@var544 .@expr3629 str (@expr3630 ) ==@exprUNIQUE "0"@expr3631 ?@exprUNIQUE trueTok@var545 :@expr3633 falseTok@var546 ) ;
1343: deleteToken (@exprUNIQUE condTok@var544 ) ;
1344: gotoTok1@var536 = true ;
1345: }
1346: }
1347:
1348: void simplecpp :: TokenList :: removeComments ( )
1349: {
1350: Token@exprUNIQUE *@exprUNIQUE tok@var550 ; tok@var550 =@exprUNIQUE frontToken@var131 ;
1351: while ( tok@var550 ) {
1352: Token * const tok1@var551 ; tok1@var551 =@exprUNIQUE tok@var550 ;
1353: tok@var550 =@exprUNIQUE tok@var550 .@exprUNIQUE next@var552 ;
1354: if ( tok1@var551 .@exprUNIQUE comment@var553 ) {
1355: deleteToken (@exprUNIQUE tok1@var551 ) ; }
1356: }
1357: }
1358:
1359: std :: string simplecpp :: TokenList :: readUntil ( Stream & stream@var554 , const Location & location@var555 , const char start@var556 , const char end@var557 , std :: list < Output > * outputList@var558 )
1360: {
1361: std ::@exprUNIQUE string ret@var559 ;
1362: ret@var559 +=@exprUNIQUE start@var556 ;
1363:
1364: bool backslash@var560 ; backslash@var560 = false ;
1365: char ch@var561 ; ch@var561 = 0 ;
1366: while ( ch@var561 !=@expr3656 end@var557 &&@exprUNIQUE ch@var561 !=@exprUNIQUE '\r'@expr3657 &&@exprUNIQUE ch@var561 !=@exprUNIQUE '\n'@expr3660 &&@exprUNIQUE stream@var554 .@expr3664 good (@expr3665 ) ) {
1367: ch@var561 =@exprUNIQUE stream@var554 .@expr3668 readChar (@expr3669 ) ;
1368: if ( backslash@var560 &&@exprUNIQUE ch@var561 ==@exprUNIQUE '\n'@expr3660 ) {
1369: ch@var561 = 0 ;
1370: backslash@var560 = false ;
1371: continue ;
1372: }
1373: backslash@var560 = false ;
1374: ret@var559 +=@exprUNIQUE ch@var561 ;
1375: if ( ch@var561 ==@exprUNIQUE '\\'@expr3674 ) {
1376: bool update_ch@var562 ; update_ch@var562 = false ;
1377: char next@var563 ; next@var563 = 0 ;
1378: do {
1379: next@var563 =@exprUNIQUE stream@var554 .@expr3668 readChar (@expr3669 ) ;
1380: if ( next@var563 ==@expr3677 '\r'@expr3657 ||@exprUNIQUE next@var563 ==@exprUNIQUE '\n'@expr3660 ) {
1381: ret@var559 .@exprUNIQUE erase (@exprUNIQUE ret@var559 .@exprUNIQUE size (@exprUNIQUE ) -@exprUNIQUE 1U ) ;
1382: backslash@var560 =@exprUNIQUE next@var563 ==@expr3677 '\r'@expr3657 ;
1383: update_ch@var562 = false ;
1384: } else { if ( next@var563 ==@expr3689 '\\'@expr3674 ) {
1385: update_ch@var562 =@exprUNIQUE !@exprUNIQUE update_ch@var562 ; } }
1386: ret@var559 +=@exprUNIQUE next@var563 ;
1387: } while ( next@var563 ==@expr3689 '\\'@expr3674 ) ;
1388: if ( update_ch@var562 ) {
1389: ch@var561 =@exprUNIQUE next@var563 ; }
1390: }
1391: }
1392:
1393: if ( !@exprUNIQUE stream@var554 .@expr3664 good (@expr3665 ) ||@exprUNIQUE ch@var561 !=@expr3656 end@var557 ) {
1394: clear (@exprUNIQUE ) ;
1395: if ( outputList@var558 ) {
1396: Output err@var564 (@exprUNIQUE files@var133 ) ;
1397: err@var564 .@exprUNIQUE type@var565 =@exprUNIQUE Output ::@exprUNIQUE SYNTAX_ERROR ;
1398: err@var564 .@exprUNIQUE location@var566 =@exprUNIQUE location@var555 ;
1399: err@var564 .@exprUNIQUE msg@var567 =@exprUNIQUE std ::@exprUNIQUE string (@exprUNIQUE "No pair for character ("@exprUNIQUE ) +@exprUNIQUE start@var556 +@exprUNIQUE "). Can't process file. File is either invalid or unicode, which is currently not supported."@exprUNIQUE ;
1400: outputList@var558 .@exprUNIQUE push_back (@exprUNIQUE err@var564 ) ;
1401: }
1402: return ""@exprUNIQUE ;
1403: }
1404:
1405: return ret@var559 ;
1406: }
1407:
1408: std :: string simplecpp :: TokenList :: lastLine ( int maxsize@var568 ) const
1409: {
1410: std ::@exprUNIQUE string ret@var569 ;
1411: int count@var570 ; count@var570 = 0 ;
1412: for ( const Token * tok@var571 =@exprUNIQUE cback (@expr3722 ) ;@exprUNIQUE ;@exprUNIQUE tok@var571 =@exprUNIQUE tok@var571 .@exprUNIQUE previous@var572 ) {
1413: if ( !@exprUNIQUE sameline (@exprUNIQUE tok@var571 ,@exprUNIQUE cback (@expr3722 ) ) ) {
1414: break ;
1415: }
1416: if ( tok@var571 .@exprUNIQUE comment@var573 ) {
1417: continue ; }
1418: if ( ++@exprUNIQUE count@var570 >@exprUNIQUE maxsize@var568 ) {
1419: return ""@exprUNIQUE ; }
1420: if ( !@exprUNIQUE ret@var569 .@exprUNIQUE empty (@exprUNIQUE ) ) {
1421: ret@var569 +=@exprUNIQUE ' '@exprUNIQUE ; }
1422:
1423: if ( tok@var571 .@expr3743 str (@expr3744 ) [@exprUNIQUE 0 ] ==@exprUNIQUE '\"'@exprUNIQUE ) {
1424: ret@var569 +=@exprUNIQUE "%rts%"@exprUNIQUE ; }
1425: else { if ( tok@var571 .@exprUNIQUE number@var574 ) {
1426: ret@var569 +=@exprUNIQUE "%mun%"@exprUNIQUE ; }
1427: else {
1428: ret@var569 +=@exprUNIQUE tok@var571 .@expr3743 str (@expr3744 ) ;
1429: std ::@expr3756 reverse (@exprUNIQUE ret@var569 .@expr3758 end (@expr3759 ) -@exprUNIQUE tok@var571 .@expr3743 str (@expr3744 ) .@exprUNIQUE length (@exprUNIQUE ) ,@exprUNIQUE ret@var569 .@expr3758 end (@expr3759 ) ) ;
1430: } }
1431: }
1432: std ::@expr3756 reverse (@exprUNIQUE ret@var569 .@exprUNIQUE begin (@exprUNIQUE ) ,@exprUNIQUE ret@var569 .@expr3758 end (@expr3759 ) ) ;
1433: return ret@var569 ;
1434: }
1435:
1436: const simplecpp :: Token * simplecpp :: TokenList :: lastLineTok ( int maxsize@var575 ) const
1437: {
1438: const Token * prevTok@var576 ; prevTok@var576 = nullptr ;
1439: int count@var577 ; count@var577 = 0 ;
1440: for ( const Token * tok@var578 =@exprUNIQUE cback (@expr3772 ) ;@exprUNIQUE ;@exprUNIQUE tok@var578 =@exprUNIQUE tok@var578 .@exprUNIQUE previous@var579 ) {
1441: if ( !@exprUNIQUE sameline (@exprUNIQUE tok@var578 ,@exprUNIQUE cback (@expr3772 ) ) ) {
1442: break ; }
1443: if ( tok@var578 .@exprUNIQUE comment@var580 ) {
1444: continue ; }
1445: if ( ++@exprUNIQUE count@var577 >@exprUNIQUE maxsize@var575 ) {
1446: return nullptr ; }
1447: prevTok@var576 =@exprUNIQUE tok@var578 ;
1448: }
1449: return prevTok@var576 ;
1450: }
1451:
1452: bool simplecpp :: TokenList :: isLastLinePreprocessor ( int maxsize@var581 ) const
1453: {
1454: const Token * const prevTok@var582 ; prevTok@var582 =@exprUNIQUE lastLineTok (@exprUNIQUE maxsize@var581 ) ;
1455: return prevTok@var582 &&@exprUNIQUE prevTok@var582 .@exprUNIQUE op@var583 ==@exprUNIQUE '#'@exprUNIQUE ;
1456: }
1457:
1458: unsigned int simplecpp :: TokenList :: fileIndex ( const std :: string & filename@var584 )
1459: {
1460: for ( unsigned int i@var585 = 0 ; i@var585 <@exprUNIQUE files@var133 .@expr3795 size (@expr3796 ) ;@exprUNIQUE ++@exprUNIQUE i@var585 ) {
1461: if ( files@var133 [@exprUNIQUE i@var585 ] ==@exprUNIQUE filename@var584 ) {
1462: return i@var585 ; }
1463: }
1464: files@var133 .@exprUNIQUE push_back (@exprUNIQUE filename@var584 ) ;
1465: return files@var133 .@expr3795 size (@expr3796 ) -@exprUNIQUE 1U ;
1466: }
1467:
1468:
1469: namespace simplecpp {
1470: class Macro ;
1471:
1472:
1473: class Macro {
1474: public:
1475: explicit Macro ( std :: vector < std :: string > & f@var586 ) : nameTokDef@var911 ( nullptr ) , valueToken@var913 ( nullptr ) , endToken@var914 ( nullptr ) , files@var915 ( f@var586 ) , tokenListDefine@var916 ( f@var586 ) , variadic@var918 ( false ) , variadicOpt@var919 ( false ) , optExpandValue@var920 ( nullptr ) , optNoExpandValue@var921 ( nullptr ) , valueDefinedInCode_@var922 ( false ) { }
1476:
1477: Macro ( const Token * tok@var587 , std :: vector < std :: string > & f@var588 ) : nameTokDef@var911 ( nullptr ) , files@var915 ( f@var588 ) , tokenListDefine@var916 ( f@var588 ) , valueDefinedInCode_@var922 ( true ) {
1478: if ( sameline (@exprUNIQUE tok@var587 .@exprUNIQUE previousSkipComments (@exprUNIQUE ) ,@exprUNIQUE tok@var587 ) ) {
1479: throw@expr3818 std ::@expr3815 runtime_error (@expr3817 "bad macro syntax"@expr3816 ) ; }
1480: if ( tok@var587 .@exprUNIQUE op@var589 !=@exprUNIQUE '#'@exprUNIQUE ) {
1481: throw@expr3818 std ::@expr3815 runtime_error (@expr3817 "bad macro syntax"@expr3816 ) ; }
1482: const Token * const hashtok@var590 ; hashtok@var590 =@exprUNIQUE tok@var587 ;
1483: tok@var587 =@expr3824 tok@var587 .@expr3823 next@var591 ;
1484: if ( !@expr3825 tok@var587 ||@exprUNIQUE tok@var587 .@exprUNIQUE str (@exprUNIQUE ) !=@exprUNIQUE DEFINE@var208 ) {
1485: throw@expr3818 std ::@expr3815 runtime_error (@expr3817 "bad macro syntax"@expr3816 ) ; }
1486: tok@var587 =@expr3824 tok@var587 .@expr3823 next@var591 ;
1487: if ( !@expr3825 tok@var587 ||@exprUNIQUE !@exprUNIQUE tok@var587 .@exprUNIQUE name@var592 ||@exprUNIQUE !@exprUNIQUE sameline (@exprUNIQUE hashtok@var590 ,@exprUNIQUE tok@var587 ) ) {
1488: throw@expr3818 std ::@expr3815 runtime_error (@expr3817 "bad macro syntax"@expr3816 ) ; }
1489: if ( !@exprUNIQUE parseDefine (@exprUNIQUE tok@var587 ) ) {
1490: throw@expr3818 std ::@expr3815 runtime_error (@expr3817 "bad macro syntax"@expr3816 ) ; }
1491: }
1492:
1493: Macro ( const std :: string & name@var593 , const std :: string & value@var594 , std :: vector < std :: string > & f@var595 ) : nameTokDef@var911 ( nullptr ) , files@var915 ( f@var595 ) , tokenListDefine@var916 ( f@var595 ) , valueDefinedInCode_@var922 ( false ) {
1494: const std ::@exprUNIQUE string def@var596 (@exprUNIQUE name@var593 +@exprUNIQUE ' '@exprUNIQUE +@exprUNIQUE value@var594 ) ;
1495: StdCharBufStream stream@var597 (@exprUNIQUE reinterpret_cast < const unsigned char * > (@exprUNIQUE def@var596 .@exprUNIQUE data (@exprUNIQUE ) ) ,@exprUNIQUE def@var596 .@exprUNIQUE size (@exprUNIQUE ) ) ;
1496: tokenListDefine@var916 .@exprUNIQUE readfile (@exprUNIQUE stream@var597 ) ;
1497: if ( !@exprUNIQUE parseDefine (@exprUNIQUE tokenListDefine@var916 .@exprUNIQUE cfront (@exprUNIQUE ) ) ) {
1498: throw@exprUNIQUE std ::@exprUNIQUE runtime_error (@exprUNIQUE "bad macro syntax. macroname="@exprUNIQUE +@exprUNIQUE name@var593 +@exprUNIQUE " value="@exprUNIQUE +@exprUNIQUE value@var594 ) ; }
1499: }
1500:
1501: Macro ( const Macro & other@var598 ) : nameTokDef@var911 ( nullptr ) , files@var915 ( other@var598 . files@var599 ) , tokenListDefine@var916 ( other@var598 . files@var599 ) , valueDefinedInCode_@var922 ( other@var598 . valueDefinedInCode_@var600 ) {
1502: *@exprUNIQUE this =@exprUNIQUE other@var598 ;
1503: }
1504:
1505: ~ Macro ( ) {
1506: delete@exprUNIQUE optExpandValue@var920 ;
1507: delete@exprUNIQUE optNoExpandValue@var921 ;
1508: }
1509:
1510: Macro & operator= ( const Macro & other@var601 ) {
1511: if ( this !=@exprUNIQUE &@exprUNIQUE other@var601 ) {
1512: files@var915 =@exprUNIQUE other@var601 .@exprUNIQUE files@var602 ;
1513: valueDefinedInCode_@var922 =@exprUNIQUE other@var601 .@exprUNIQUE valueDefinedInCode_@var603 ;
1514: if ( other@var601 .@expr3887 tokenListDefine@var604 .@exprUNIQUE empty (@exprUNIQUE ) ) {
1515: parseDefine (@exprUNIQUE other@var601 .@exprUNIQUE nameTokDef@var605 ) ; }
1516: else {
1517: tokenListDefine@var916 =@exprUNIQUE other@var601 .@expr3887 tokenListDefine@var604 ;
1518: parseDefine (@exprUNIQUE tokenListDefine@var916 .@exprUNIQUE cfront (@exprUNIQUE ) ) ;
1519: }
1520: usageList@var917 =@exprUNIQUE other@var601 .@exprUNIQUE usageList@var606 ;
1521: }
1522: return *@exprUNIQUE this ;
1523: }
1524:
1525: bool valueDefinedInCode ( ) const {
1526: return valueDefinedInCode_@var922 ;
1527: }
1528:
|
1537:
1538: const Token * expand ( TokenList * const output@var607 ,
1539: const Token * rawtok@var608 ,
1540: const std :: unordered_map < std :: string , Macro > & macros@var609 ,
1541: std :: vector < std :: string > & inputFiles@var610 ) const {
1542: std ::@exprUNIQUE set < std :: string > expandedmacros@var611 ;
1543:
|
1547:
1548: TokenList output2@var612 (@exprUNIQUE inputFiles@var610 ) ;
1549:
1550: if ( functionLike (@exprUNIQUE ) &&@exprUNIQUE rawtok@var608 .@expr3907 next@var613 &&@exprUNIQUE rawtok@var608 .@expr3907 next@var613 .@exprUNIQUE op@var614 ==@exprUNIQUE '('@expr3910 ) {
1551:
1552: const Token * const rawtok1@var615 ; rawtok1@var615 =@exprUNIQUE rawtok@var608 ;
1553: TokenList rawtokens2@var616 (@exprUNIQUE inputFiles@var610 ) ;
1554: rawtokens2@var616 .@expr3916 push_back (@expr3927 new@expr3926 Token (@expr3925 rawtok@var608 .@expr3919 str (@expr3920 ) ,@expr3922 rawtok1@var615 .@expr3921 location@var617 ,@expr3924 rawtok@var608 .@expr3923 whitespaceahead@var618 ) ) ;
1555: rawtok@var608 =@expr3928 rawtok@var608 .@expr3907 next@var613 ;
1556: rawtokens2@var616 .@expr3916 push_back (@expr3927 new@expr3926 Token (@expr3925 rawtok@var608 .@expr3919 str (@expr3920 ) ,@expr3922 rawtok1@var615 .@expr3921 location@var617 ,@expr3924 rawtok@var608 .@expr3923 whitespaceahead@var618 ) ) ;
1557: rawtok@var608 =@expr3928 rawtok@var608 .@expr3907 next@var613 ;
1558: int par@var619 ; par@var619 = 1 ;
1559: while ( rawtok@var608 &&@exprUNIQUE par@var619 >@exprUNIQUE 0 ) {
1560: if ( rawtok@var608 .@expr3932 op@var620 ==@expr3933 '('@expr3910 ) {
1561: ++@exprUNIQUE par@var619 ; }
1562: else { if ( rawtok@var608 .@expr3932 op@var620 ==@exprUNIQUE ')'@expr3935 ) {
1563: --@exprUNIQUE par@var619 ; }
1564: else { if ( rawtok@var608 .@expr3932 op@var620 ==@exprUNIQUE '#'@exprUNIQUE &&@exprUNIQUE !@exprUNIQUE sameline (@exprUNIQUE rawtok@var608 .@exprUNIQUE previous@var621 ,@exprUNIQUE rawtok@var608 ) ) {
1565: throw@exprUNIQUE Error (@exprUNIQUE rawtok@var608 .@expr3947 location@var622 ,@exprUNIQUE "it is invalid to use a preprocessor directive as macro parameter"@exprUNIQUE ) ; } } }
1566: rawtokens2@var616 .@expr3916 push_back (@expr3927 new@expr3926 Token (@expr3925 rawtok@var608 .@expr3919 str (@expr3920 ) ,@expr3922 rawtok1@var615 .@expr3921 location@var617 ,@expr3924 rawtok@var608 .@expr3923 whitespaceahead@var618 ) ) ;
1567: rawtok@var608 =@expr3928 rawtok@var608 .@expr3907 next@var613 ;
1568: }
1569: if ( expand (@exprUNIQUE &@expr3953 output2@var612 ,@exprUNIQUE rawtok1@var615 .@expr3921 location@var617 ,@exprUNIQUE rawtokens2@var616 .@exprUNIQUE cfront (@exprUNIQUE ) ,@exprUNIQUE macros@var609 ,@exprUNIQUE expandedmacros@var611 ) ) {
1570: rawtok@var608 =@exprUNIQUE rawtok1@var615 .@exprUNIQUE next@var623 ; }
1571: } else {
1572: rawtok@var608 =@exprUNIQUE expand (@exprUNIQUE &@expr3953 output2@var612 ,@expr3964 rawtok@var608 .@expr3947 location@var622 ,@exprUNIQUE rawtok@var608 ,@exprUNIQUE macros@var609 ,@exprUNIQUE expandedmacros@var611 ) ;
1573: }
1574: while ( output2@var612 .@expr3971 cback (@expr3972 ) &&@exprUNIQUE rawtok@var608 ) {
1575: unsigned int par@var624 ; par@var624 = 0 ;
1576: Token@exprUNIQUE *@exprUNIQUE macro2tok@var625 ; macro2tok@var625 =@expr3978 output2@var612 .@expr3976 back (@expr3977 ) ;
1577: while ( macro2tok@var625 ) {
1578: if ( macro2tok@var625 .@expr3979 op@var626 ==@exprUNIQUE '('@expr3910 ) {
1579: if ( par@var624 ==@exprUNIQUE 0 ) {
1580: break ; }
1581: --@exprUNIQUE par@var624 ;
1582: } else { if ( macro2tok@var625 .@expr3979 op@var626 ==@exprUNIQUE ')'@expr3935 ) {
1583: ++@exprUNIQUE par@var624 ; } }
1584: macro2tok@var625 =@expr3986 macro2tok@var625 .@expr3985 previous@var627 ;
1585: }
1586: if ( macro2tok@var625 ) {
1587: macro2tok@var625 =@expr3986 macro2tok@var625 .@expr3985 previous@var627 ;
1588: expandedmacros@var611 .@exprUNIQUE insert (@exprUNIQUE name (@exprUNIQUE ) ) ;
1589: } else { if ( rawtok@var608 .@expr3932 op@var620 ==@expr3933 '('@expr3910 ) {
1590: macro2tok@var625 =@expr3978 output2@var612 .@expr3976 back (@expr3977 ) ; } }
1591: if ( !@exprUNIQUE macro2tok@var625 ||@exprUNIQUE !@exprUNIQUE macro2tok@var625 .@exprUNIQUE name@var628 ) {
1592: break ; }
1593: if ( output2@var612 .@exprUNIQUE cfront (@exprUNIQUE ) !=@exprUNIQUE output2@var612 .@expr3971 cback (@expr3972 ) &&@exprUNIQUE macro2tok@var625 .@expr3999 str (@expr4000 ) ==@exprUNIQUE this .@exprUNIQUE name (@exprUNIQUE ) ) {
1594: break ; }
1595: const MacroMap :: const_iterator macro@var629 =@exprUNIQUE macros@var609 .@exprUNIQUE find (@exprUNIQUE macro2tok@var625 .@expr3999 str (@expr4000 ) ) ;
1596: if ( macro@var629 ==@exprUNIQUE macros@var609 .@exprUNIQUE end (@exprUNIQUE ) ||@exprUNIQUE !@exprUNIQUE macro@var629 .@expr4014 second@var630 .@exprUNIQUE functionLike (@exprUNIQUE ) ) {
1597: break ; }
1598: TokenList rawtokens2@var631 (@exprUNIQUE inputFiles@var610 ) ;
1599: const Location loc@var632 (@exprUNIQUE macro2tok@var625 .@exprUNIQUE location@var633 ) ;
1600: while ( macro2tok@var625 ) {
1601: Token * const next@var634 ; next@var634 =@exprUNIQUE macro2tok@var625 .@exprUNIQUE next@var635 ;
1602: rawtokens2@var631 .@expr4024 push_back (@exprUNIQUE new@exprUNIQUE Token (@exprUNIQUE macro2tok@var625 .@expr3999 str (@expr4000 ) ,@exprUNIQUE loc@var632 ) ) ;
1603: output2@var612 .@exprUNIQUE deleteToken (@exprUNIQUE macro2tok@var625 ) ;
1604: macro2tok@var625 =@exprUNIQUE next@var634 ;
1605: }
1606: par@var624 =@exprUNIQUE ( rawtokens2@var631 .@expr4033 cfront (@expr4034 ) !=@exprUNIQUE rawtokens2@var631 .@exprUNIQUE cback (@exprUNIQUE ) ) ?@exprUNIQUE 1U :@exprUNIQUE 0U ;
1607: const Token * rawtok2@var636 ; rawtok2@var636 =@exprUNIQUE rawtok@var608 ;
1608: for ( ;@exprUNIQUE rawtok2@var636 ;@exprUNIQUE rawtok2@var636 =@exprUNIQUE rawtok2@var636 .@expr4044 next@var637 ) {
1609: rawtokens2@var631 .@expr4024 push_back (@exprUNIQUE new@exprUNIQUE Token (@exprUNIQUE rawtok2@var636 .@exprUNIQUE str (@exprUNIQUE ) ,@exprUNIQUE loc@var632 ) ) ;
1610: if ( rawtok2@var636 .@expr4054 op@var638 ==@exprUNIQUE '('@expr3910 ) {
1611: ++@exprUNIQUE par@var624 ; }
1612: else { if ( rawtok2@var636 .@expr4054 op@var638 ==@exprUNIQUE ')'@expr3935 ) {
1613: if ( par@var624 <=@exprUNIQUE 1U ) {
1614: break ; }
1615: --@exprUNIQUE par@var624 ;
1616: } }
1617: }
1618: if ( !@exprUNIQUE rawtok2@var636 ||@exprUNIQUE par@var624 !=@exprUNIQUE 1U ) {
1619: break ; }
1620: if ( macro@var629 .@expr4014 second@var630 .@exprUNIQUE expand (@exprUNIQUE &@expr3953 output2@var612 ,@expr3964 rawtok@var608 .@expr3947 location@var622 ,@exprUNIQUE rawtokens2@var631 .@expr4033 cfront (@expr4034 ) ,@exprUNIQUE macros@var609 ,@exprUNIQUE expandedmacros@var611 ) !=@exprUNIQUE nullptr ) {
1621: break ; }
1622: rawtok@var608 =@exprUNIQUE rawtok2@var636 .@expr4044 next@var637 ;
1623: }
1624: output@var607 .@exprUNIQUE takeTokens (@exprUNIQUE output2@var612 ) ;
1625: return rawtok@var608 ;
1626: }
1627:
1628:
1629: const std :: string & name ( ) const {
1630: return nameTokDef@var911 .@exprUNIQUE str (@exprUNIQUE ) ;
1631: }
1632:
1633:
1634: const Location & defineLocation ( ) const {
1635: return nameTokDef@var911 .@exprUNIQUE location@var923 ;
1636: }
1637:
1638:
1639: const std :: list < Location > & usage ( ) const {
1640: return usageList@var917 ;
1641: }
1642:
1643:
1644: bool functionLike ( ) const {
1645: return nameTokDef@var911 .@expr4078 next@var924 &&@exprUNIQUE
1646: nameTokDef@var911 .@expr4078 next@var924 .@exprUNIQUE op@var925 ==@exprUNIQUE '('@exprUNIQUE &&@exprUNIQUE
1647: sameline (@exprUNIQUE nameTokDef@var911 ,@exprUNIQUE nameTokDef@var911 .@expr4078 next@var924 ) &&@exprUNIQUE
1648: nameTokDef@var911 .@expr4078 next@var924 .@exprUNIQUE location@var926 .@exprUNIQUE col@var927 ==@exprUNIQUE nameTokDef@var911 .@exprUNIQUE location@var923 .@exprUNIQUE col@var928 +@exprUNIQUE nameTokDef@var911 .@exprUNIQUE str (@exprUNIQUE ) .@exprUNIQUE size (@exprUNIQUE ) ;
1649: }
1650:
1651:
1652: struct Error {
1653: Error ( const Location & loc@var639 , const std :: string & s@var640 ) : location@var641 ( loc@var639 ) , what@var642 ( s@var640 ) { }
1654: const Location location@var641 ;
1655: const std :: string what@var642 ;
1656: } ;
1657:
1658:
1659: struct wrongNumberOfParameters : public Error {
1660: wrongNumberOfParameters ( const Location & loc@var643 , const std :: string & macroName@var644 ) : Error ( loc@var643 , "Wrong number of parameters for macro \'" + macroName@var644 + "\'." ) { }
1661: } ;
1662:
1663:
1664: struct invalidHashHash : public Error {
1665: static std :: string format ( const std :: string & macroName@var645 , const std :: string & message@var646 ) {
1666: return "Invalid ## usage when expanding \'"@exprUNIQUE +@exprUNIQUE macroName@var645 +@exprUNIQUE "\': "@exprUNIQUE +@exprUNIQUE message@var646 ;
1667: }
1668:
1669: invalidHashHash ( const Location & loc@var647 , const std :: string & macroName@var648 , const std :: string & message@var649 )
1670: : Error ( loc@var647 , format ( macroName@var648 , message@var649 ) ) { }
1671:
1672: static invalidHashHash unexpectedToken ( const Location & loc@var650 , const std :: string & macroName@var651 , const Token * tokenA@var652 ) {
1673: return invalidHashHash (@exprUNIQUE loc@var650 ,@exprUNIQUE macroName@var651 ,@exprUNIQUE "Unexpected token '"@exprUNIQUE +@exprUNIQUE tokenA@var652 .@exprUNIQUE str (@exprUNIQUE ) +@exprUNIQUE "'"@exprUNIQUE ) ;
1674: }
1675:
1676: static invalidHashHash cannotCombine ( const Location & loc@var653 , const std :: string & macroName@var654 , const Token * tokenA@var655 , const Token * tokenB@var656 ) {
1677: return invalidHashHash (@exprUNIQUE loc@var653 ,@exprUNIQUE macroName@var654 ,@exprUNIQUE "Combining '"@exprUNIQUE +@exprUNIQUE tokenA@var655 .@exprUNIQUE str (@exprUNIQUE ) +@exprUNIQUE "' and '"@exprUNIQUE +@exprUNIQUE tokenB@var656 .@exprUNIQUE str (@exprUNIQUE ) +@exprUNIQUE "' yields an invalid token."@exprUNIQUE ) ;
1678: }
1679:
1680: static invalidHashHash unexpectedNewline ( const Location & loc@var657 , const std :: string & macroName@var658 ) {
1681: return invalidHashHash (@exprUNIQUE loc@var657 ,@exprUNIQUE macroName@var658 ,@exprUNIQUE "Unexpected newline"@exprUNIQUE ) ;
1682: }
1683:
1684: static invalidHashHash universalCharacterUB ( const Location & loc@var659 , const std :: string & macroName@var660 , const Token * tokenA@var661 , const std :: string & strAB@var662 ) {
1685: return invalidHashHash (@exprUNIQUE loc@var659 ,@exprUNIQUE macroName@var660 ,@exprUNIQUE "Combining '\\"@exprUNIQUE +@exprUNIQUE tokenA@var661 .@expr4141 str (@expr4142 ) +@exprUNIQUE "' and '"@exprUNIQUE +@exprUNIQUE strAB@var662 .@exprUNIQUE substr (@exprUNIQUE tokenA@var661 .@expr4141 str (@expr4142 ) .@exprUNIQUE size (@exprUNIQUE ) ) +@exprUNIQUE "' yields universal character '\\"@exprUNIQUE +@exprUNIQUE strAB@var662 +@exprUNIQUE "'. This is undefined behavior according to C standard chapter 5.1.1.2, paragraph 4."@exprUNIQUE ) ;
1686: }
1687: } ;
1688: private:
1689:
1690: Token * newMacroToken ( const std :: string & str@var663 , const Location & loc@var664 , bool replaced@var665 , const Token * expandedFromToken@var666 = nullptr ) const {
1691: Token@exprUNIQUE *@exprUNIQUE tok@var667 ; tok@var667 =@exprUNIQUE new@exprUNIQUE Token (@exprUNIQUE str@var663 ,@exprUNIQUE loc@var664 ) ;
1692: if ( replaced@var665 ) {
1693: tok@var667 .@exprUNIQUE macro@var668 =@exprUNIQUE nameTokDef@var911 .@exprUNIQUE str (@exprUNIQUE ) ; }
1694: if ( expandedFromToken@var666 ) {
1695: tok@var667 .@exprUNIQUE setExpandedFrom (@exprUNIQUE expandedFromToken@var666 ,@exprUNIQUE this ) ; }
1696: return tok@var667 ;
1697: }
1698:
1699: bool parseDefine ( const Token * nametoken@var669 ) {
1700: nameTokDef@var911 =@exprUNIQUE nametoken@var669 ;
1701: variadic@var918 = false ;
1702: variadicOpt@var919 = false ;
1703: optExpandValue@var920 = nullptr ;
1704: optNoExpandValue@var921 = nullptr ;
1705: if ( !@exprUNIQUE nameTokDef@var911 ) {
1706: valueToken@var913 =@exprUNIQUE endToken@var914 =@exprUNIQUE nullptr ;
1707: args@var912 .@expr4181 clear (@expr4182 ) ;
1708: return false@expr4183 ;
1709: }
1710:
1711:
1712: if ( functionLike (@exprUNIQUE ) ) {
1713: args@var912 .@expr4181 clear (@expr4182 ) ;
1714: const Token * argtok@var670 ; argtok@var670 =@exprUNIQUE nameTokDef@var911 .@expr4186 next@var924 .@exprUNIQUE next@var929 ;
1715: while ( sameline (@expr4191 nametoken@var669 ,@expr4190 argtok@var670 ) &&@exprUNIQUE argtok@var670 .@expr4192 op@var671 !=@exprUNIQUE ')'@expr4193 ) {
1716: if ( argtok@var670 .@expr4197 str (@expr4198 ) ==@exprUNIQUE "..."@exprUNIQUE &&@exprUNIQUE
1717: argtok@var670 .@expr4201 next@var672 &&@exprUNIQUE argtok@var670 .@expr4201 next@var672 .@exprUNIQUE op@var673 ==@exprUNIQUE ')'@expr4193 ) {
1718: variadic@var918 = true ;
1719: if ( !@exprUNIQUE argtok@var670 .@expr4206 previous@var674 .@exprUNIQUE name@var675 ) {
1720: args@var912 .@expr4210 push_back (@exprUNIQUE "__VA_ARGS__"@exprUNIQUE ) ; }
1721: argtok@var670 =@expr4213 argtok@var670 .@expr4201 next@var672 ;
1722: break ;
1723: }
1724: if ( argtok@var670 .@expr4192 op@var671 !=@exprUNIQUE ','@exprUNIQUE ) {
1725: args@var912 .@expr4210 push_back (@exprUNIQUE argtok@var670 .@expr4197 str (@expr4198 ) ) ; }
1726: argtok@var670 =@expr4213 argtok@var670 .@expr4201 next@var672 ;
1727: }
1728: if ( !@exprUNIQUE sameline (@expr4191 nametoken@var669 ,@expr4190 argtok@var670 ) ) {
1729: endToken@var914 =@exprUNIQUE argtok@var670 ?@exprUNIQUE argtok@var670 .@expr4206 previous@var674 :@exprUNIQUE argtok@var670 ;
1730: valueToken@var913 = nullptr ;
1731: return false@expr4183 ;
1732: }
1733: valueToken@var913 =@exprUNIQUE argtok@var670 ?@exprUNIQUE argtok@var670 .@expr4201 next@var672 :@exprUNIQUE nullptr ;
1734: } else {
1735: args@var912 .@expr4181 clear (@expr4182 ) ;
1736: valueToken@var913 =@exprUNIQUE nameTokDef@var911 .@expr4186 next@var924 ;
1737: }
1738:
1739: if ( !@exprUNIQUE sameline (@exprUNIQUE valueToken@var913 ,@exprUNIQUE nameTokDef@var911 ) ) {
1740: valueToken@var913 = nullptr ; }
1741: endToken@var914 =@exprUNIQUE valueToken@var913 ;
1742: while ( sameline (@exprUNIQUE endToken@var914 ,@exprUNIQUE nameTokDef@var911 ) ) {
1743: if ( variadic@var918 &&@exprUNIQUE endToken@var914 .@exprUNIQUE str (@exprUNIQUE ) ==@exprUNIQUE "__VA_OPT__"@expr4234 ) {
1744: variadicOpt@var919 = true ; }
1745: endToken@var914 =@exprUNIQUE endToken@var914 .@exprUNIQUE next@var930 ;
1746: }
1747:
1748: if ( variadicOpt@var919 ) {
1749: TokenList expandValue@var676 (@exprUNIQUE files@var915 ) ;
1750: TokenList noExpandValue@var677 (@exprUNIQUE files@var915 ) ;
1751: for ( const Token * tok@var678 =@exprUNIQUE valueToken@var913 ;@exprUNIQUE tok@var678 &&@expr4243 tok@var678 !=@expr4242 endToken@var914 ;@exprUNIQUE ) {
1752: if ( tok@var678 .@expr4246 str (@expr4247 ) ==@expr4248 "__VA_OPT__"@expr4234 ) {
1753: if ( !@exprUNIQUE sameline (@exprUNIQUE tok@var678 ,@exprUNIQUE tok@var678 .@expr4249 next@var679 ) ||@exprUNIQUE tok@var678 .@expr4249 next@var679 .@exprUNIQUE op@var680 !=@exprUNIQUE '('@expr4254 ) {
1754: throw@exprUNIQUE Error (@exprUNIQUE tok@var678 .@expr4258 location@var681 ,@exprUNIQUE "In definition of '"@expr4259 +@expr4262 nameTokDef@var911 .@expr4260 str (@expr4261 ) +@exprUNIQUE "': Missing opening parenthesis for __VA_OPT__"@exprUNIQUE ) ; }
1755: tok@var678 =@exprUNIQUE tok@var678 .@expr4249 next@var679 .@exprUNIQUE next@var682 ;
1756: int par@var683 ; par@var683 = 1 ;
1757: while ( tok@var678 &&@expr4243 tok@var678 !=@expr4242 endToken@var914 ) {
1758: if ( tok@var678 .@expr4270 op@var684 ==@exprUNIQUE '('@expr4254 ) {
1759: par@var683 ++@exprUNIQUE ; }
1760: else { if ( tok@var678 .@expr4270 op@var684 ==@exprUNIQUE ')'@expr4193 ) {
1761: par@var683 --@exprUNIQUE ; }
1762: else { if ( tok@var678 .@expr4246 str (@expr4247 ) ==@expr4248 "__VA_OPT__"@expr4234 ) {
1763: throw@exprUNIQUE Error (@exprUNIQUE tok@var678 .@expr4258 location@var681 ,@exprUNIQUE "In definition of '"@expr4259 +@expr4262 nameTokDef@var911 .@expr4260 str (@expr4261 ) +@exprUNIQUE "': __VA_OPT__ cannot be nested"@exprUNIQUE ) ; } } }
1764: if ( par@var683 ==@exprUNIQUE 0 ) {
1765: tok@var678 =@expr4282 tok@var678 .@expr4249 next@var679 ;
1766: break ;
1767: }
1768: expandValue@var676 .@expr4283 push_back (@expr4288 new@expr4287 Token (@expr4286 *@expr4285 tok@var678 ) ) ;
1769: tok@var678 =@expr4282 tok@var678 .@expr4249 next@var679 ;
1770: }
1771: if ( par@var683 !=@exprUNIQUE 0 ) {
1772: const Token * const lastTok@var685 ; lastTok@var685 =@exprUNIQUE expandValue@var676 .@expr4291 back (@expr4292 ) ?@exprUNIQUE expandValue@var676 .@expr4291 back (@expr4292 ) :@exprUNIQUE valueToken@var913 .@exprUNIQUE next@var931 ;
1773: throw@exprUNIQUE Error (@exprUNIQUE lastTok@var685 .@exprUNIQUE location@var686 ,@exprUNIQUE "In definition of '"@expr4259 +@expr4262 nameTokDef@var911 .@expr4260 str (@expr4261 ) +@exprUNIQUE "': Missing closing parenthesis for __VA_OPT__"@exprUNIQUE ) ;
1774: }
1775: } else {
1776: expandValue@var676 .@expr4283 push_back (@expr4288 new@expr4287 Token (@expr4286 *@expr4285 tok@var678 ) ) ;
1777: noExpandValue@var677 .@exprUNIQUE push_back (@exprUNIQUE new@expr4287 Token (@expr4286 *@expr4285 tok@var678 ) ) ;
1778: tok@var678 =@expr4282 tok@var678 .@expr4249 next@var679 ;
1779: }
1780: }
1781: optExpandValue@var920 =@exprUNIQUE new@exprUNIQUE TokenList (@exprUNIQUE std ::@expr4308 move (@exprUNIQUE expandValue@var676 ) ) ;
1782: optNoExpandValue@var921 =@exprUNIQUE new@exprUNIQUE TokenList (@exprUNIQUE std ::@expr4308 move (@exprUNIQUE noExpandValue@var677 ) ) ;
1783: }
1784:
1785: return true@exprUNIQUE ;
1786: }
1787:
1788: unsigned int getArgNum ( const std :: string & str@var687 ) const {
1789: unsigned int par@var688 ; par@var688 = 0 ;
1790: while ( par@var688 <@exprUNIQUE args@var912 .@exprUNIQUE size (@exprUNIQUE ) ) {
1791: if ( str@var687 ==@exprUNIQUE args@var912 [@exprUNIQUE par@var688 ] ) {
1792: return par@var688 ; }
1793: par@var688 ++@exprUNIQUE ;
1794: }
1795: return ~@exprUNIQUE 0U ;
1796: }
1797:
1798: std :: vector < const Token * > getMacroParameters ( const Token * nameTokInst@var689 , bool calledInDefine@var690 ) const {
1799: if ( !@exprUNIQUE nameTokInst@var689 .@expr4327 next@var691 ||@exprUNIQUE nameTokInst@var689 .@expr4327 next@var691 .@exprUNIQUE op@var692 !=@exprUNIQUE '('@expr4330 ||@exprUNIQUE !@exprUNIQUE functionLike (@exprUNIQUE ) ) {
1800: return std ::@exprUNIQUE vector < const Token * > (@exprUNIQUE ) ; }
1801:
1802: std ::@exprUNIQUE vector < const Token * > parametertokens@var693 ;
1803: parametertokens@var693 .@expr4343 push_back (@exprUNIQUE nameTokInst@var689 .@expr4327 next@var691 ) ;
1804: unsigned int par@var694 ; par@var694 = 0U ;
1805: for ( const Token * tok@var695 =@exprUNIQUE nameTokInst@var689 .@expr4327 next@var691 .@exprUNIQUE next@var696 ;@exprUNIQUE calledInDefine@var690 ?@exprUNIQUE sameline (@exprUNIQUE tok@var695 ,@exprUNIQUE nameTokInst@var689 ) :@exprUNIQUE ( tok@var695 !=@exprUNIQUE nullptr ) ;@exprUNIQUE tok@var695 =@exprUNIQUE tok@var695 .@exprUNIQUE next@var697 ) {
1806: if ( tok@var695 .@expr4358 op@var698 ==@exprUNIQUE '('@expr4330 ) {
1807: ++@exprUNIQUE par@var694 ; }
1808: else { if ( tok@var695 .@expr4358 op@var698 ==@exprUNIQUE ')'@exprUNIQUE ) {
1809: if ( par@var694 ==@expr4364 0U ) {
1810: parametertokens@var693 .@expr4343 push_back (@expr4365 tok@var695 ) ;
1811: break ;
1812: }
1813: --@exprUNIQUE par@var694 ;
1814: } else { if ( par@var694 ==@expr4364 0U &&@exprUNIQUE tok@var695 .@expr4358 op@var698 ==@exprUNIQUE ','@exprUNIQUE &&@exprUNIQUE ( !@exprUNIQUE variadic@var918 ||@exprUNIQUE parametertokens@var693 .@exprUNIQUE size (@exprUNIQUE ) <@exprUNIQUE args@var912 .@exprUNIQUE size (@exprUNIQUE ) ) ) {
1815: parametertokens@var693 .@expr4343 push_back (@expr4365 tok@var695 ) ; } } }
1816: }
1817: return parametertokens@var693 ;
1818: }
1819:
1820: const Token * appendTokens ( TokenList * tokens@var699 ,
1821: const Location & rawloc@var700 ,
1822: const Token * const lpar@var701 ,
1823: const std :: unordered_map < std :: string , Macro > & macros@var702 ,
1824: const std :: set < std :: string > & expandedmacros@var703 ,
1825: const std :: vector < const Token * > & parametertokens@var704 ) const {
1826: if ( !@exprUNIQUE lpar@var701 ||@exprUNIQUE lpar@var701 .@exprUNIQUE op@var705 !=@exprUNIQUE '('@expr4381 ) {
1827: return nullptr ; }
1828: unsigned int par@var706 ; par@var706 = 0 ;
1829: const Token * tok@var707 ; tok@var707 =@exprUNIQUE lpar@var701 ;
1830: while ( sameline (@expr4388 lpar@var701 ,@expr4387 tok@var707 ) ) {
1831: if ( tok@var707 .@expr4389 op@var708 ==@expr4391 '#'@expr4390 &&@expr4395 sameline (@expr4394 tok@var707 ,@expr4393 tok@var707 .@expr4392 next@var709 ) &&@exprUNIQUE tok@var707 .@expr4392 next@var709 .@expr4396 op@var710 ==@exprUNIQUE '#'@expr4390 &&@exprUNIQUE sameline (@exprUNIQUE tok@var707 ,@exprUNIQUE tok@var707 .@expr4392 next@var709 .@exprUNIQUE next@var711 ) ) {
1832:
1833: tok@var707 =@exprUNIQUE expandHashHash (@exprUNIQUE tokens@var699 ,@expr4404 rawloc@var700 ,@expr4405 tok@var707 ,@exprUNIQUE macros@var702 ,@exprUNIQUE expandedmacros@var703 ,@exprUNIQUE parametertokens@var704 ,@exprUNIQUE false@exprUNIQUE ) ;
1834: } else { if ( tok@var707 .@expr4389 op@var708 ==@expr4391 '#'@expr4390 &&@expr4395 sameline (@expr4394 tok@var707 ,@expr4393 tok@var707 .@expr4392 next@var709 ) &&@exprUNIQUE tok@var707 .@expr4392 next@var709 .@expr4396 op@var710 !=@exprUNIQUE '#'@expr4390 ) {
1835: tok@var707 =@exprUNIQUE expandHash (@exprUNIQUE tokens@var699 ,@expr4404 rawloc@var700 ,@expr4405 tok@var707 ,@exprUNIQUE expandedmacros@var703 ,@exprUNIQUE parametertokens@var704 ) ;
1836: } else {
1837: if ( !@exprUNIQUE expandArg (@exprUNIQUE tokens@var699 ,@exprUNIQUE tok@var707 ,@exprUNIQUE rawloc@var700 ,@exprUNIQUE macros@var702 ,@exprUNIQUE expandedmacros@var703 ,@exprUNIQUE parametertokens@var704 ) ) {
1838: tokens@var699 .@exprUNIQUE push_back (@exprUNIQUE new@exprUNIQUE Token (@exprUNIQUE *@exprUNIQUE tok@var707 ) ) ;
1839: if ( tok@var707 .@exprUNIQUE macro@var712 .@exprUNIQUE empty (@exprUNIQUE ) &&@exprUNIQUE ( par@var706 >@exprUNIQUE 0 ||@exprUNIQUE tok@var707 .@exprUNIQUE str (@exprUNIQUE ) !=@exprUNIQUE "("@exprUNIQUE ) ) {
1840: tokens@var699 .@exprUNIQUE back (@exprUNIQUE ) .@exprUNIQUE macro@var1331 =@exprUNIQUE name (@exprUNIQUE ) ; }
1841: }
1842:
1843: if ( tok@var707 .@expr4389 op@var708 ==@exprUNIQUE '('@expr4381 ) {
1844: ++@exprUNIQUE par@var706 ; }
1845: else { if ( tok@var707 .@expr4389 op@var708 ==@exprUNIQUE ')'@exprUNIQUE ) {
1846: --@exprUNIQUE par@var706 ;
1847: if ( par@var706 ==@exprUNIQUE 0U ) {
1848: break ; }
1849: } }
1850: tok@var707 =@exprUNIQUE tok@var707 .@expr4392 next@var709 ;
1851: } }
1852: }
1853: for ( Token * tok2@var713 =@exprUNIQUE tokens@var699 .@exprUNIQUE front (@exprUNIQUE ) ;@exprUNIQUE tok2@var713 ;@exprUNIQUE tok2@var713 =@exprUNIQUE tok2@var713 .@exprUNIQUE next@var714 ) {
1854: tok2@var713 .@exprUNIQUE location@var715 =@exprUNIQUE lpar@var701 .@exprUNIQUE location@var716 ; }
1855: return sameline (@expr4388 lpar@var701 ,@expr4387 tok@var707 ) ?@exprUNIQUE tok@var707 :@exprUNIQUE nullptr ;
1856: }
1857:
1858: const Token * expand ( TokenList * const output@var717 , const Location & loc@var718 , const Token * const nameTokInst@var719 , const std :: unordered_map < std :: string , Macro > & macros@var720 , std :: set < std :: string > expandedmacros@var721 ) const {
1859: expandedmacros@var721 .@exprUNIQUE insert (@exprUNIQUE nameTokInst@var719 .@expr4479 str (@expr4480 ) ) ;
1860:
|
1864:
1865: usageList@var917 .@exprUNIQUE push_back (@exprUNIQUE loc@var718 ) ;
1866:
1867: if ( nameTokInst@var719 .@expr4479 str (@expr4480 ) ==@exprUNIQUE "__FILE__"@exprUNIQUE ) {
1868: output@var717 .@expr4487 push_back (@exprUNIQUE new@exprUNIQUE Token (@exprUNIQUE '\"'@expr4489 +@exprUNIQUE loc@var718 .@exprUNIQUE file (@exprUNIQUE ) +@exprUNIQUE '\"'@expr4489 ,@exprUNIQUE loc@var718 ) ) ;
1869: return nameTokInst@var719 .@expr4499 next@var722 ;
1870: }
1871: if ( nameTokInst@var719 .@expr4479 str (@expr4480 ) ==@exprUNIQUE "__LINE__"@exprUNIQUE ) {
1872: output@var717 .@expr4487 push_back (@exprUNIQUE new@exprUNIQUE Token (@exprUNIQUE toString (@exprUNIQUE loc@var718 .@expr4503 line@var723 ) ,@exprUNIQUE loc@var718 ) ) ;
1873: return nameTokInst@var719 .@expr4499 next@var722 ;
1874: }
1875: if ( nameTokInst@var719 .@expr4479 str (@expr4480 ) ==@exprUNIQUE "__COUNTER__"@expr4509 ) {
1876: output@var717 .@expr4487 push_back (@exprUNIQUE new@exprUNIQUE Token (@exprUNIQUE toString (@exprUNIQUE usageList@var917 .@exprUNIQUE size (@exprUNIQUE ) -@exprUNIQUE 1U ) ,@exprUNIQUE loc@var718 ) ) ;
1877: return nameTokInst@var719 .@expr4499 next@var722 ;
1878: }
1879:
1880: const bool calledInDefine@var724 =@exprUNIQUE loc@var718 .@exprUNIQUE fileIndex@var725 !=@exprUNIQUE nameTokInst@var719 .@expr4522 location@var726 .@exprUNIQUE fileIndex@var727 ||@exprUNIQUE
1881: loc@var718 .@expr4503 line@var723 <@exprUNIQUE nameTokInst@var719 .@expr4522 location@var726 .@exprUNIQUE line@var728 ;
1882:
1883: std ::@exprUNIQUE vector < const Token * > parametertokens1@var729 (@exprUNIQUE getMacroParameters (@exprUNIQUE nameTokInst@var719 ,@exprUNIQUE calledInDefine@var724 ) ) ;
1884:
1885: if ( functionLike (@expr4536 ) ) {
1886:
1887: if ( nameTokInst@var719 .@expr4499 next@var722 &&@exprUNIQUE nameTokInst@var719 .@expr4499 next@var722 .@exprUNIQUE op@var730 !=@exprUNIQUE '('@exprUNIQUE ) {
1888: output@var717 .@expr4487 push_back (@exprUNIQUE new@exprUNIQUE Token (@exprUNIQUE nameTokInst@var719 .@expr4479 str (@expr4480 ) ,@exprUNIQUE loc@var718 ) ) ;
1889: return nameTokInst@var719 .@expr4499 next@var722 ;
1890: }
1891:
1892:
1893: if ( variadic@var918 ) {
1894: if ( parametertokens1@var729 .@expr4545 size (@expr4546 ) <@exprUNIQUE args@var912 .@expr4547 size (@expr4548 ) ) {
1895: throw@expr4555 wrongNumberOfParameters (@expr4554 nameTokInst@var719 .@expr4522 location@var726 ,@expr4553 name (@expr4552 ) ) ;
1896: }
1897: } else {
1898: if ( parametertokens1@var729 .@expr4545 size (@expr4546 ) !=@exprUNIQUE args@var912 .@expr4547 size (@expr4548 ) +@exprUNIQUE ( args@var912 .@exprUNIQUE empty (@exprUNIQUE ) ?@exprUNIQUE 2U :@exprUNIQUE 1U ) ) {
1899: throw@expr4555 wrongNumberOfParameters (@expr4554 nameTokInst@var719 .@expr4522 location@var726 ,@expr4553 name (@expr4552 ) ) ; }
1900: }
1901: }
1902:
1903:
1904: TokenList tokensparams@var731 (@exprUNIQUE files@var915 ) ;
1905: std ::@exprUNIQUE vector < const Token * > parametertokens2@var732 ;
1906: if ( !@expr4568 parametertokens1@var729 .@expr4566 empty (@expr4567 ) ) {
1907: bool counter@var733 ; counter@var733 = false ;
1908: for ( const Token * tok@var734 =@exprUNIQUE parametertokens1@var729 [@expr4570 0 ] ;@exprUNIQUE tok@var734 !=@exprUNIQUE parametertokens1@var729 .@exprUNIQUE back (@exprUNIQUE ) ;@exprUNIQUE tok@var734 =@exprUNIQUE tok@var734 .@exprUNIQUE next@var735 ) {
1909: if ( tok@var734 .@exprUNIQUE str (@exprUNIQUE ) ==@exprUNIQUE "__COUNTER__"@expr4509 ) {
1910: counter@var733 = true ;
1911: break ;
1912: }
1913: }
1914:
1915: const MacroMap :: const_iterator m@var736 =@exprUNIQUE macros@var720 .@exprUNIQUE find (@exprUNIQUE "__COUNTER__"@expr4509 ) ;
1916:
1917: if ( !@exprUNIQUE counter@var733 ||@exprUNIQUE m@var736 ==@exprUNIQUE macros@var720 .@exprUNIQUE end (@exprUNIQUE ) ) {
1918: parametertokens2@var732 .@exprUNIQUE swap (@exprUNIQUE parametertokens1@var729 ) ; }
1919: else {
1920: const Macro & counterMacro@var737 =@exprUNIQUE m@var736 .@exprUNIQUE second@var738 ;
1921: unsigned int par@var739 ; par@var739 = 0 ;
1922: for ( const Token * tok@var740 =@exprUNIQUE parametertokens1@var729 [@expr4570 0 ] ;@exprUNIQUE tok@var740 &&@exprUNIQUE par@var739 <@exprUNIQUE parametertokens1@var729 .@expr4545 size (@expr4546 ) ;@exprUNIQUE tok@var740 =@exprUNIQUE tok@var740 .@exprUNIQUE next@var741 ) {
1923: if ( tok@var740 .@exprUNIQUE str (@exprUNIQUE ) ==@exprUNIQUE "__COUNTER__"@expr4509 ) {
1924: tokensparams@var731 .@expr4608 push_back (@exprUNIQUE new@exprUNIQUE Token (@exprUNIQUE toString (@exprUNIQUE counterMacro@var737 .@expr4609 usageList@var742 .@exprUNIQUE size (@exprUNIQUE ) ) ,@exprUNIQUE tok@var740 .@expr4613 location@var743 ) ) ;
1925: counterMacro@var737 .@expr4609 usageList@var742 .@exprUNIQUE push_back (@exprUNIQUE tok@var740 .@expr4613 location@var743 ) ;
1926: } else {
1927: tokensparams@var731 .@expr4608 push_back (@exprUNIQUE new@exprUNIQUE Token (@exprUNIQUE *@exprUNIQUE tok@var740 ) ) ;
1928: if ( tok@var740 ==@exprUNIQUE parametertokens1@var729 [@exprUNIQUE par@var739 ] ) {
1929: parametertokens2@var732 .@exprUNIQUE push_back (@exprUNIQUE tokensparams@var731 .@exprUNIQUE cback (@exprUNIQUE ) ) ;
1930: par@var739 ++@exprUNIQUE ;
1931: }
1932: }
1933: }
1934: }
1935: }
1936:
1937: Token * const output_end_1@var744 ; output_end_1@var744 =@exprUNIQUE output@var717 .@expr4632 back (@expr4633 ) ;
1938:
1939: const Token * valueToken2@var745 ;
1940: const Token * endToken2@var746 ;
1941:
1942: if ( variadicOpt@var919 ) {
1943: if ( parametertokens2@var732 .@exprUNIQUE size (@exprUNIQUE ) >@exprUNIQUE args@var912 .@expr4547 size (@expr4548 ) &&@exprUNIQUE parametertokens2@var732 [@exprUNIQUE args@var912 .@expr4547 size (@expr4548 ) -@exprUNIQUE 1 ] .@exprUNIQUE next@var1332 .@exprUNIQUE op@var1333 !=@exprUNIQUE ')'@exprUNIQUE ) {
1944: valueToken2@var745 =@exprUNIQUE optExpandValue@var920 .@exprUNIQUE cfront (@exprUNIQUE ) ; }
1945: else {
1946: valueToken2@var745 =@exprUNIQUE optNoExpandValue@var921 .@exprUNIQUE cfront (@exprUNIQUE ) ; }
1947: endToken2@var746 = nullptr ;
1948: } else {
1949: valueToken2@var745 =@exprUNIQUE valueToken@var913 ;
1950: endToken2@var746 =@exprUNIQUE endToken@var914 ;
1951: }
1952:
1953:
1954: for ( const Token * tok@var747 =@exprUNIQUE valueToken2@var745 ;@exprUNIQUE tok@var747 !=@exprUNIQUE endToken2@var746 ;@exprUNIQUE ) {
1955: if ( tok@var747 .@expr4659 op@var748 !=@exprUNIQUE '#'@expr4660 ) {
1956:
1957: if ( sameline (@exprUNIQUE tok@var747 ,@exprUNIQUE tok@var747 .@expr4663 next@var749 ) &&@exprUNIQUE tok@var747 .@expr4663 next@var749 &&@exprUNIQUE tok@var747 .@expr4663 next@var749 .@exprUNIQUE op@var750 ==@exprUNIQUE '#'@expr4660 &&@exprUNIQUE tok@var747 .@expr4663 next@var749 .@expr4670 next@var751 &&@exprUNIQUE tok@var747 .@expr4663 next@var749 .@expr4670 next@var751 .@exprUNIQUE op@var752 ==@exprUNIQUE '#'@expr4660 ) {
1958: if ( !@exprUNIQUE sameline (@exprUNIQUE tok@var747 ,@exprUNIQUE tok@var747 .@expr4663 next@var749 .@expr4670 next@var751 .@expr4675 next@var753 ) ) {
1959: throw@exprUNIQUE invalidHashHash ::@exprUNIQUE unexpectedNewline (@exprUNIQUE tok@var747 .@expr4682 location@var754 ,@exprUNIQUE name (@expr4552 ) ) ; }
1960: if ( variadic@var918 &&@exprUNIQUE tok@var747 .@expr4659 op@var748 ==@exprUNIQUE ','@exprUNIQUE &&@exprUNIQUE tok@var747 .@expr4663 next@var749 .@expr4670 next@var751 .@expr4675 next@var753 .@exprUNIQUE str (@exprUNIQUE ) ==@exprUNIQUE args@var912 .@exprUNIQUE back (@exprUNIQUE ) ) {
1961: Token * const comma@var755 ; comma@var755 =@exprUNIQUE newMacroToken (@expr4703 tok@var747 .@expr4696 str (@expr4697 ) ,@expr4698 loc@var718 ,@expr4701 isReplaced (@expr4700 expandedmacros@var721 ) ,@expr4702 tok@var747 ) ;
1962: output@var717 .@expr4487 push_back (@exprUNIQUE comma@var755 ) ;
1963: tok@var747 =@exprUNIQUE expandToken (@exprUNIQUE output@var717 ,@expr4707 loc@var718 ,@exprUNIQUE tok@var747 .@expr4663 next@var749 .@expr4670 next@var751 .@expr4675 next@var753 ,@exprUNIQUE macros@var720 ,@exprUNIQUE expandedmacros@var721 ,@exprUNIQUE parametertokens2@var732 ) ;
1964: if ( output@var717 .@expr4632 back (@expr4633 ) ==@exprUNIQUE comma@var755 ) {
1965: output@var717 .@exprUNIQUE deleteToken (@exprUNIQUE comma@var755 ) ; }
1966: continue ;
1967: }
1968: TokenList new_output@var756 (@exprUNIQUE files@var915 ) ;
1969: if ( !@exprUNIQUE expandArg (@exprUNIQUE &@exprUNIQUE new_output@var756 ,@exprUNIQUE tok@var747 ,@exprUNIQUE parametertokens2@var732 ) ) {
1970: output@var717 .@expr4487 push_back (@exprUNIQUE newMacroToken (@expr4703 tok@var747 .@expr4696 str (@expr4697 ) ,@expr4698 loc@var718 ,@expr4701 isReplaced (@expr4700 expandedmacros@var721 ) ,@expr4702 tok@var747 ) ) ; }
1971: else { if ( new_output@var756 .@exprUNIQUE empty (@exprUNIQUE ) ) {
1972: output@var717 .@expr4487 push_back (@exprUNIQUE newMacroToken (@exprUNIQUE ""@exprUNIQUE ,@exprUNIQUE loc@var718 ,@exprUNIQUE isReplaced (@expr4700 expandedmacros@var721 ) ) ) ; }
1973: else {
1974: for ( const Token * tok2@var757 =@exprUNIQUE new_output@var756 .@exprUNIQUE cfront (@exprUNIQUE ) ;@exprUNIQUE tok2@var757 ;@exprUNIQUE tok2@var757 =@exprUNIQUE tok2@var757 .@exprUNIQUE next@var758 ) {
1975: output@var717 .@expr4487 push_back (@exprUNIQUE newMacroToken (@exprUNIQUE tok2@var757 .@exprUNIQUE str (@exprUNIQUE ) ,@exprUNIQUE loc@var718 ,@exprUNIQUE isReplaced (@expr4700 expandedmacros@var721 ) ,@exprUNIQUE tok2@var757 ) ) ; } } }
1976: tok@var747 =@expr4747 tok@var747 .@expr4663 next@var749 ;
1977: } else {
1978: tok@var747 =@exprUNIQUE expandToken (@exprUNIQUE output@var717 ,@expr4707 loc@var718 ,@exprUNIQUE tok@var747 ,@exprUNIQUE macros@var720 ,@exprUNIQUE expandedmacros@var721 ,@exprUNIQUE parametertokens2@var732 ) ;
1979: }
1980: continue ;
1981: }
1982:
1983: int numberOfHash@var759 ; numberOfHash@var759 = 1 ;
1984: const Token * hashToken@var760 ; hashToken@var760 =@exprUNIQUE tok@var747 .@expr4663 next@var749 ;
1985: while ( sameline (@exprUNIQUE tok@var747 ,@exprUNIQUE hashToken@var760 ) &&@exprUNIQUE hashToken@var760 .@exprUNIQUE op@var761 ==@exprUNIQUE '#'@expr4660 ) {
1986: hashToken@var760 =@exprUNIQUE hashToken@var760 .@exprUNIQUE next@var762 ;
1987: ++@exprUNIQUE numberOfHash@var759 ;
1988: }
1989: if ( numberOfHash@var759 ==@exprUNIQUE 4 &&@exprUNIQUE tok@var747 .@expr4663 next@var749 .@expr4765 location@var763 .@expr4766 col@var764 +@exprUNIQUE 1 ==@exprUNIQUE tok@var747 .@expr4663 next@var749 .@expr4670 next@var751 .@exprUNIQUE location@var765 .@exprUNIQUE col@var766 ) {
1990:
1991: output@var717 .@expr4487 push_back (@exprUNIQUE newMacroToken (@exprUNIQUE "##"@exprUNIQUE ,@exprUNIQUE loc@var718 ,@exprUNIQUE isReplaced (@expr4700 expandedmacros@var721 ) ) ) ;
1992: tok@var747 =@exprUNIQUE hashToken@var760 ;
1993: continue ;
1994: }
1995:
1996: if ( numberOfHash@var759 >=@exprUNIQUE 2 &&@exprUNIQUE tok@var747 .@expr4682 location@var754 .@exprUNIQUE col@var767 +@exprUNIQUE 1 <@exprUNIQUE tok@var747 .@expr4663 next@var749 .@expr4765 location@var763 .@expr4766 col@var764 ) {
1997: output@var717 .@expr4487 push_back (@exprUNIQUE new@exprUNIQUE Token (@exprUNIQUE *@exprUNIQUE tok@var747 ) ) ;
1998: tok@var747 =@expr4747 tok@var747 .@expr4663 next@var749 ;
1999: continue ;
2000: }
2001:
2002: tok@var747 =@expr4747 tok@var747 .@expr4663 next@var749 ;
2003: if ( tok@var747 ==@exprUNIQUE endToken2@var746 ) {
2004: output@var717 .@expr4487 push_back (@exprUNIQUE new@exprUNIQUE Token (@exprUNIQUE *@exprUNIQUE tok@var747 .@expr4789 previous@var768 ) ) ;
2005: break ;
2006: }
2007: if ( tok@var747 .@expr4659 op@var748 ==@exprUNIQUE '#'@expr4660 ) {
2008:
2009: tok@var747 =@exprUNIQUE expandHashHash (@exprUNIQUE output@var717 ,@expr4707 loc@var718 ,@expr4796 tok@var747 .@expr4789 previous@var768 ,@exprUNIQUE macros@var720 ,@exprUNIQUE expandedmacros@var721 ,@exprUNIQUE parametertokens2@var732 ) ;
2010: } else {
2011:
2012: tok@var747 =@exprUNIQUE expandHash (@exprUNIQUE output@var717 ,@expr4707 loc@var718 ,@expr4796 tok@var747 .@expr4789 previous@var768 ,@exprUNIQUE expandedmacros@var721 ,@exprUNIQUE parametertokens2@var732 ) ;
2013: }
2014: }
2015:
2016: if ( !@exprUNIQUE functionLike (@expr4536 ) ) {
2017: for ( Token * tok@var769 =@exprUNIQUE output_end_1@var744 ?@exprUNIQUE output_end_1@var744 .@exprUNIQUE next@var770 :@exprUNIQUE output@var717 .@exprUNIQUE front (@exprUNIQUE ) ;@exprUNIQUE tok@var769 ;@exprUNIQUE tok@var769 =@exprUNIQUE tok@var769 .@exprUNIQUE next@var771 ) {
2018: tok@var769 .@exprUNIQUE macro@var772 =@exprUNIQUE nameTokInst@var719 .@expr4479 str (@expr4480 ) ;
2019: }
2020: }
2021:
2022: if ( !@expr4568 parametertokens1@var729 .@expr4566 empty (@expr4567 ) ) {
2023: parametertokens1@var729 .@exprUNIQUE swap (@exprUNIQUE parametertokens2@var732 ) ; }
2024:
2025: return functionLike (@expr4536 ) ?@exprUNIQUE parametertokens2@var732 .@exprUNIQUE back (@exprUNIQUE ) .@exprUNIQUE next :@exprUNIQUE nameTokInst@var719 .@expr4499 next@var722 ;
2026: }
2027:
2028: const Token * recursiveExpandToken ( TokenList * output@var773 , TokenList & temp@var774 , const Location & loc@var775 , const Token * tok@var776 , const std :: unordered_map < std :: string , Macro > & macros@var777 , const std :: set < std :: string > & expandedmacros@var778 , const std :: vector < const Token * > & parametertokens@var779 ) const {
2029: if ( !@exprUNIQUE ( temp@var774 .@expr4830 cback (@expr4831 ) &&@exprUNIQUE temp@var774 .@expr4830 cback (@expr4831 ) .@exprUNIQUE name@var1330 &&@exprUNIQUE tok@var776 .@expr4834 next@var780 &&@exprUNIQUE tok@var776 .@expr4834 next@var780 .@exprUNIQUE op@var781 ==@exprUNIQUE '('@exprUNIQUE ) ) {
2030: output@var773 .@expr4842 takeTokens (@expr4843 temp@var774 ) ;
2031: return tok@var776 .@expr4834 next@var780 ;
2032: }
2033:
2034: if ( !@exprUNIQUE sameline (@exprUNIQUE tok@var776 ,@exprUNIQUE tok@var776 .@expr4834 next@var780 ) ) {
2035: output@var773 .@expr4842 takeTokens (@expr4843 temp@var774 ) ;
2036: return tok@var776 .@expr4834 next@var780 ;
2037: }
2038:
2039: const std :: unordered_map < std :: string , Macro > :: const_iterator it@var782 =@exprUNIQUE macros@var777 .@exprUNIQUE find (@exprUNIQUE temp@var774 .@expr4830 cback (@expr4831 ) .@expr4851 str (@expr4852 ) ) ;
2040: if ( it@var782 ==@exprUNIQUE macros@var777 .@exprUNIQUE end (@exprUNIQUE ) ||@exprUNIQUE expandedmacros@var778 .@exprUNIQUE find (@exprUNIQUE temp@var774 .@expr4830 cback (@expr4831 ) .@expr4851 str (@expr4852 ) ) !=@exprUNIQUE expandedmacros@var778 .@exprUNIQUE end (@exprUNIQUE ) ) {
2041: output@var773 .@expr4842 takeTokens (@expr4843 temp@var774 ) ;
2042: return tok@var776 .@expr4834 next@var780 ;
2043: }
2044:
2045: const Macro & calledMacro@var783 =@exprUNIQUE it@var782 .@exprUNIQUE second@var784 ;
2046: if ( !@exprUNIQUE calledMacro@var783 .@exprUNIQUE functionLike (@exprUNIQUE ) ) {
2047: output@var773 .@expr4842 takeTokens (@expr4843 temp@var774 ) ;
2048: return tok@var776 .@expr4834 next@var780 ;
2049: }
2050:
2051: TokenList temp2@var785 (@exprUNIQUE files@var915 ) ;
2052: temp2@var785 .@exprUNIQUE push_back (@exprUNIQUE new@exprUNIQUE Token (@exprUNIQUE temp@var774 .@expr4830 cback (@expr4831 ) .@expr4851 str (@expr4852 ) ,@exprUNIQUE tok@var776 .@exprUNIQUE location@var786 ) ) ;
2053:
2054: const Token * const tok2@var787 ; tok2@var787 =@exprUNIQUE appendTokens (@exprUNIQUE &@exprUNIQUE temp2@var785 ,@exprUNIQUE loc@var775 ,@exprUNIQUE tok@var776 .@expr4834 next@var780 ,@exprUNIQUE macros@var777 ,@exprUNIQUE expandedmacros@var778 ,@exprUNIQUE parametertokens@var779 ) ;
2055: if ( !@exprUNIQUE tok2@var787 ) {
2056: return tok@var776 .@expr4834 next@var780 ; }
2057: output@var773 .@expr4842 takeTokens (@expr4843 temp@var774 ) ;
2058: output@var773 .@exprUNIQUE deleteToken (@exprUNIQUE output@var773 .@exprUNIQUE back (@exprUNIQUE ) ) ;
2059: calledMacro@var783 .@exprUNIQUE expand (@exprUNIQUE output@var773 ,@exprUNIQUE loc@var775 ,@exprUNIQUE temp2@var785 .@exprUNIQUE cfront (@exprUNIQUE ) ,@exprUNIQUE macros@var777 ,@exprUNIQUE expandedmacros@var778 ) ;
2060: return tok2@var787 .@exprUNIQUE next@var788 ;
2061: }
2062:
2063: const Token * expandToken ( TokenList * output@var789 , const Location & loc@var790 , const Token * tok@var791 , const std :: unordered_map < std :: string , Macro > & macros@var792 , const std :: set < std :: string > & expandedmacros@var793 , const std :: vector < const Token * > & parametertokens@var794 ) const {
2064:
2065: if ( !@exprUNIQUE tok@var791 .@exprUNIQUE name@var795 ) {
2066: output@var789 .@expr4910 push_back (@expr4920 newMacroToken (@expr4919 tok@var791 .@expr4913 str (@expr4914 ) ,@expr4915 loc@var790 ,@expr4917 true@expr4916 ,@expr4918 tok@var791 ) ) ;
2067: return tok@var791 .@expr4921 next@var796 ;
2068: }
2069:
2070:
2071: {
2072: TokenList temp@var797 (@exprUNIQUE files@var915 ) ;
2073: if ( expandArg (@exprUNIQUE &@exprUNIQUE temp@var797 ,@exprUNIQUE tok@var791 ,@exprUNIQUE loc@var790 ,@exprUNIQUE macros@var792 ,@exprUNIQUE expandedmacros@var793 ,@exprUNIQUE parametertokens@var794 ) ) {
2074: if ( tok@var791 .@expr4913 str (@expr4914 ) ==@exprUNIQUE "__VA_ARGS__"@exprUNIQUE &&@exprUNIQUE temp@var797 .@exprUNIQUE empty (@exprUNIQUE ) &&@exprUNIQUE output@var789 .@expr4938 cback (@expr4939 ) &&@exprUNIQUE output@var789 .@expr4938 cback (@expr4939 ) .@exprUNIQUE str (@exprUNIQUE ) ==@exprUNIQUE ","@exprUNIQUE &&@exprUNIQUE
2075: tok@var791 .@expr4947 nextSkipComments (@expr4948 ) &&@exprUNIQUE tok@var791 .@expr4947 nextSkipComments (@expr4948 ) .@exprUNIQUE str (@exprUNIQUE ) ==@exprUNIQUE ")"@exprUNIQUE ) {
2076: output@var789 .@exprUNIQUE deleteToken (@exprUNIQUE output@var789 .@exprUNIQUE back (@exprUNIQUE ) ) ; }
2077: return recursiveExpandToken (@exprUNIQUE output@var789 ,@exprUNIQUE temp@var797 ,@exprUNIQUE loc@var790 ,@exprUNIQUE tok@var791 ,@exprUNIQUE macros@var792 ,@exprUNIQUE expandedmacros@var793 ,@exprUNIQUE parametertokens@var794 ) ;
2078: }
2079: }
2080:
2081:
2082: const std :: unordered_map < std :: string , Macro > :: const_iterator it@var798 =@exprUNIQUE macros@var792 .@expr4970 find (@exprUNIQUE tok@var791 .@expr4913 str (@expr4914 ) ) ;
2083: if ( it@var798 !=@exprUNIQUE macros@var792 .@expr4974 end (@expr4975 ) &&@exprUNIQUE expandedmacros@var793 .@exprUNIQUE find (@exprUNIQUE tok@var791 .@expr4913 str (@expr4914 ) ) ==@exprUNIQUE expandedmacros@var793 .@exprUNIQUE end (@exprUNIQUE ) ) {
2084: std ::@exprUNIQUE set < std :: string > expandedmacros2@var799 (@exprUNIQUE expandedmacros@var793 ) ;
2085: expandedmacros2@var799 .@exprUNIQUE insert (@exprUNIQUE tok@var791 .@expr4913 str (@expr4914 ) ) ;
2086:
2087: const Macro & calledMacro@var800 =@exprUNIQUE it@var798 .@exprUNIQUE second@var801 ;
2088: if ( !@exprUNIQUE calledMacro@var800 .@exprUNIQUE functionLike (@exprUNIQUE ) ) {
2089: TokenList temp@var802 (@exprUNIQUE files@var915 ) ;
2090: calledMacro@var800 .@expr4997 expand (@exprUNIQUE &@exprUNIQUE temp@var802 ,@exprUNIQUE loc@var790 ,@exprUNIQUE tok@var791 ,@exprUNIQUE macros@var792 ,@exprUNIQUE expandedmacros@var793 ) ;
2091: return recursiveExpandToken (@exprUNIQUE output@var789 ,@exprUNIQUE temp@var802 ,@exprUNIQUE loc@var790 ,@exprUNIQUE tok@var791 ,@exprUNIQUE macros@var792 ,@exprUNIQUE expandedmacros2@var799 ,@exprUNIQUE parametertokens@var794 ) ;
2092: }
2093: if ( !@exprUNIQUE sameline (@exprUNIQUE tok@var791 ,@exprUNIQUE tok@var791 .@expr4921 next@var796 ) ) {
2094: output@var789 .@expr4910 push_back (@expr4920 newMacroToken (@expr4919 tok@var791 .@expr4913 str (@expr4914 ) ,@expr4915 loc@var790 ,@expr4917 true@expr4916 ,@expr4918 tok@var791 ) ) ;
2095: return tok@var791 .@expr4921 next@var796 ;
2096: }
2097: TokenList tokens@var803 (@exprUNIQUE files@var915 ) ;
2098: tokens@var803 .@exprUNIQUE push_back (@exprUNIQUE new@exprUNIQUE Token (@exprUNIQUE *@exprUNIQUE tok@var791 ) ) ;
2099: const Token * tok2@var804 ; tok2@var804 = nullptr ;
2100: if ( tok@var791 .@expr4921 next@var796 .@exprUNIQUE op@var805 ==@exprUNIQUE '('@expr5023 ) {
2101: tok2@var804 =@exprUNIQUE appendTokens (@exprUNIQUE &@expr5026 tokens@var803 ,@exprUNIQUE loc@var790 ,@exprUNIQUE tok@var791 .@expr4921 next@var796 ,@exprUNIQUE macros@var792 ,@exprUNIQUE expandedmacros@var793 ,@exprUNIQUE parametertokens@var794 ) ; }
2102: else { if ( expandArg (@exprUNIQUE &@expr5026 tokens@var803 ,@exprUNIQUE tok@var791 .@expr4921 next@var796 ,@exprUNIQUE loc@var790 ,@exprUNIQUE macros@var792 ,@exprUNIQUE expandedmacros@var793 ,@exprUNIQUE parametertokens@var794 ) ) {
2103: tokens@var803 .@exprUNIQUE front (@exprUNIQUE ) .@exprUNIQUE location@var1325 =@exprUNIQUE loc@var790 ;
2104: if ( tokens@var803 .@expr5046 cfront (@expr5047 ) .@expr5048 next@var1334 &&@exprUNIQUE tokens@var803 .@expr5046 cfront (@expr5047 ) .@expr5048 next@var1334 .@exprUNIQUE op@var1335 ==@exprUNIQUE '('@expr5023 ) {
2105: tok2@var804 =@exprUNIQUE tok@var791 .@expr4921 next@var796 ; }
2106: } }
2107: if ( !@exprUNIQUE tok2@var804 ) {
2108: output@var789 .@expr4910 push_back (@expr4920 newMacroToken (@expr4919 tok@var791 .@expr4913 str (@expr4914 ) ,@expr4915 loc@var790 ,@expr4917 true@expr4916 ,@expr4918 tok@var791 ) ) ;
2109: return tok@var791 .@expr4921 next@var796 ;
2110: }
2111: TokenList temp@var806 (@exprUNIQUE files@var915 ) ;
2112: calledMacro@var800 .@expr4997 expand (@exprUNIQUE &@exprUNIQUE temp@var806 ,@exprUNIQUE loc@var790 ,@exprUNIQUE tokens@var803 .@expr5046 cfront (@expr5047 ) ,@exprUNIQUE macros@var792 ,@exprUNIQUE expandedmacros@var793 ) ;
2113: return recursiveExpandToken (@exprUNIQUE output@var789 ,@exprUNIQUE temp@var806 ,@exprUNIQUE loc@var790 ,@exprUNIQUE tok2@var804 ,@exprUNIQUE macros@var792 ,@exprUNIQUE expandedmacros@var793 ,@exprUNIQUE parametertokens@var794 ) ;
2114: }
2115:
2116: if ( tok@var791 .@expr4913 str (@expr4914 ) ==@exprUNIQUE DEFINED@var216 ) {
2117: const Token * const tok2@var807 ; tok2@var807 =@exprUNIQUE tok@var791 .@expr4921 next@var796 ;
2118: const Token * const tok3@var808 ; tok3@var808 =@exprUNIQUE tok2@var807 ?@exprUNIQUE tok2@var807 .@exprUNIQUE next@var809 :@exprUNIQUE nullptr ;
2119: const Token * const tok4@var810 ; tok4@var810 =@exprUNIQUE tok3@var808 ?@exprUNIQUE tok3@var808 .@exprUNIQUE next@var811 :@exprUNIQUE nullptr ;
2120: const Token * defToken@var812 ; defToken@var812 = nullptr ;
2121: const Token * lastToken@var813 ; lastToken@var813 = nullptr ;
2122: if ( sameline (@exprUNIQUE tok@var791 ,@exprUNIQUE tok4@var810 ) &&@exprUNIQUE tok2@var807 .@exprUNIQUE op@var814 ==@exprUNIQUE '('@expr5023 &&@exprUNIQUE tok3@var808 .@exprUNIQUE name@var815 &&@exprUNIQUE tok4@var810 .@exprUNIQUE op@var816 ==@exprUNIQUE ')'@exprUNIQUE ) {
2123: defToken@var812 =@exprUNIQUE tok3@var808 ;
2124: lastToken@var813 =@exprUNIQUE tok4@var810 ;
2125: } else { if ( sameline (@exprUNIQUE tok@var791 ,@exprUNIQUE tok2@var807 ) &&@exprUNIQUE tok2@var807 .@exprUNIQUE name@var817 ) {
2126: defToken@var812 =@exprUNIQUE lastToken@var813 =@exprUNIQUE tok2@var807 ;
2127: } }
2128: if ( defToken@var812 ) {
2129: std ::@exprUNIQUE string macroName@var818 ; macroName@var818 =@exprUNIQUE defToken@var812 .@exprUNIQUE str (@exprUNIQUE ) ;
2130: if ( defToken@var812 .@expr5102 next@var819 &&@exprUNIQUE defToken@var812 .@expr5102 next@var819 .@exprUNIQUE op@var820 ==@exprUNIQUE '#'@expr5104 &&@exprUNIQUE defToken@var812 .@expr5102 next@var819 .@expr5107 next@var821 &&@exprUNIQUE defToken@var812 .@expr5102 next@var819 .@expr5107 next@var821 .@exprUNIQUE op@var822 ==@exprUNIQUE '#'@expr5104 &&@exprUNIQUE defToken@var812 .@expr5102 next@var819 .@expr5107 next@var821 .@expr5112 next@var823 &&@exprUNIQUE defToken@var812 .@expr5102 next@var819 .@expr5107 next@var821 .@expr5112 next@var823 .@exprUNIQUE name@var824 &&@exprUNIQUE sameline (@exprUNIQUE defToken@var812 ,@exprUNIQUE defToken@var812 .@expr5102 next@var819 .@expr5107 next@var821 .@expr5112 next@var823 ) ) {
2131: TokenList temp@var825 (@exprUNIQUE files@var915 ) ;
2132: if ( expandArg (@exprUNIQUE &@expr5120 temp@var825 ,@exprUNIQUE defToken@var812 ,@exprUNIQUE parametertokens@var794 ) ) {
2133: macroName@var818 =@exprUNIQUE temp@var825 .@expr5124 cback (@expr5125 ) .@expr5126 str (@expr5127 ) ; }
2134: if ( expandArg (@exprUNIQUE &@expr5120 temp@var825 ,@exprUNIQUE defToken@var812 .@expr5102 next@var819 .@expr5107 next@var821 .@expr5112 next@var823 ,@exprUNIQUE parametertokens@var794 ) ) {
2135: macroName@var818 +=@exprUNIQUE temp@var825 .@expr5124 cback (@expr5125 ) ?@exprUNIQUE temp@var825 .@expr5124 cback (@expr5125 ) .@expr5126 str (@expr5127 ) :@exprUNIQUE ""@exprUNIQUE ; }
2136: else {
2137: macroName@var818 +=@exprUNIQUE defToken@var812 .@expr5102 next@var819 .@expr5107 next@var821 .@expr5112 next@var823 .@exprUNIQUE str (@exprUNIQUE ) ; }
2138: lastToken@var813 =@exprUNIQUE defToken@var812 .@expr5102 next@var819 .@expr5107 next@var821 .@expr5112 next@var823 ;
2139: }
2140: const bool def@var826 =@exprUNIQUE macros@var792 .@expr4970 find (@exprUNIQUE macroName@var818 ) !=@exprUNIQUE macros@var792 .@expr4974 end (@expr4975 ) ;
2141: output@var789 .@expr4910 push_back (@exprUNIQUE newMacroToken (@exprUNIQUE def@var826 ?@exprUNIQUE "1"@exprUNIQUE :@exprUNIQUE "0"@exprUNIQUE ,@exprUNIQUE loc@var790 ,@exprUNIQUE true@expr4916 ) ) ;
2142: return lastToken@var813 .@exprUNIQUE next@var827 ;
2143: }
2144: }
2145:
2146: output@var789 .@expr4910 push_back (@expr4920 newMacroToken (@expr4919 tok@var791 .@expr4913 str (@expr4914 ) ,@expr4915 loc@var790 ,@expr4917 true@expr4916 ,@expr4918 tok@var791 ) ) ;
2147: return tok@var791 .@expr4921 next@var796 ;
2148: }
2149:
2150: bool expandArg ( TokenList * output@var828 , const Token * tok@var829 , const std :: vector < const Token * > & parametertokens@var830 ) const {
2151: if ( !@exprUNIQUE tok@var829 .@exprUNIQUE name@var831 ) {
2152: return false@expr5154 ; }
2153:
2154: const unsigned int argnr@var832 =@exprUNIQUE getArgNum (@exprUNIQUE tok@var829 .@exprUNIQUE str (@exprUNIQUE ) ) ;
2155: if ( argnr@var832 >=@exprUNIQUE args@var912 .@exprUNIQUE size (@exprUNIQUE ) ) {
2156: return false@expr5154 ; }
2157:
2158:
2159: if ( variadic@var918 &&@exprUNIQUE argnr@var832 +@expr5166 1U >=@exprUNIQUE parametertokens@var830 .@exprUNIQUE size (@exprUNIQUE ) ) {
2160: return true@expr5171 ; }
2161:
2162: for ( const Token * partok@var833 =@exprUNIQUE parametertokens@var830 [@exprUNIQUE argnr@var832 ] .@exprUNIQUE next@var1336 ;@exprUNIQUE partok@var833 !=@exprUNIQUE parametertokens@var830 [@exprUNIQUE argnr@var832 +@expr5166 1U ] ;@exprUNIQUE partok@var833 =@exprUNIQUE partok@var833 .@exprUNIQUE next@var834 ) {
2163: output@var828 .@exprUNIQUE push_back (@exprUNIQUE new@exprUNIQUE Token (@exprUNIQUE *@exprUNIQUE partok@var833 ) ) ; }
2164:
2165: return true@expr5171 ;
2166: }
2167:
2168: bool expandArg ( TokenList * output@var835 , const Token * tok@var836 , const Location & loc@var837 , const std :: unordered_map < std :: string , Macro > & macros@var838 , const std :: set < std :: string > & expandedmacros@var839 , const std :: vector < const Token * > & parametertokens@var840 ) const {
2169: if ( !@exprUNIQUE tok@var836 .@exprUNIQUE name@var841 ) {
2170: return false@expr5190 ; }
2171: const unsigned int argnr@var842 =@exprUNIQUE getArgNum (@exprUNIQUE tok@var836 .@exprUNIQUE str (@exprUNIQUE ) ) ;
2172: if ( argnr@var842 >=@exprUNIQUE args@var912 .@exprUNIQUE size (@exprUNIQUE ) ) {
2173: return false@expr5190 ; }
2174: if ( variadic@var918 &&@exprUNIQUE argnr@var842 +@expr5202 1U >=@exprUNIQUE parametertokens@var840 .@exprUNIQUE size (@exprUNIQUE ) ) {
2175: return true@expr5207 ; }
2176: for ( const Token * partok@var843 =@exprUNIQUE parametertokens@var840 [@exprUNIQUE argnr@var842 ] .@exprUNIQUE next@var1337 ;@exprUNIQUE partok@var843 !=@exprUNIQUE parametertokens@var840 [@exprUNIQUE argnr@var842 +@expr5202 1U ] ;@exprUNIQUE ) {
2177: const MacroMap :: const_iterator it@var844 =@exprUNIQUE macros@var838 .@exprUNIQUE find (@exprUNIQUE partok@var843 .@expr5217 str (@expr5218 ) ) ;
2178: if ( it@var844 !=@exprUNIQUE macros@var838 .@exprUNIQUE end (@exprUNIQUE ) &&@exprUNIQUE !@exprUNIQUE partok@var843 .@exprUNIQUE isExpandedFrom (@exprUNIQUE &@exprUNIQUE it@var844 .@expr5227 second@var845 ) &&@exprUNIQUE ( partok@var843 .@expr5217 str (@expr5218 ) ==@exprUNIQUE name (@expr5233 ) ||@exprUNIQUE expandedmacros@var839 .@exprUNIQUE find (@exprUNIQUE partok@var843 .@expr5217 str (@expr5218 ) ) ==@exprUNIQUE expandedmacros@var839 .@exprUNIQUE end (@exprUNIQUE ) ) ) {
2179: std ::@exprUNIQUE set < std :: string > expandedmacros2@var846 (@exprUNIQUE expandedmacros@var839 ) ;
2180: expandedmacros2@var846 .@exprUNIQUE erase (@exprUNIQUE name (@expr5233 ) ) ;
2181: partok@var843 =@exprUNIQUE it@var844 .@expr5227 second@var845 .@exprUNIQUE expand (@exprUNIQUE output@var835 ,@exprUNIQUE loc@var837 ,@exprUNIQUE partok@var843 ,@exprUNIQUE macros@var838 ,@exprUNIQUE expandedmacros2@var846 ) ;
2182: } else {
2183: output@var835 .@exprUNIQUE push_back (@exprUNIQUE newMacroToken (@exprUNIQUE partok@var843 .@expr5217 str (@expr5218 ) ,@exprUNIQUE loc@var837 ,@exprUNIQUE isReplaced (@exprUNIQUE expandedmacros@var839 ) ,@exprUNIQUE partok@var843 ) ) ;
2184: output@var835 .@expr5267 back (@expr5268 ) .@exprUNIQUE macro@var1331 =@exprUNIQUE partok@var843 .@exprUNIQUE macro@var847 ;
2185: partok@var843 =@exprUNIQUE partok@var843 .@exprUNIQUE next@var848 ;
2186: }
2187: }
2188: if ( tok@var836 .@exprUNIQUE whitespaceahead@var849 &&@exprUNIQUE output@var835 .@expr5267 back (@expr5268 ) ) {
2189: output@var835 .@expr5267 back (@expr5268 ) .@exprUNIQUE whitespaceahead@var1338 = true ; }
2190: return true@expr5207 ;
2191: }
2192:
|
2201:
2202: const Token * expandHash ( TokenList * output@var850 , const Location & loc@var851 , const Token * tok@var852 , const std :: set < std :: string > & expandedmacros@var853 , const std :: vector < const Token * > & parametertokens@var854 ) const {
2203: TokenList tokenListHash@var855 (@exprUNIQUE files@var915 ) ;
2204: const std ::@exprUNIQUE unordered_map < std :: string , Macro > macros2@var856 ;
2205: tok@var852 =@exprUNIQUE expandToken (@exprUNIQUE &@exprUNIQUE tokenListHash@var855 ,@exprUNIQUE loc@var851 ,@exprUNIQUE tok@var852 .@exprUNIQUE next@var857 ,@exprUNIQUE macros2@var856 ,@exprUNIQUE expandedmacros@var853 ,@exprUNIQUE parametertokens@var854 ) ;
2206: std ::@exprUNIQUE ostringstream ostr@var858 ;
2207: ostr@var858 <<@expr5293 '\"'@expr5292 ;
2208: for ( const Token * hashtok@var859 =@exprUNIQUE tokenListHash@var855 .@exprUNIQUE cfront (@exprUNIQUE ) ,@exprUNIQUE *@exprUNIQUE next@expr5298 ;@exprUNIQUE hashtok@var859 ;@exprUNIQUE hashtok@var859 =@exprUNIQUE next@expr5277 ) {
2209: next@expr5277 =@exprUNIQUE hashtok@var859 .@exprUNIQUE next@var860 ;
2210: ostr@var858 <<@exprUNIQUE hashtok@var859 .@exprUNIQUE str (@exprUNIQUE ) ;
2211: if ( next@expr5298 &&@exprUNIQUE hashtok@var859 .@exprUNIQUE whitespaceahead@var861 ) {
2212: ostr@var858 <<@exprUNIQUE ' '@exprUNIQUE ; }
2213: }
2214: ostr@var858 <<@expr5293 '\"'@expr5292 ;
2215: output@var850 .@exprUNIQUE push_back (@exprUNIQUE newMacroToken (@exprUNIQUE escapeString (@exprUNIQUE ostr@var858 .@exprUNIQUE str (@exprUNIQUE ) ) ,@exprUNIQUE loc@var851 ,@exprUNIQUE isReplaced (@exprUNIQUE expandedmacros@var853 ) ) ) ;
2216: return tok@var852 ;
2217: }
2218:
|
2230:
2231: const Token * expandHashHash ( TokenList * output@var862 , const Location & loc@var863 , const Token * tok@var864 , const std :: unordered_map < std :: string , Macro > & macros@var865 , const std :: set < std :: string > & expandedmacros@var866 , const std :: vector < const Token * > & parametertokens@var867 , bool expandResult@var868 = true ) const {
2232: Token@exprUNIQUE *@exprUNIQUE A@var869 ; A@var869 =@exprUNIQUE output@var862 .@exprUNIQUE back (@exprUNIQUE ) ;
2233: if ( !@exprUNIQUE A@var869 ) {
2234: throw@exprUNIQUE invalidHashHash (@exprUNIQUE tok@var864 .@expr5335 location@var870 ,@expr5338 name (@expr5337 ) ,@exprUNIQUE "Missing first argument"@exprUNIQUE ) ; }
2235: if ( !@exprUNIQUE sameline (@exprUNIQUE tok@var864 ,@exprUNIQUE tok@var864 .@expr5344 next@var871 ) ||@exprUNIQUE !@exprUNIQUE sameline (@exprUNIQUE tok@var864 ,@exprUNIQUE tok@var864 .@expr5344 next@var871 .@expr5348 next@var872 ) ) {
2236: throw@exprUNIQUE invalidHashHash ::@exprUNIQUE unexpectedNewline (@exprUNIQUE tok@var864 .@expr5335 location@var870 ,@expr5338 name (@expr5337 ) ) ; }
2237:
2238: const bool canBeConcatenatedWithEqual@var873 =@exprUNIQUE A@var869 .@exprUNIQUE isOneOf (@exprUNIQUE "+-*/%&|^"@exprUNIQUE ) ||@exprUNIQUE A@var869 .@expr5362 str (@expr5363 ) ==@exprUNIQUE "<<"@exprUNIQUE ||@exprUNIQUE A@var869 .@expr5362 str (@expr5363 ) ==@exprUNIQUE ">>"@exprUNIQUE ;
2239: const bool canBeConcatenatedStringOrChar@var874 =@exprUNIQUE isStringLiteral_ (@exprUNIQUE A@var869 .@expr5362 str (@expr5363 ) ) ||@exprUNIQUE isCharLiteral_ (@exprUNIQUE A@var869 .@expr5362 str (@expr5363 ) ) ;
2240: const bool unexpectedA@var875 =@exprUNIQUE !@exprUNIQUE A@var869 .@exprUNIQUE name@var876 &&@exprUNIQUE !@exprUNIQUE A@var869 .@exprUNIQUE number@var877 &&@exprUNIQUE !@exprUNIQUE A@var869 .@expr5362 str (@expr5363 ) .@exprUNIQUE empty (@exprUNIQUE ) &&@exprUNIQUE !@expr5387 canBeConcatenatedWithEqual@var873 &&@exprUNIQUE !@exprUNIQUE canBeConcatenatedStringOrChar@var874 ;
2241:
2242: Token * const B@var878 ; B@var878 =@exprUNIQUE tok@var864 .@expr5344 next@var871 .@expr5348 next@var872 ;
2243: if ( !@expr5394 B@var878 .@expr5393 name@var879 &&@exprUNIQUE !@exprUNIQUE B@var878 .@expr5395 number@var880 &&@exprUNIQUE B@var878 .@expr5398 op@var881 &&@exprUNIQUE !@exprUNIQUE B@var878 .@exprUNIQUE isOneOf (@exprUNIQUE "#="@exprUNIQUE ) ) {
2244: throw@exprUNIQUE invalidHashHash ::@expr5406 unexpectedToken (@exprUNIQUE tok@var864 .@expr5335 location@var870 ,@expr5338 name (@expr5337 ) ,@exprUNIQUE B@var878 ) ; }
2245:
2246: if ( ( canBeConcatenatedWithEqual@var873 &&@exprUNIQUE B@var878 .@expr5398 op@var881 !=@exprUNIQUE '='@expr5410 ) ||@exprUNIQUE
2247: ( !@expr5387 canBeConcatenatedWithEqual@var873 &&@exprUNIQUE B@var878 .@expr5398 op@var881 ==@exprUNIQUE '='@expr5410 ) ) {
2248: throw@expr5421 invalidHashHash ::@expr5417 cannotCombine (@expr5420 tok@var864 .@expr5335 location@var870 ,@expr5338 name (@expr5337 ) ,@expr5418 A@var869 ,@expr5419 B@var878 ) ; }
2249:
2250:
2251: if ( canBeConcatenatedStringOrChar@var874 &&@exprUNIQUE ( B@var878 .@expr5395 number@var880 ||@exprUNIQUE !@expr5394 B@var878 .@expr5393 name@var879 ) ) {
2252: throw@expr5421 invalidHashHash ::@expr5417 cannotCombine (@expr5420 tok@var864 .@expr5335 location@var870 ,@expr5338 name (@expr5337 ) ,@expr5418 A@var869 ,@expr5419 B@var878 ) ; }
2253:
2254: TokenList tokensB@var882 (@exprUNIQUE files@var915 ) ;
2255: const Token * nextTok@var883 ; nextTok@var883 =@exprUNIQUE B@var878 .@expr5425 next@var884 ;
2256:
2257: if ( canBeConcatenatedStringOrChar@var874 ) {
2258: if ( unexpectedA@var875 ) {
2259: throw@expr5428 invalidHashHash ::@expr5406 unexpectedToken (@expr5427 tok@var864 .@expr5335 location@var870 ,@expr5338 name (@expr5337 ) ,@expr5418 A@var869 ) ; }
2260:
2261:
2262:
2263: if ( expandArg (@expr5433 &@expr5430 tokensB@var882 ,@expr5431 B@var878 ,@expr5432 parametertokens@var867 ) ) {
2264: for ( Token * b@var885 =@exprUNIQUE tokensB@var882 .@expr5435 front (@expr5436 ) ;@exprUNIQUE b@var885 ;@exprUNIQUE b@var885 =@exprUNIQUE b@var885 .@exprUNIQUE next@var886 ) {
2265: b@var885 .@exprUNIQUE location@var887 =@exprUNIQUE loc@var863 ; }
2266: } else {
2267: tokensB@var882 .@exprUNIQUE push_back (@exprUNIQUE new@exprUNIQUE Token (@exprUNIQUE *@exprUNIQUE B@var878 ) ) ;
2268: tokensB@var882 .@exprUNIQUE back (@exprUNIQUE ) .@exprUNIQUE location@var1325 =@exprUNIQUE loc@var863 ;
2269: }
2270: output@var862 .@expr5455 takeTokens (@expr5456 tokensB@var882 ) ;
2271: } else {
2272: std ::@exprUNIQUE string strAB@var888 ;
2273:
2274: const bool varargs@var889 =@exprUNIQUE variadic@var918 &&@exprUNIQUE !@exprUNIQUE args@var912 .@exprUNIQUE empty (@exprUNIQUE ) &&@exprUNIQUE B@var878 .@expr5463 str (@expr5464 ) ==@exprUNIQUE args@var912 [@exprUNIQUE args@var912 .@exprUNIQUE size (@exprUNIQUE ) -@exprUNIQUE 1U ] ;
2275:
2276: if ( expandArg (@expr5433 &@expr5430 tokensB@var882 ,@expr5431 B@var878 ,@expr5432 parametertokens@var867 ) ) {
2277: if ( tokensB@var882 .@expr5474 empty (@expr5475 ) ) {
2278: strAB@var888 =@exprUNIQUE A@var869 .@expr5362 str (@expr5363 ) ; }
2279: else { if ( varargs@var889 &&@exprUNIQUE A@var869 .@exprUNIQUE op@var890 ==@exprUNIQUE ','@exprUNIQUE ) {
2280: strAB@var888 = "," ; }
2281: else { if ( varargs@var889 &&@exprUNIQUE unexpectedA@var875 ) {
2282: throw@expr5428 invalidHashHash ::@expr5406 unexpectedToken (@expr5427 tok@var864 .@expr5335 location@var870 ,@expr5338 name (@expr5337 ) ,@expr5418 A@var869 ) ; }
2283: else {
2284: strAB@var888 =@exprUNIQUE A@var869 .@expr5362 str (@expr5363 ) +@exprUNIQUE tokensB@var882 .@exprUNIQUE cfront (@exprUNIQUE ) .@exprUNIQUE str (@exprUNIQUE ) ;
2285: tokensB@var882 .@exprUNIQUE deleteToken (@exprUNIQUE tokensB@var882 .@expr5435 front (@expr5436 ) ) ;
2286: } } }
2287: } else {
2288: if ( unexpectedA@var875 ) {
2289: throw@expr5428 invalidHashHash ::@expr5406 unexpectedToken (@expr5427 tok@var864 .@expr5335 location@var870 ,@expr5338 name (@expr5337 ) ,@expr5418 A@var869 ) ; }
2290: strAB@var888 =@exprUNIQUE A@var869 .@expr5362 str (@expr5363 ) +@exprUNIQUE B@var878 .@expr5463 str (@expr5464 ) ;
2291: }
2292:
2293:
2294: if ( A@var869 .@expr5494 previous@var891 &&@exprUNIQUE A@var869 .@expr5494 previous@var891 .@exprUNIQUE str (@exprUNIQUE ) ==@exprUNIQUE "\\"@exprUNIQUE ) {
2295: if ( strAB@var888 [@expr5501 0 ] ==@exprUNIQUE 'u'@exprUNIQUE &&@exprUNIQUE strAB@var888 .@expr5504 size (@expr5505 ) ==@exprUNIQUE 5 ) {
2296: throw@expr5513 invalidHashHash ::@expr5510 universalCharacterUB (@expr5512 tok@var864 .@expr5335 location@var870 ,@expr5338 name (@expr5337 ) ,@expr5418 A@var869 ,@expr5511 strAB@var888 ) ; }
2297: if ( strAB@var888 [@expr5501 0 ] ==@exprUNIQUE 'U'@exprUNIQUE &&@exprUNIQUE strAB@var888 .@expr5504 size (@expr5505 ) ==@exprUNIQUE 9 ) {
2298: throw@expr5513 invalidHashHash ::@expr5510 universalCharacterUB (@expr5512 tok@var864 .@expr5335 location@var870 ,@expr5338 name (@expr5337 ) ,@expr5418 A@var869 ,@expr5511 strAB@var888 ) ; }
2299: }
2300:
2301: if ( varargs@var889 &&@exprUNIQUE tokensB@var882 .@expr5474 empty (@expr5475 ) &&@exprUNIQUE tok@var864 .@exprUNIQUE previous@var892 .@exprUNIQUE str (@exprUNIQUE ) ==@exprUNIQUE ","@expr5523 ) {
2302: output@var862 .@expr5526 deleteToken (@expr5527 A@var869 ) ; }
2303: else { if ( strAB@var888 !=@exprUNIQUE ","@expr5523 &&@exprUNIQUE macros@var865 .@expr5530 find (@expr5531 strAB@var888 ) ==@exprUNIQUE macros@var865 .@expr5533 end (@expr5534 ) ) {
2304: A@var869 .@exprUNIQUE setstr (@exprUNIQUE strAB@var888 ) ;
2305: for ( Token * b@var893 =@exprUNIQUE tokensB@var882 .@expr5435 front (@expr5436 ) ;@exprUNIQUE b@var893 ;@exprUNIQUE b@var893 =@exprUNIQUE b@var893 .@exprUNIQUE next@var894 ) {
2306: b@var893 .@exprUNIQUE location@var895 =@exprUNIQUE loc@var863 ; }
2307: output@var862 .@expr5455 takeTokens (@expr5456 tokensB@var882 ) ;
2308: } else { if ( sameline (@exprUNIQUE B@var878 ,@exprUNIQUE nextTok@var883 ) &&@exprUNIQUE sameline (@exprUNIQUE B@var878 ,@exprUNIQUE nextTok@var883 .@expr5549 next@var896 ) &&@exprUNIQUE nextTok@var883 .@exprUNIQUE op@var897 ==@exprUNIQUE '#'@expr5554 &&@exprUNIQUE nextTok@var883 .@expr5549 next@var896 .@exprUNIQUE op@var898 ==@exprUNIQUE '#'@expr5554 ) {
2309: TokenList output2@var899 (@exprUNIQUE files@var915 ) ;
2310: output2@var899 .@exprUNIQUE push_back (@exprUNIQUE new@expr5564 Token (@expr5563 strAB@var888 ,@expr5562 tok@var864 .@expr5335 location@var870 ) ) ;
2311: nextTok@var883 =@exprUNIQUE expandHashHash (@exprUNIQUE &@exprUNIQUE output2@var899 ,@exprUNIQUE loc@var863 ,@exprUNIQUE nextTok@var883 ,@exprUNIQUE macros@var865 ,@exprUNIQUE expandedmacros@var866 ,@exprUNIQUE parametertokens@var867 ) ;
2312: output@var862 .@expr5526 deleteToken (@expr5527 A@var869 ) ;
2313: output@var862 .@expr5455 takeTokens (@exprUNIQUE output2@var899 ) ;
2314: } else {
2315: output@var862 .@expr5526 deleteToken (@expr5527 A@var869 ) ;
2316: TokenList tokens@var900 (@exprUNIQUE files@var915 ) ;
2317: tokens@var900 .@exprUNIQUE push_back (@exprUNIQUE new@expr5564 Token (@expr5563 strAB@var888 ,@expr5562 tok@var864 .@expr5335 location@var870 ) ) ;
2318:
2319: if ( tokensB@var882 .@expr5474 empty (@expr5475 ) &&@exprUNIQUE sameline (@exprUNIQUE B@var878 ,@exprUNIQUE B@var878 .@expr5425 next@var884 ) &&@exprUNIQUE B@var878 .@expr5425 next@var884 .@exprUNIQUE op@var901 ==@exprUNIQUE '('@exprUNIQUE ) {
2320: const MacroMap :: const_iterator it@var902 =@exprUNIQUE macros@var865 .@expr5530 find (@expr5531 strAB@var888 ) ;
2321: if ( it@var902 !=@exprUNIQUE macros@var865 .@expr5533 end (@expr5534 ) &&@exprUNIQUE expandedmacros@var866 .@exprUNIQUE find (@exprUNIQUE strAB@var888 ) ==@exprUNIQUE expandedmacros@var866 .@exprUNIQUE end (@exprUNIQUE ) &&@exprUNIQUE it@var902 .@exprUNIQUE second@var903 .@exprUNIQUE functionLike (@exprUNIQUE ) ) {
2322: const Token * const tok2@var904 ; tok2@var904 =@exprUNIQUE appendTokens (@exprUNIQUE &@exprUNIQUE tokens@var900 ,@exprUNIQUE loc@var863 ,@exprUNIQUE B@var878 .@expr5425 next@var884 ,@exprUNIQUE macros@var865 ,@exprUNIQUE expandedmacros@var866 ,@exprUNIQUE parametertokens@var867 ) ;
2323: if ( tok2@var904 ) {
2324: nextTok@var883 =@exprUNIQUE tok2@var904 .@exprUNIQUE next@var905 ; }
2325: }
2326: }
2327: if ( expandResult@var868 ) {
2328: expandToken (@exprUNIQUE output@var862 ,@exprUNIQUE loc@var863 ,@exprUNIQUE tokens@var900 .@exprUNIQUE cfront (@exprUNIQUE ) ,@exprUNIQUE macros@var865 ,@exprUNIQUE expandedmacros@var866 ,@exprUNIQUE parametertokens@var867 ) ; }
2329: else {
2330: output@var862 .@expr5455 takeTokens (@exprUNIQUE tokens@var900 ) ; }
2331: for ( Token * b@var906 =@exprUNIQUE tokensB@var882 .@expr5435 front (@expr5436 ) ;@exprUNIQUE b@var906 ;@exprUNIQUE b@var906 =@exprUNIQUE b@var906 .@exprUNIQUE next@var907 ) {
2332: b@var906 .@exprUNIQUE location@var908 =@exprUNIQUE loc@var863 ; }
2333: output@var862 .@expr5455 takeTokens (@expr5456 tokensB@var882 ) ;
2334: } } }
2335: }
2336:
2337: return nextTok@var883 ;
2338: }
2339:
2340: static bool isReplaced ( const std :: set < std :: string > & expandedmacros@var909 ) {
2341:
2342: std ::@exprUNIQUE set < std :: string > ::@exprUNIQUE const_iterator it@var910 ; it@var910 =@exprUNIQUE expandedmacros@var909 .@exprUNIQUE begin (@exprUNIQUE ) ;
2343: if ( it@var910 ==@exprUNIQUE expandedmacros@var909 .@expr5636 end (@expr5637 ) ) {
2344: return false@exprUNIQUE ; }
2345: ++@exprUNIQUE it@var910 ;
2346: return ( it@var910 !=@exprUNIQUE expandedmacros@var909 .@expr5636 end (@expr5637 ) ) ;
2347: }
2348:
2349:
2350: const Token * nameTokDef@var911 ;
2351:
2352:
2353: std :: vector < std :: string > args@var912 ;
2354:
2355:
2356: const Token * valueToken@var913 ;
2357:
2358:
2359: const Token * endToken@var914 ;
2360:
2361:
2362: std :: vector < std :: string > & files@var915 ;
2363:
2364:
2365: TokenList tokenListDefine@var916 ;
2366:
2367:
2368: mutable std :: list < Location > usageList@var917 ;
2369:
2370:
2371: bool variadic@var918 ;
2372:
2373:
2374: bool variadicOpt@var919 ;
2375:
2376:
2377: const TokenList * optExpandValue@var920 ;
2378: const TokenList * optNoExpandValue@var921 ;
2379:
2380:
2381: bool valueDefinedInCode_@var922 ;
2382: } ;
2383: }
2384:
|
2427:
2428: static bool isAbsolutePath ( const std :: string & path@var932 )
2429: {
2430: return path@var932 .@exprUNIQUE length (@exprUNIQUE ) >@exprUNIQUE 1U &&@exprUNIQUE path@var932 [@exprUNIQUE 0 ] ==@exprUNIQUE '/'@exprUNIQUE ;
2431: }
2432:
2433:
2434: namespace simplecpp {
2435:
2436:
2437:
2438: std :: string simplifyPath ( std ::@exprUNIQUE string path@var933 )
2439: {
2440: if ( path@var933 .@expr8206 empty (@expr8207 ) ) {
2441: return path@var933 ; }
2442:
2443: std ::@expr8209 string ::@exprUNIQUE size_type pos@var934 ;
2444:
2445:
2446: std ::@exprUNIQUE replace (@exprUNIQUE path@var933 .@exprUNIQUE begin (@exprUNIQUE ) ,@exprUNIQUE path@var933 .@exprUNIQUE end (@exprUNIQUE ) ,@exprUNIQUE '\\'@exprUNIQUE ,@exprUNIQUE '/'@expr8232 ) ;
2447:
2448: const bool unc@var935 (@exprUNIQUE path@var933 .@exprUNIQUE compare (@exprUNIQUE 0 ,@exprUNIQUE 2 ,@exprUNIQUE "//"@expr8243 ) ==@exprUNIQUE 0 ) ;
2449:
2450:
2451: pos@var934 = 0 ;
2452: while ( ( pos@var934 =@exprUNIQUE path@var933 .@expr8249 find (@exprUNIQUE "//"@expr8243 ,@exprUNIQUE pos@var934 ) ) !=@exprUNIQUE std ::@expr8209 string ::@expr8260 npos ) {
2453: path@var933 .@expr8263 erase (@exprUNIQUE pos@var934 ,@exprUNIQUE 1 ) ;
2454: }
2455:
2456:
2457: pos@var934 = 0 ;
2458: while ( ( pos@var934 =@exprUNIQUE path@var933 .@expr8249 find (@exprUNIQUE "./"@exprUNIQUE ,@exprUNIQUE pos@var934 ) ) !=@exprUNIQUE std ::@expr8209 string ::@expr8260 npos ) {
2459: if ( pos@var934 ==@exprUNIQUE 0 ||@exprUNIQUE path@var933 [@exprUNIQUE pos@var934 -@expr8281 1U ] ==@exprUNIQUE '/'@expr8232 ) {
2460: path@var933 .@expr8263 erase (@exprUNIQUE pos@var934 ,@exprUNIQUE 2 ) ; }
2461: else {
2462: pos@var934 +=@exprUNIQUE 2 ; }
2463: }
2464:
2465:
2466: if ( endsWith (@exprUNIQUE path@var933 ,@exprUNIQUE "/."@exprUNIQUE ) ) {
2467: path@var933 .@expr8263 erase (@exprUNIQUE path@var933 .@expr8298 size (@expr8299 ) -@exprUNIQUE 1 ) ; }
2468:
2469:
2470: pos@var934 = 1 ;
2471: while ( ( pos@var934 =@exprUNIQUE path@var933 .@expr8249 find (@exprUNIQUE "/.."@exprUNIQUE ,@exprUNIQUE pos@var934 ) ) !=@exprUNIQUE std ::@expr8209 string ::@expr8260 npos ) {
2472:
2473: if ( pos@var934 +@expr8313 3 <@exprUNIQUE path@var933 .@expr8298 size (@expr8299 ) &&@exprUNIQUE path@var933 [@exprUNIQUE pos@var934 +@expr8313 3 ] !=@exprUNIQUE '/'@expr8232 ) {
2474: ++@exprUNIQUE pos@var934 ;
2475: continue ;
2476: }
2477:
2478: std ::@expr8209 string ::@exprUNIQUE size_type pos1@var936 ; pos1@var936 =@exprUNIQUE path@var933 .@exprUNIQUE rfind (@exprUNIQUE '/'@expr8232 ,@exprUNIQUE pos@var934 -@expr8281 1U ) ;
2479: if ( pos1@var936 ==@exprUNIQUE std ::@expr8209 string ::@expr8260 npos ) {
2480: pos1@var936 = 0 ;
2481: } else {
2482: pos1@var936 +=@exprUNIQUE 1U ;
2483: }
2484: const std :: string previousSubPath@var937 =@exprUNIQUE path@var933 .@exprUNIQUE substr (@exprUNIQUE pos1@var936 ,@exprUNIQUE pos@var934 -@expr5747 pos1@var936 ) ;
2485: if ( previousSubPath@var937 ==@exprUNIQUE ".."@exprUNIQUE ) {
2486:
2487: ++@exprUNIQUE pos@var934 ;
2488: } else {
2489:
2490: path@var933 .@expr8263 erase (@exprUNIQUE pos1@var936 ,@exprUNIQUE pos@var934 -@expr5747 pos1@var936 +@exprUNIQUE 4 ) ;
2491: if ( path@var933 .@expr8206 empty (@expr8207 ) ) {
2492: path@var933 = "." ; }
2493:
2494: pos@var934 =@exprUNIQUE ( pos1@var936 ==@exprUNIQUE 0 ) ?@exprUNIQUE 1 :@exprUNIQUE ( pos1@var936 -@exprUNIQUE 1 ) ;
2495: }
2496: }
2497:
|
2501:
2502: if ( unc@var935 ) {
2503: path@var933 =@exprUNIQUE '/'@expr8232 +@exprUNIQUE path@var933 ; }
2504:
2505: return path@var933 ;
2506: }
2507: }
2508:
2509:
2510: static void simplifySizeof ( simplecpp :: TokenList & expr@var938 , const std :: map < std :: string , unsigned long > & sizeOfType@var939 )
2511: {
2512: for ( simplecpp :: Token * tok@var940 =@exprUNIQUE expr@var938 .@exprUNIQUE front (@exprUNIQUE ) ;@exprUNIQUE tok@var940 ;@exprUNIQUE tok@var940 =@exprUNIQUE tok@var940 .@expr5770 next@var941 ) {
2513: if ( tok@var940 .@exprUNIQUE str (@exprUNIQUE ) !=@exprUNIQUE "sizeof"@exprUNIQUE ) {
2514: continue ; }
2515: simplecpp ::@expr5781 Token *@exprUNIQUE tok1@var942 ; tok1@var942 =@exprUNIQUE tok@var940 .@expr5770 next@var941 ;
2516: if ( !@exprUNIQUE tok1@var942 ) {
2517: throw@expr5790 std ::@expr5787 runtime_error (@expr5789 "missing sizeof argument"@expr5788 ) ;
2518: }
2519: simplecpp ::@expr5781 Token *@exprUNIQUE tok2@var943 ; tok2@var943 =@exprUNIQUE tok1@var942 .@expr5792 next@var944 ;
2520: if ( !@expr5794 tok2@var943 ) {
2521: throw@expr5790 std ::@expr5787 runtime_error (@expr5789 "missing sizeof argument"@expr5788 ) ;
2522: }
2523: if ( tok1@var942 .@exprUNIQUE op@var945 ==@exprUNIQUE '('@exprUNIQUE ) {
2524: tok1@var942 =@exprUNIQUE tok1@var942 .@expr5792 next@var944 ;
2525: while ( tok2@var943 .@exprUNIQUE op@var946 !=@exprUNIQUE ')'@exprUNIQUE ) {
2526: tok2@var943 =@expr5803 tok2@var943 .@expr5802 next@var947 ;
2527: if ( !@expr5794 tok2@var943 ) {
2528: throw@exprUNIQUE std ::@expr5787 runtime_error (@exprUNIQUE "invalid sizeof expression"@exprUNIQUE ) ;
2529: }
2530: }
2531: }
2532:
2533: std ::@exprUNIQUE string type@var948 ;
2534: for ( simplecpp :: Token * typeToken@var949 =@exprUNIQUE tok1@var942 ;@exprUNIQUE typeToken@var949 !=@exprUNIQUE tok2@var943 ;@exprUNIQUE typeToken@var949 =@exprUNIQUE typeToken@var949 .@expr5810 next@var950 ) {
2535: if ( ( typeToken@var949 .@expr5814 str (@expr5815 ) ==@exprUNIQUE "unsigned"@exprUNIQUE ||@exprUNIQUE typeToken@var949 .@expr5814 str (@expr5815 ) ==@exprUNIQUE "signed"@exprUNIQUE ) &&@exprUNIQUE typeToken@var949 .@expr5810 next@var950 .@exprUNIQUE name@var951 ) {
2536: continue ; }
2537: if ( typeToken@var949 .@expr5814 str (@expr5815 ) ==@exprUNIQUE "*"@exprUNIQUE &&@exprUNIQUE type@var948 .@exprUNIQUE find (@exprUNIQUE '*'@exprUNIQUE ) !=@exprUNIQUE std ::@exprUNIQUE string ::@exprUNIQUE npos ) {
2538: continue ; }
2539: if ( !@exprUNIQUE type@var948 .@exprUNIQUE empty (@exprUNIQUE ) ) {
2540: type@var948 +=@exprUNIQUE ' '@exprUNIQUE ; }
2541: type@var948 +=@exprUNIQUE typeToken@var949 .@expr5814 str (@expr5815 ) ;
2542: }
2543:
2544: const std :: map < std :: string , unsigned long > :: const_iterator it@var952 =@exprUNIQUE sizeOfType@var939 .@exprUNIQUE find (@exprUNIQUE type@var948 ) ;
2545: if ( it@var952 !=@exprUNIQUE sizeOfType@var939 .@exprUNIQUE end (@exprUNIQUE ) ) {
2546: tok@var940 .@exprUNIQUE setstr (@exprUNIQUE toString (@exprUNIQUE it@var952 .@exprUNIQUE second@var953 ) ) ; }
2547: else {
2548: continue ; }
2549:
2550: tok2@var943 =@expr5803 tok2@var943 .@expr5802 next@var947 ;
2551: while ( tok@var940 .@expr5770 next@var941 !=@exprUNIQUE tok2@var943 ) {
2552: expr@var938 .@exprUNIQUE deleteToken (@exprUNIQUE tok@var940 .@expr5770 next@var941 ) ; }
2553: }
2554: }
2555:
2556: static bool isCpp17OrLater ( const simplecpp :: DUI & dui@var954 )
2557: {
2558: const std :: string std_ver@var955 =@exprUNIQUE simplecpp ::@exprUNIQUE getCppStdString (@exprUNIQUE dui@var954 .@exprUNIQUE std@var956 ) ;
2559: return !@exprUNIQUE std_ver@var955 .@exprUNIQUE empty (@exprUNIQUE ) &&@exprUNIQUE ( std_ver@var955 >=@exprUNIQUE "201703L"@exprUNIQUE ) ;
2560: }
2561:
2562: static bool isGnu ( const simplecpp :: DUI & dui@var957 )
2563: {
2564: return dui@var957 .@exprUNIQUE std@var958 .@exprUNIQUE rfind (@exprUNIQUE "gnu"@exprUNIQUE ,@exprUNIQUE 0 ) !=@exprUNIQUE std ::@exprUNIQUE string ::@exprUNIQUE npos ;
2565: }
2566:
2567: static std :: string dirPath ( const std :: string & path@var959 , bool withTrailingSlash@var960 = true )
2568: {
2569: const unsigned long lastSlash@var961 =@exprUNIQUE path@var959 .@exprUNIQUE find_last_of (@exprUNIQUE "\\/"@exprUNIQUE ) ;
2570: if ( lastSlash@var961 ==@exprUNIQUE std ::@exprUNIQUE string ::@exprUNIQUE npos ) {
2571: return ""@exprUNIQUE ;
2572: }
2573: return path@var959 .@exprUNIQUE substr (@exprUNIQUE 0 ,@exprUNIQUE lastSlash@var961 +@exprUNIQUE ( withTrailingSlash@var960 ?@exprUNIQUE 1U :@exprUNIQUE 0U ) ) ;
2574: }
2575:
2576: static std :: string openHeader ( std :: ifstream & f@var962 , const simplecpp :: DUI & dui@var963 , const std :: string & sourcefile@var964 , const std :: string & header@var965 , bool systemheader@var966 ) ;
2577: static void simplifyHasInclude ( simplecpp :: TokenList & expr@var967 , const simplecpp :: DUI & dui@var968 )
2578: {
2579: if ( !@exprUNIQUE isCpp17OrLater (@exprUNIQUE dui@var968 ) &&@exprUNIQUE !@exprUNIQUE isGnu (@exprUNIQUE dui@var968 ) ) {
2580: return ; }
2581:
2582: for ( simplecpp :: Token * tok@var969 =@exprUNIQUE expr@var967 .@exprUNIQUE front (@exprUNIQUE ) ;@exprUNIQUE tok@var969 ;@exprUNIQUE tok@var969 =@exprUNIQUE tok@var969 .@expr5927 next@var970 ) {
2583: if ( tok@var969 .@exprUNIQUE str (@exprUNIQUE ) !=@exprUNIQUE HAS_INCLUDE@var222 ) {
2584: continue ; }
2585: simplecpp ::@expr5937 Token *@exprUNIQUE tok1@var971 ; tok1@var971 =@exprUNIQUE tok@var969 .@expr5927 next@var970 ;
2586: if ( !@exprUNIQUE tok1@var971 ) {
2587: throw@expr5946 std ::@expr5943 runtime_error (@expr5945 "missing __has_include argument"@expr5944 ) ;
2588: }
2589: simplecpp ::@expr5937 Token *@exprUNIQUE tok2@var972 ; tok2@var972 =@exprUNIQUE tok1@var971 .@expr5948 next@var973 ;
2590: if ( !@expr5950 tok2@var972 ) {
2591: throw@expr5946 std ::@expr5943 runtime_error (@expr5945 "missing __has_include argument"@expr5944 ) ;
2592: }
2593: if ( tok1@var971 .@expr5951 op@var974 ==@exprUNIQUE '('@exprUNIQUE ) {
2594: tok1@var971 =@exprUNIQUE tok1@var971 .@expr5948 next@var973 ;
2595: while ( tok2@var972 .@exprUNIQUE op@var975 !=@exprUNIQUE ')'@exprUNIQUE ) {
2596: tok2@var972 =@expr5959 tok2@var972 .@expr5958 next@var976 ;
2597: if ( !@expr5950 tok2@var972 ) {
2598: throw@expr5962 std ::@expr5943 runtime_error (@expr5961 "invalid __has_include expression"@expr5960 ) ;
2599: }
2600: }
2601: }
2602:
2603: const std :: string & sourcefile@var977 =@exprUNIQUE tok@var969 .@exprUNIQUE location@var978 .@exprUNIQUE file (@exprUNIQUE ) ;
2604: const bool systemheader@var979 =@exprUNIQUE tok1@var971 &&@exprUNIQUE tok1@var971 .@expr5951 op@var974 ==@exprUNIQUE '<'@exprUNIQUE ;
2605: std ::@exprUNIQUE string header@var980 ;
2606: if ( systemheader@var979 ) {
2607: simplecpp ::@expr5937 Token *@exprUNIQUE tok3@var981 ; tok3@var981 =@exprUNIQUE tok1@var971 .@expr5948 next@var973 ;
2608: if ( !@expr5975 tok3@var981 ) {
2609: throw@exprUNIQUE std ::@expr5943 runtime_error (@exprUNIQUE "missing __has_include closing angular bracket"@exprUNIQUE ) ;
2610: }
2611: while ( tok3@var981 .@exprUNIQUE op@var982 !=@exprUNIQUE '>'@exprUNIQUE ) {
2612: tok3@var981 =@exprUNIQUE tok3@var981 .@exprUNIQUE next@var983 ;
2613: if ( !@expr5975 tok3@var981 ) {
2614: throw@expr5962 std ::@expr5943 runtime_error (@expr5961 "invalid __has_include expression"@expr5960 ) ;
2615: }
2616: }
2617:
2618: for ( simplecpp :: Token * headerToken@var984 =@exprUNIQUE tok1@var971 .@expr5948 next@var973 ;@exprUNIQUE headerToken@var984 !=@exprUNIQUE tok3@var981 ;@exprUNIQUE headerToken@var984 =@exprUNIQUE headerToken@var984 .@exprUNIQUE next@var985 ) {
2619: header@var980 +=@exprUNIQUE headerToken@var984 .@exprUNIQUE str (@exprUNIQUE ) ; }
2620: } else {
2621: header@var980 =@exprUNIQUE tok1@var971 .@expr5993 str (@expr5994 ) .@exprUNIQUE substr (@exprUNIQUE 1U ,@exprUNIQUE tok1@var971 .@expr5993 str (@expr5994 ) .@exprUNIQUE size (@exprUNIQUE ) -@exprUNIQUE 2U ) ;
2622: }
2623: std ::@exprUNIQUE ifstream f@var986 ;
2624: const std :: string header2@var987 =@exprUNIQUE openHeader (@exprUNIQUE f@var986 ,@exprUNIQUE dui@var968 ,@exprUNIQUE sourcefile@var977 ,@exprUNIQUE header@var980 ,@exprUNIQUE systemheader@var979 ) ;
2625: tok@var969 .@exprUNIQUE setstr (@exprUNIQUE header2@var987 .@exprUNIQUE empty (@exprUNIQUE ) ?@exprUNIQUE "0"@exprUNIQUE :@exprUNIQUE "1"@exprUNIQUE ) ;
2626:
2627: tok2@var972 =@expr5959 tok2@var972 .@expr5958 next@var976 ;
2628: while ( tok@var969 .@expr5927 next@var970 !=@exprUNIQUE tok2@var972 ) {
2629: expr@var967 .@exprUNIQUE deleteToken (@exprUNIQUE tok@var969 .@expr5927 next@var970 ) ; }
2630: }
2631: }
2632:
2633: static const char * const altopData@var988 [ 8 ] = { "and" , "or" , "bitand" , "bitor" , "compl" , "not" , "not_eq" , "xor" } ;
2634: static const std :: set < std :: string > altop@var989 ( & altopData@var988 [ 0 ] , & altopData@var988 [ 8 ] ) ;
2635: static void simplifyName ( simplecpp :: TokenList & expr@var990 )
2636: {
2637: for ( simplecpp :: Token * tok@var991 =@exprUNIQUE expr@var990 .@exprUNIQUE front (@exprUNIQUE ) ;@exprUNIQUE tok@var991 ;@exprUNIQUE tok@var991 =@exprUNIQUE tok@var991 .@expr6032 next@var992 ) {
2638: if ( tok@var991 .@exprUNIQUE name@var993 ) {
2639: if ( altop@var989 .@exprUNIQUE find (@exprUNIQUE tok@var991 .@expr6040 str (@expr6041 ) ) !=@exprUNIQUE altop@var989 .@exprUNIQUE end (@exprUNIQUE ) ) {
2640: bool alt@var994 ;
2641: if ( tok@var991 .@expr6040 str (@expr6041 ) ==@exprUNIQUE "not"@exprUNIQUE ||@exprUNIQUE tok@var991 .@expr6040 str (@expr6041 ) ==@exprUNIQUE "compl"@exprUNIQUE ) {
2642: alt@var994 =@exprUNIQUE isAlternativeUnaryOp (@exprUNIQUE tok@var991 ,@expr6053 tok@var991 .@expr6040 str (@expr6041 ) ) ;
2643: } else {
2644: alt@var994 =@exprUNIQUE isAlternativeBinaryOp (@exprUNIQUE tok@var991 ,@expr6053 tok@var991 .@expr6040 str (@expr6041 ) ) ;
2645: }
2646: if ( alt@var994 ) {
2647: continue ; }
2648: }
2649: if ( tok@var991 .@expr6032 next@var992 &&@exprUNIQUE tok@var991 .@expr6032 next@var992 .@exprUNIQUE str (@exprUNIQUE ) ==@exprUNIQUE "("@exprUNIQUE ) {
2650: throw@exprUNIQUE std ::@exprUNIQUE runtime_error (@exprUNIQUE "undefined function-like macro invocation: "@exprUNIQUE +@exprUNIQUE tok@var991 .@expr6040 str (@expr6041 ) +@exprUNIQUE "( ... )"@exprUNIQUE ) ; }
2651: tok@var991 .@exprUNIQUE setstr (@exprUNIQUE "0"@exprUNIQUE ) ;
2652: }
2653: }
2654: }
2655:
|
2663:
2664: static unsigned long long stringToULLbounded (
2665: const std :: string & s@var995 ,
2666: unsigned long & pos@var996 ,
2667: int base@var997 = 0 ,
2668: long minlen@var998 = 1 ,
2669: unsigned long maxlen@var999 = std :: string :: npos
2670: )
2671: {
2672: const std :: string sub@var1000 =@exprUNIQUE s@var995 .@exprUNIQUE substr (@exprUNIQUE pos@var996 ,@exprUNIQUE maxlen@var999 ) ;
2673: const char * const start@var1001 ; start@var1001 =@exprUNIQUE sub@var1000 .@exprUNIQUE c_str (@exprUNIQUE ) ;
2674: char * end@var1002 ;
2675: const unsigned long long value@var1003 =@exprUNIQUE std ::@exprUNIQUE strtoull (@exprUNIQUE start@var1001 ,@exprUNIQUE &@exprUNIQUE end@var1002 ,@exprUNIQUE base@var997 ) ;
2676: pos@var996 +=@exprUNIQUE end@var1002 -@expr6094 start@var1001 ;
2677: if ( end@var1002 -@expr6094 start@var1001 <@exprUNIQUE minlen@var998 ) {
2678: throw@exprUNIQUE std ::@exprUNIQUE runtime_error (@exprUNIQUE "expected digit"@exprUNIQUE ) ; }
2679: return value@var1003 ;
2680: }
2681:
|
2709:
2710: long long simplecpp :: characterLiteralToLL ( const std :: string & str@var1004 )
2711: {
2712:
2713: bool narrow@var1005 ; narrow@var1005 = false ;
2714: bool utf8@var1006 ; utf8@var1006 = false ;
2715: bool utf16@var1007 ; utf16@var1007 = false ;
2716:
2717: unsigned long pos@var1008 ;
2718:
2719: if ( !@exprUNIQUE str@var1004 .@exprUNIQUE empty (@exprUNIQUE ) &&@exprUNIQUE str@var1004 [@expr6107 0 ] ==@exprUNIQUE '\''@expr6108 ) {
2720: narrow@var1005 = true ;
2721: pos@var1008 = 1 ;
2722: } else { if ( str@var1004 .@expr6112 size (@expr6113 ) >=@expr6115 2 &&@exprUNIQUE str@var1004 [@expr6107 0 ] ==@expr6117 'u'@expr6116 &&@exprUNIQUE str@var1004 [@expr6120 1 ] ==@expr6121 '\''@expr6108 ) {
2723: utf16@var1007 = true ;
2724: pos@var1008 = 2 ;
2725: } else { if ( str@var1004 .@expr6112 size (@expr6113 ) >=@exprUNIQUE 3 &&@exprUNIQUE str@var1004 [@expr6107 0 ] ==@expr6117 'u'@expr6116 &&@exprUNIQUE str@var1004 [@expr6120 1 ] ==@exprUNIQUE '8'@exprUNIQUE &&@exprUNIQUE str@var1004 [@exprUNIQUE 2 ] ==@exprUNIQUE '\''@expr6108 ) {
2726: utf8@var1006 = true ;
2727: pos@var1008 = 3 ;
2728: } else { if ( str@var1004 .@expr6112 size (@expr6113 ) >=@expr6115 2 &&@exprUNIQUE ( str@var1004 [@expr6107 0 ] ==@exprUNIQUE 'L'@exprUNIQUE ||@exprUNIQUE str@var1004 [@expr6107 0 ] ==@exprUNIQUE 'U'@expr6134 ) &&@exprUNIQUE str@var1004 [@expr6120 1 ] ==@expr6121 '\''@expr6108 ) {
2729: pos@var1008 = 2 ;
2730: } else {
2731: throw@exprUNIQUE std ::@expr6141 runtime_error (@exprUNIQUE "expected a character literal"@exprUNIQUE ) ; } } } }
2732:
2733: unsigned long long multivalue@var1009 ; multivalue@var1009 = 0 ;
2734:
2735: unsigned long nbytes@var1010 ; nbytes@var1010 = 0 ;
2736:
2737: while ( pos@var1008 +@expr6145 1 <@exprUNIQUE str@var1004 .@expr6112 size (@expr6113 ) ) {
2738: if ( str@var1004 [@expr6147 pos@var1008 ] ==@exprUNIQUE '\''@expr6108 ||@exprUNIQUE str@var1004 [@expr6147 pos@var1008 ] ==@exprUNIQUE '\n'@expr6149 ) {
2739: throw@exprUNIQUE std ::@expr6141 runtime_error (@exprUNIQUE "raw single quotes and newlines not allowed in character literals"@exprUNIQUE ) ; }
2740:
2741: if ( nbytes@var1010 >=@exprUNIQUE 1 &&@exprUNIQUE !@expr6156 narrow@var1005 ) {
2742: throw@exprUNIQUE std ::@expr6141 runtime_error (@exprUNIQUE "multiple characters only supported in narrow character literals"@exprUNIQUE ) ; }
2743:
2744: unsigned long long value@var1011 ;
2745:
2746: if ( str@var1004 [@expr6147 pos@var1008 ] ==@exprUNIQUE '\\'@expr6161 ) {
2747: pos@var1008 ++@exprUNIQUE ;
2748: const char escape@var1012 =@exprUNIQUE str@var1004 [@exprUNIQUE pos@var1008 ++@exprUNIQUE ] ;
2749:
2750: if ( pos@var1008 >=@exprUNIQUE str@var1004 .@expr6112 size (@expr6113 ) ) {
2751: throw@exprUNIQUE std ::@expr6141 runtime_error (@exprUNIQUE "unexpected end of character literal"@exprUNIQUE ) ; }
2752:
2753: switch ( escape@var1012 ) {
2754:
2755: case '%'@exprUNIQUE :
2756: case '('@exprUNIQUE :
2757: case '['@exprUNIQUE :
2758: case '{'@exprUNIQUE :
2759:
2760: case '\''@expr6108 :
2761: case '"'@exprUNIQUE :
2762: case '?'@exprUNIQUE :
2763: case '\\'@expr6161 : ;
2764: value@var1011 =@exprUNIQUE static_cast < unsigned char > (@exprUNIQUE escape@var1012 ) ;
2765: break ;
2766:
2767: case 'a'@exprUNIQUE : ;
2768: value@var1011 =@exprUNIQUE static_cast < unsigned char > (@exprUNIQUE '\a'@exprUNIQUE ) ;
2769: break ;
2770: case 'b'@exprUNIQUE : ;
2771: value@var1011 =@exprUNIQUE static_cast < unsigned char > (@exprUNIQUE '\b'@exprUNIQUE ) ;
2772: break ;
2773: case 'f'@exprUNIQUE : ;
2774: value@var1011 =@exprUNIQUE static_cast < unsigned char > (@exprUNIQUE '\f'@exprUNIQUE ) ;
2775: break ;
2776: case 'n'@exprUNIQUE : ;
2777: value@var1011 =@exprUNIQUE static_cast < unsigned char > (@exprUNIQUE '\n'@expr6149 ) ;
2778: break ;
2779: case 'r'@exprUNIQUE : ;
2780: value@var1011 =@exprUNIQUE static_cast < unsigned char > (@exprUNIQUE '\r'@exprUNIQUE ) ;
2781: break ;
2782: case 't'@exprUNIQUE : ;
2783: value@var1011 =@exprUNIQUE static_cast < unsigned char > (@exprUNIQUE '\t'@exprUNIQUE ) ;
2784: break ;
2785: case 'v'@exprUNIQUE : ;
2786: value@var1011 =@exprUNIQUE static_cast < unsigned char > (@exprUNIQUE '\v'@exprUNIQUE ) ;
2787: break ;
2788:
2789:
2790: case 'e'@exprUNIQUE :
2791: case 'E'@exprUNIQUE : ;
2792: value@var1011 =@exprUNIQUE static_cast < unsigned char > (@exprUNIQUE '\x1b'@exprUNIQUE ) ;
2793: break ;
2794:
2795: case '0'@exprUNIQUE :
2796: case '1'@exprUNIQUE :
2797: case '2'@exprUNIQUE :
2798: case '3'@exprUNIQUE :
2799: case '4'@exprUNIQUE :
2800: case '5'@exprUNIQUE :
2801: case '6'@exprUNIQUE :
2802: case '7'@exprUNIQUE : ;
2803:
2804: value@var1011 =@exprUNIQUE stringToULLbounded (@exprUNIQUE str@var1004 ,@exprUNIQUE --@exprUNIQUE pos@var1008 ,@exprUNIQUE 8 ,@exprUNIQUE 1 ,@exprUNIQUE 3 ) ;
2805: break ;
2806:
2807: case 'x'@exprUNIQUE : ;
2808:
2809: value@var1011 =@exprUNIQUE stringToULLbounded (@exprUNIQUE str@var1004 ,@expr6238 pos@var1008 ,@expr6240 16 ) ;
2810: break ;
2811:
2812: case 'u'@expr6116 :
2813: case 'U'@expr6134 : ; {
2814:
2815: const unsigned long ndigits@var1013 =@exprUNIQUE escape@var1012 ==@exprUNIQUE 'u'@expr6116 ?@exprUNIQUE 4 :@exprUNIQUE 8 ;
2816: value@var1011 =@exprUNIQUE stringToULLbounded (@exprUNIQUE str@var1004 ,@expr6238 pos@var1008 ,@expr6240 16 ,@exprUNIQUE ndigits@var1013 ,@exprUNIQUE ndigits@var1013 ) ;
2817:
2818:
2819:
2820: if ( ( ( narrow@var1005 ||@expr6252 utf8@var1006 ) &&@exprUNIQUE value@var1011 >@expr6254 0x7f ) ||@exprUNIQUE ( utf16@var1007 &&@expr6258 value@var1011 >@expr6257 0xffff ) ||@exprUNIQUE value@var1011 >@expr6261 0x10ffff ) {
2821: throw@expr6265 std ::@expr6141 runtime_error (@expr6264 "code point too large"@expr6263 ) ; }
2822:
2823: if ( value@var1011 >=@expr6267 0xd800 &&@expr6270 value@var1011 <=@expr6269 0xdfff ) {
2824: throw@exprUNIQUE std ::@expr6141 runtime_error (@exprUNIQUE "surrogate code points not allowed in universal character names"@exprUNIQUE ) ; }
2825:
2826: break ;
2827: }
2828:
2829: default : ;
2830: throw@exprUNIQUE std ::@expr6141 runtime_error (@exprUNIQUE "invalid escape sequence"@exprUNIQUE ) ;
2831: }
2832: } else {
2833: value@var1011 =@exprUNIQUE static_cast < unsigned char > (@exprUNIQUE str@var1004 [@exprUNIQUE pos@var1008 ++@exprUNIQUE ] ) ;
2834:
2835: if ( !@expr6156 narrow@var1005 &&@exprUNIQUE value@var1011 >=@exprUNIQUE 0x80 ) {
2836:
|
2839:
2840: int additional_bytes@var1014 ;
2841: if ( value@var1011 >=@exprUNIQUE 0xf5 ) {
2842: throw@expr6289 std ::@expr6141 runtime_error (@expr6288 "assumed UTF-8 encoded source, but sequence is invalid"@expr6287 ) ; }
2843: if ( value@var1011 >=@exprUNIQUE 0xf0 ) {
2844: additional_bytes@var1014 = 3 ; }
2845: else { if ( value@var1011 >=@exprUNIQUE 0xe0 ) {
2846: additional_bytes@var1014 = 2 ; }
2847: else { if ( value@var1011 >=@exprUNIQUE 0xc2 ) {
2848: additional_bytes@var1014 = 1 ; }
2849: else {
2850: throw@expr6289 std ::@expr6141 runtime_error (@expr6288 "assumed UTF-8 encoded source, but sequence is invalid"@expr6287 ) ; } } }
2851:
2852: value@var1011 &=@exprUNIQUE ( 1 <<@exprUNIQUE ( 6 -@exprUNIQUE additional_bytes@var1014 ) ) -@exprUNIQUE 1 ;
2853:
2854: while ( additional_bytes@var1014 --@exprUNIQUE ) {
2855: if ( pos@var1008 +@expr6145 1 >=@exprUNIQUE str@var1004 .@expr6112 size (@expr6113 ) ) {
2856: throw@exprUNIQUE std ::@expr6141 runtime_error (@exprUNIQUE "assumed UTF-8 encoded source, but character literal ends unexpectedly"@exprUNIQUE ) ; }
2857:
2858: const unsigned char c@var1015 =@exprUNIQUE str@var1004 [@exprUNIQUE pos@var1008 ++@exprUNIQUE ] ;
2859:
2860: if ( ( ( c@var1015 >>@exprUNIQUE 6 ) !=@exprUNIQUE 2 )
2861: ||@exprUNIQUE ( !@expr6311 value@var1011 &&@exprUNIQUE additional_bytes@var1014 ==@exprUNIQUE 1 &&@exprUNIQUE c@var1015 <@exprUNIQUE 0xa0 )
2862: ||@exprUNIQUE ( !@expr6311 value@var1011 &&@exprUNIQUE additional_bytes@var1014 ==@exprUNIQUE 2 &&@exprUNIQUE c@var1015 <@exprUNIQUE 0x90 ) ) {
2863: throw@expr6289 std ::@expr6141 runtime_error (@expr6288 "assumed UTF-8 encoded source, but sequence is invalid"@expr6287 ) ; }
2864:
2865: value@var1011 =@exprUNIQUE ( value@var1011 <<@exprUNIQUE 6 ) |@exprUNIQUE ( c@var1015 &@exprUNIQUE ( ( 1 <<@exprUNIQUE 7 ) -@exprUNIQUE 1 ) ) ;
2866: }
2867:
2868: if ( value@var1011 >=@expr6267 0xd800 &&@expr6270 value@var1011 <=@expr6269 0xdfff ) {
2869: throw@expr6289 std ::@expr6141 runtime_error (@expr6288 "assumed UTF-8 encoded source, but sequence is invalid"@expr6287 ) ; }
2870:
2871: if ( ( utf8@var1006 &&@exprUNIQUE value@var1011 >@expr6254 0x7f ) ||@exprUNIQUE ( utf16@var1007 &&@expr6258 value@var1011 >@expr6257 0xffff ) ||@exprUNIQUE value@var1011 >@expr6261 0x10ffff ) {
2872: throw@expr6265 std ::@expr6141 runtime_error (@expr6264 "code point too large"@expr6263 ) ; }
2873: }
2874: }
2875:
2876: if ( ( ( narrow@var1005 ||@expr6252 utf8@var1006 ) &&@exprUNIQUE value@var1011 >@exprUNIQUE std ::@exprUNIQUE numeric_limits < unsigned char > ::@exprUNIQUE max (@exprUNIQUE ) ) ||@exprUNIQUE ( utf16@var1007 &&@exprUNIQUE value@var1011 >>@exprUNIQUE 16 ) ||@exprUNIQUE value@var1011 >>@exprUNIQUE 32 ) {
2877: throw@exprUNIQUE std ::@expr6141 runtime_error (@exprUNIQUE "numeric escape sequence too large"@exprUNIQUE ) ; }
2878:
2879: multivalue@var1009 <<=@exprUNIQUE $8 ;
2880: multivalue@var1009 |=@exprUNIQUE value@var1011 ;
2881: nbytes@var1010 ++@exprUNIQUE ;
2882: }
2883:
2884: if ( pos@var1008 +@expr6145 1 !=@exprUNIQUE str@var1004 .@expr6112 size (@expr6113 ) ||@exprUNIQUE str@var1004 [@expr6147 pos@var1008 ] !=@exprUNIQUE '\''@expr6108 ) {
2885: throw@exprUNIQUE std ::@expr6141 runtime_error (@exprUNIQUE "missing closing quote in character literal"@exprUNIQUE ) ; }
2886:
2887: if ( !@exprUNIQUE nbytes@var1010 ) {
2888: throw@exprUNIQUE std ::@expr6141 runtime_error (@exprUNIQUE "empty character literal"@exprUNIQUE ) ; }
2889:
2890:
2891: if ( narrow@var1005 &&@exprUNIQUE nbytes@var1010 ==@exprUNIQUE 1 ) {
2892: return static_cast < char > (@exprUNIQUE multivalue@var1009 ) ; }
2893:
2894:
2895: if ( narrow@var1005 ) {
2896: return static_cast < int > (@exprUNIQUE multivalue@var1009 ) ; }
2897:
2898:
2899:
2900: return multivalue@var1009 ;
2901: }
2902:
2903: static void simplifyNumbers ( simplecpp :: TokenList & expr@var1016 )
2904: {
2905: for ( simplecpp :: Token * tok@var1017 =@exprUNIQUE expr@var1016 .@exprUNIQUE front (@exprUNIQUE ) ;@exprUNIQUE tok@var1017 ;@exprUNIQUE tok@var1017 =@exprUNIQUE tok@var1017 .@exprUNIQUE next@var1018 ) {
2906: if ( tok@var1017 .@expr6380 str (@expr6381 ) .@exprUNIQUE size (@exprUNIQUE ) ==@exprUNIQUE 1U ) {
2907: continue ; }
2908: if ( tok@var1017 .@expr6380 str (@expr6381 ) .@exprUNIQUE compare (@exprUNIQUE 0 ,@exprUNIQUE 2 ,@exprUNIQUE "0x"@exprUNIQUE ) ==@exprUNIQUE 0 ) {
2909: tok@var1017 .@expr6397 setstr (@exprUNIQUE toString (@exprUNIQUE stringToULL (@exprUNIQUE tok@var1017 .@expr6380 str (@expr6381 ) ) ) ) ; }
2910: else { if ( !@exprUNIQUE tok@var1017 .@exprUNIQUE number@var1019 &&@exprUNIQUE tok@var1017 .@expr6380 str (@expr6381 ) .@exprUNIQUE find (@exprUNIQUE '\''@exprUNIQUE ) !=@exprUNIQUE std ::@exprUNIQUE string ::@exprUNIQUE npos ) {
2911: tok@var1017 .@expr6397 setstr (@exprUNIQUE toString (@exprUNIQUE simplecpp ::@exprUNIQUE characterLiteralToLL (@exprUNIQUE tok@var1017 .@expr6380 str (@expr6381 ) ) ) ) ; } }
2912: }
2913: }
2914:
2915: static void simplifyComments ( simplecpp :: TokenList & expr@var1020 )
2916: {
2917: for ( simplecpp :: Token * tok@var1021 =@exprUNIQUE expr@var1020 .@exprUNIQUE front (@exprUNIQUE ) ;@exprUNIQUE tok@var1021 ;@exprUNIQUE ) {
2918: simplecpp ::@exprUNIQUE Token *@exprUNIQUE const d@var1022 ; d@var1022 =@exprUNIQUE tok@var1021 ;
2919: tok@var1021 =@exprUNIQUE tok@var1021 .@exprUNIQUE next@var1023 ;
2920: if ( d@var1022 .@exprUNIQUE comment@var1024 ) {
2921: expr@var1020 .@exprUNIQUE deleteToken (@exprUNIQUE d@var1022 ) ; }
2922: }
2923: }
2924:
2925: static long long evaluate ( simplecpp :: TokenList & expr@var1025 , const simplecpp :: DUI & dui@var1026 , const std :: map < std :: string , unsigned long > & sizeOfType@var1027 )
2926: {
2927: simplifyComments (@exprUNIQUE expr@var1025 ) ;
2928: simplifySizeof (@exprUNIQUE expr@var1025 ,@exprUNIQUE sizeOfType@var1027 ) ;
2929: simplifyHasInclude (@exprUNIQUE expr@var1025 ,@exprUNIQUE dui@var1026 ) ;
2930: simplifyName (@exprUNIQUE expr@var1025 ) ;
2931: simplifyNumbers (@exprUNIQUE expr@var1025 ) ;
2932: expr@var1025 .@exprUNIQUE constFold (@exprUNIQUE ) ;
2933:
2934: return expr@var1025 .@expr6458 cfront (@expr6459 ) &&@exprUNIQUE expr@var1025 .@expr6458 cfront (@expr6459 ) ==@exprUNIQUE expr@var1025 .@exprUNIQUE cback (@exprUNIQUE ) &&@exprUNIQUE expr@var1025 .@expr6458 cfront (@expr6459 ) .@exprUNIQUE number@var1339 ?@exprUNIQUE stringToLL (@exprUNIQUE expr@var1025 .@expr6458 cfront (@expr6459 ) .@exprUNIQUE str (@exprUNIQUE ) ) :@exprUNIQUE 0LL ;
2935: }
2936:
2937: static const simplecpp :: Token * gotoNextLine ( const simplecpp :: Token * tok@var1028 )
2938: {
2939: const unsigned int line@var1029 =@exprUNIQUE tok@var1028 .@expr6475 location@var1030 .@expr6476 line@var1031 ;
2940: const unsigned int file@var1032 =@exprUNIQUE tok@var1028 .@expr6475 location@var1030 .@expr6478 fileIndex@var1033 ;
2941: while ( tok@var1028 &&@exprUNIQUE tok@var1028 .@expr6475 location@var1030 .@expr6476 line@var1031 ==@exprUNIQUE line@var1029 &&@exprUNIQUE tok@var1028 .@expr6475 location@var1030 .@expr6478 fileIndex@var1033 ==@exprUNIQUE file@var1032 ) {
2942: tok@var1028 =@exprUNIQUE tok@var1028 .@exprUNIQUE next@var1034 ; }
2943: return tok@var1028 ;
2944: }
2945:
|
2975:
2976: static std :: string openHeaderDirect ( std :: ifstream & f@var1035 , const std :: string & path@var1036 )
2977: {
2978:
|
2981:
2982: f@var1035 .@exprUNIQUE open (@exprUNIQUE path@var1036 .@exprUNIQUE c_str (@exprUNIQUE ) ) ;
2983: if ( f@var1035 .@exprUNIQUE is_open (@exprUNIQUE ) ) {
2984: return path@var1036 ; }
2985:
2986:
2987:
2988: return ""@exprUNIQUE ;
2989: }
2990:
2991: static std :: string openHeader ( std :: ifstream & f@var1037 , const simplecpp :: DUI & dui@var1038 , const std :: string & sourcefile@var1039 , const std :: string & header@var1040 , bool systemheader@var1041 )
2992: {
2993: if ( isAbsolutePath (@exprUNIQUE header@var1040 ) ) {
2994: return openHeaderDirect (@exprUNIQUE f@var1037 ,@exprUNIQUE simplecpp ::@expr6501 simplifyPath (@exprUNIQUE header@var1040 ) ) ; }
2995:
2996:
2997: if ( !@exprUNIQUE systemheader@var1041 ) {
2998: std ::@exprUNIQUE string path@var1042 ; path@var1042 =@exprUNIQUE openHeaderDirect (@exprUNIQUE f@var1037 ,@exprUNIQUE simplecpp ::@expr6501 simplifyPath (@exprUNIQUE dirPath (@exprUNIQUE sourcefile@var1039 ) +@exprUNIQUE header@var1040 ) ) ;
2999: if ( !@exprUNIQUE path@var1042 .@exprUNIQUE empty (@exprUNIQUE ) ) {
3000: return path@var1042 ;
3001: }
3002: }
3003:
3004:
3005: for ( const auto & includePath@var1043 :@exprUNIQUE dui@var1038 .@exprUNIQUE includePaths@var1044 ) {
3006: std ::@exprUNIQUE string path@var1045 ; path@var1045 =@exprUNIQUE openHeaderDirect (@exprUNIQUE f@var1037 ,@exprUNIQUE simplecpp ::@expr6501 simplifyPath (@exprUNIQUE includePath@var1043 +@exprUNIQUE "/"@exprUNIQUE +@exprUNIQUE header@var1040 ) ) ;
3007: if ( !@exprUNIQUE path@var1045 .@exprUNIQUE empty (@exprUNIQUE ) ) {
3008: return path@var1045 ; }
3009: }
3010: return ""@exprUNIQUE ;
3011: }
3012:
3013: std :: pair < simplecpp :: FileData * , bool > simplecpp :: FileDataCache :: tryload ( std :: unordered_map < std :: string , FileData * > :: iterator & name_it@var1046 , const simplecpp :: DUI & dui@var1047 , std :: vector < std :: string > & filenames@var1048 , std :: list < Output > * outputList@var1049 )
3014: {
3015: const std :: string & path@var1050 =@exprUNIQUE name_it@var1046 .@exprUNIQUE first@var1051 ;
3016: FileID fileId@var1052 ;
3017:
3018: if ( !@exprUNIQUE getFileId (@exprUNIQUE path@var1050 ,@exprUNIQUE fileId@var1052 ) ) {
3019: return {@exprUNIQUE nullptr ,@exprUNIQUE false@expr6540 } ; }
3020:
3021: const auto id_it@var1053 =@exprUNIQUE mIdMap@var203 .@exprUNIQUE find (@exprUNIQUE fileId@var1052 ) ;
3022: if ( id_it@var1053 !=@exprUNIQUE mIdMap@var203 .@exprUNIQUE end (@exprUNIQUE ) ) {
3023: name_it@var1046 .@expr6551 second@var1054 =@exprUNIQUE id_it@var1053 .@expr6552 second@var1055 ;
3024: return {@exprUNIQUE id_it@var1053 .@expr6552 second@var1055 ,@exprUNIQUE false@expr6540 } ;
3025: }
3026:
3027: std ::@exprUNIQUE ifstream f@var1056 (@exprUNIQUE path@var1050 ) ;
3028: FileData * const data@var1057 ; data@var1057 =@exprUNIQUE new@exprUNIQUE FileData@exprUNIQUE {@exprUNIQUE path@var1050 ,@exprUNIQUE TokenList (@exprUNIQUE f@var1056 ,@exprUNIQUE filenames@var1048 ,@exprUNIQUE path@var1050 ,@exprUNIQUE outputList@var1049 ) } ;
3029:
3030: if ( dui@var1047 .@exprUNIQUE removeComments@var1058 ) {
3031: data@var1057 .@exprUNIQUE tokens@var1059 .@exprUNIQUE removeComments (@exprUNIQUE ) ; }
3032:
3033: name_it@var1046 .@expr6551 second@var1054 =@exprUNIQUE data@var1057 ;
3034: mIdMap@var203 .@exprUNIQUE emplace (@exprUNIQUE fileId@var1052 ,@exprUNIQUE data@var1057 ) ;
3035: mData@var201 .@exprUNIQUE emplace_back (@exprUNIQUE data@var1057 ) ;
3036:
3037: return {@exprUNIQUE data@var1057 ,@exprUNIQUE true@exprUNIQUE } ;
3038: }
3039:
3040: std :: pair < simplecpp :: FileData * , bool > simplecpp :: FileDataCache :: get ( const std :: string & sourcefile@var1060 , const std :: string & header@var1061 , const simplecpp :: DUI & dui@var1062 , bool systemheader@var1063 , std :: vector < std :: string > & filenames@var1064 , std :: list < Output > * outputList@var1065 )
3041: {
3042: if ( isAbsolutePath (@exprUNIQUE header@var1061 ) ) {
3043: auto ins@var1066 ; ins@var1066 =@exprUNIQUE mNameMap@var202 .@expr6588 emplace (@exprUNIQUE simplecpp ::@expr6591 simplifyPath (@exprUNIQUE header@var1061 ) ,@exprUNIQUE nullptr ) ;
3044:
3045: if ( ins@var1066 .@exprUNIQUE second@var1067 ) {
3046: const auto ret@var1068 =@exprUNIQUE tryload (@exprUNIQUE ins@var1066 .@expr6599 first@var1069 ,@exprUNIQUE dui@var1062 ,@exprUNIQUE filenames@var1064 ,@exprUNIQUE outputList@var1065 ) ;
3047: if ( ret@var1068 .@exprUNIQUE first@var1070 !=@exprUNIQUE nullptr ) {
3048: return ret@var1068 ;
3049: }
3050: } else {
3051: return {@exprUNIQUE ins@var1066 .@expr6599 first@var1069 .@exprUNIQUE second@var1071 ,@exprUNIQUE false@expr6608 } ;
3052: }
3053:
3054: return {@expr6612 nullptr ,@expr6611 false@expr6608 } ;
3055: }
3056:
3057: if ( !@exprUNIQUE systemheader@var1063 ) {
3058: auto ins@var1072 ; ins@var1072 =@exprUNIQUE mNameMap@var202 .@expr6588 emplace (@exprUNIQUE simplecpp ::@expr6591 simplifyPath (@exprUNIQUE dirPath (@exprUNIQUE sourcefile@var1060 ) +@exprUNIQUE header@var1061 ) ,@exprUNIQUE nullptr ) ;
3059:
3060: if ( ins@var1072 .@exprUNIQUE second@var1073 ) {
3061: const auto ret@var1074 =@exprUNIQUE tryload (@exprUNIQUE ins@var1072 .@expr6622 first@var1075 ,@exprUNIQUE dui@var1062 ,@exprUNIQUE filenames@var1064 ,@exprUNIQUE outputList@var1065 ) ;
3062: if ( ret@var1074 .@exprUNIQUE first@var1076 !=@exprUNIQUE nullptr ) {
3063: return ret@var1074 ;
3064: }
3065: } else { if ( ins@var1072 .@expr6622 first@var1075 .@expr6630 second@var1077 !=@exprUNIQUE nullptr ) {
3066: return {@exprUNIQUE ins@var1072 .@expr6622 first@var1075 .@expr6630 second@var1077 ,@exprUNIQUE false@expr6608 } ;
3067: } }
3068: }
3069:
3070: for ( const auto & includePath@var1078 :@exprUNIQUE dui@var1062 .@exprUNIQUE includePaths@var1079 ) {
3071: auto ins@var1080 ; ins@var1080 =@exprUNIQUE mNameMap@var202 .@expr6588 emplace (@exprUNIQUE simplecpp ::@expr6591 simplifyPath (@exprUNIQUE includePath@var1078 +@exprUNIQUE "/"@exprUNIQUE +@exprUNIQUE header@var1061 ) ,@exprUNIQUE nullptr ) ;
3072:
3073: if ( ins@var1080 .@exprUNIQUE second@var1081 ) {
3074: const auto ret@var1082 =@exprUNIQUE tryload (@exprUNIQUE ins@var1080 .@expr6644 first@var1083 ,@exprUNIQUE dui@var1062 ,@exprUNIQUE filenames@var1064 ,@exprUNIQUE outputList@var1065 ) ;
3075: if ( ret@var1082 .@exprUNIQUE first@var1084 !=@exprUNIQUE nullptr ) {
3076: return ret@var1082 ;
3077: }
3078: } else { if ( ins@var1080 .@expr6644 first@var1083 .@expr6652 second@var1085 !=@exprUNIQUE nullptr ) {
3079: return {@exprUNIQUE ins@var1080 .@expr6644 first@var1083 .@expr6652 second@var1085 ,@exprUNIQUE false@expr6608 } ;
3080: } }
3081: }
3082:
3083: return {@expr6612 nullptr ,@expr6611 false@expr6608 } ;
3084: }
3085:
3086: bool simplecpp :: FileDataCache :: getFileId ( const std :: string & path@var1086 , FileID & id@var1087 )
3087: {
3088:
|
3099:
3100: struct stat statbuf@var1088 ;
3101:
3102: if ( stat (@exprUNIQUE path@var1086 .@exprUNIQUE c_str (@exprUNIQUE ) ,@exprUNIQUE &@exprUNIQUE statbuf@var1088 ) !=@exprUNIQUE 0 ) {
3103: return false@exprUNIQUE ; }
3104:
3105: id@var1087 .@exprUNIQUE dev@var1089 =@exprUNIQUE statbuf@var1088 .@exprUNIQUE st_dev@var1090 ;
3106: id@var1087 .@exprUNIQUE ino@var1091 =@exprUNIQUE statbuf@var1088 .@exprUNIQUE st_ino@var1092 ;
3107:
3108: return true@exprUNIQUE ;
3109:
3110: }
3111:
3112: simplecpp :: FileDataCache simplecpp :: load ( const simplecpp :: TokenList & rawtokens@var1093 , std :: vector < std :: string > & filenames@var1094 , const simplecpp :: DUI & dui@var1095 , std :: list < Output > * outputList@var1096 )
3113: {
3114:
|
3118:
3119: FileDataCache cache@var1097 ;
3120:
3121: std ::@exprUNIQUE list < const Token * > filelist@var1098 ;
3122:
3123:
3124: for ( std :: list < std :: string > :: const_iterator it@var1099 =@exprUNIQUE dui@var1095 .@expr6675 includes@var1100 .@exprUNIQUE begin (@exprUNIQUE ) ;@exprUNIQUE it@var1099 !=@exprUNIQUE dui@var1095 .@expr6675 includes@var1100 .@exprUNIQUE end (@exprUNIQUE ) ;@exprUNIQUE ++@exprUNIQUE it@var1099 ) {
3125: const std :: string & filename@var1101 =@exprUNIQUE *@exprUNIQUE it@var1099 ;
3126:
3127: const auto loadResult@var1102 =@exprUNIQUE cache@var1097 .@expr6690 get (@exprUNIQUE ""@exprUNIQUE ,@exprUNIQUE filename@var1101 ,@exprUNIQUE dui@var1095 ,@exprUNIQUE false@exprUNIQUE ,@exprUNIQUE filenames@var1094 ,@exprUNIQUE outputList@var1096 ) ;
3128: const bool loaded@var1103 =@exprUNIQUE loadResult@var1102 .@exprUNIQUE second@var1104 ;
3129: FileData * const filedata@var1105 ; filedata@var1105 =@exprUNIQUE loadResult@var1102 .@exprUNIQUE first@var1106 ;
3130:
3131: if ( filedata@var1105 ==@exprUNIQUE nullptr ) {
3132: if ( outputList@var1096 ) {
3133: simplecpp ::@exprUNIQUE Output err@var1107 (@exprUNIQUE filenames@var1094 ) ;
3134: err@var1107 .@exprUNIQUE type@var1108 =@exprUNIQUE simplecpp ::@exprUNIQUE Output ::@exprUNIQUE EXPLICIT_INCLUDE_NOT_FOUND ;
3135: err@var1107 .@exprUNIQUE location@var1109 =@exprUNIQUE Location (@exprUNIQUE filenames@var1094 ) ;
3136: err@var1107 .@exprUNIQUE msg@var1110 =@exprUNIQUE "Can not open include file '"@exprUNIQUE +@exprUNIQUE filename@var1101 +@exprUNIQUE "' that is explicitly included."@exprUNIQUE ;
3137: outputList@var1096 .@exprUNIQUE push_back (@exprUNIQUE err@var1107 ) ;
3138: }
3139: continue ;
3140: }
3141:
3142: if ( !@exprUNIQUE loaded@var1103 ) {
3143: continue ; }
3144:
3145: if ( !@exprUNIQUE filedata@var1105 .@expr6729 tokens@var1111 .@expr6731 front (@expr6732 ) ) {
3146: continue ; }
3147:
3148: if ( dui@var1095 .@expr6734 removeComments@var1112 ) {
3149: filedata@var1105 .@expr6729 tokens@var1111 .@exprUNIQUE removeComments (@exprUNIQUE ) ; }
3150:
3151: filelist@var1098 .@expr6738 push_back (@exprUNIQUE filedata@var1105 .@expr6729 tokens@var1111 .@expr6731 front (@expr6732 ) ) ;
3152: }
3153:
3154: for ( const Token * rawtok@var1113 =@exprUNIQUE rawtokens@var1093 .@exprUNIQUE cfront (@exprUNIQUE ) ;@exprUNIQUE rawtok@var1113 ||@exprUNIQUE !@exprUNIQUE filelist@var1098 .@exprUNIQUE empty (@exprUNIQUE ) ;@exprUNIQUE rawtok@var1113 =@exprUNIQUE rawtok@var1113 ?@exprUNIQUE rawtok@var1113 .@exprUNIQUE next@var1114 :@exprUNIQUE nullptr ) {
3155: if ( rawtok@var1113 ==@exprUNIQUE nullptr ) {
3156: rawtok@var1113 =@exprUNIQUE filelist@var1098 .@exprUNIQUE back (@exprUNIQUE ) ;
3157: filelist@var1098 .@exprUNIQUE pop_back (@exprUNIQUE ) ;
3158: }
3159:
3160: if ( rawtok@var1113 .@exprUNIQUE op@var1115 !=@exprUNIQUE '#'@exprUNIQUE ||@exprUNIQUE sameline (@exprUNIQUE rawtok@var1113 .@exprUNIQUE previousSkipComments (@exprUNIQUE ) ,@exprUNIQUE rawtok@var1113 ) ) {
3161: continue ; }
3162:
3163: rawtok@var1113 =@exprUNIQUE rawtok@var1113 .@expr6774 nextSkipComments (@expr6775 ) ;
3164: if ( !@exprUNIQUE rawtok@var1113 ||@exprUNIQUE rawtok@var1113 .@exprUNIQUE str (@exprUNIQUE ) !=@exprUNIQUE INCLUDE@var210 ) {
3165: continue ; }
3166:
3167: const std :: string & sourcefile@var1116 =@exprUNIQUE rawtok@var1113 .@exprUNIQUE location@var1117 .@exprUNIQUE file (@exprUNIQUE ) ;
3168:
3169: const Token * const htok@var1118 ; htok@var1118 =@exprUNIQUE rawtok@var1113 .@expr6774 nextSkipComments (@expr6775 ) ;
3170: if ( !@exprUNIQUE sameline (@exprUNIQUE rawtok@var1113 ,@exprUNIQUE htok@var1118 ) ) {
3171: continue ; }
3172:
3173: const bool systemheader@var1119 =@exprUNIQUE htok@var1118 .@expr6792 str (@expr6793 ) [@exprUNIQUE 0 ] ==@exprUNIQUE '<'@exprUNIQUE ;
3174: const std ::@exprUNIQUE string header@var1120 (@exprUNIQUE htok@var1118 .@expr6792 str (@expr6793 ) .@exprUNIQUE substr (@exprUNIQUE 1U ,@exprUNIQUE htok@var1118 .@expr6792 str (@expr6793 ) .@exprUNIQUE size (@exprUNIQUE ) -@exprUNIQUE 2U ) ) ;
3175:
3176: FileData * const filedata@var1121 ; filedata@var1121 =@exprUNIQUE cache@var1097 .@expr6690 get (@exprUNIQUE sourcefile@var1116 ,@exprUNIQUE header@var1120 ,@exprUNIQUE dui@var1095 ,@exprUNIQUE systemheader@var1119 ,@exprUNIQUE filenames@var1094 ,@exprUNIQUE outputList@var1096 ) .@exprUNIQUE first@var1122 ;
3177: if ( !@exprUNIQUE filedata@var1121 ) {
3178: continue ; }
3179:
3180: if ( dui@var1095 .@expr6734 removeComments@var1112 ) {
3181: filedata@var1121 .@expr6820 tokens@var1123 .@exprUNIQUE removeComments (@exprUNIQUE ) ; }
3182:
3183: if ( filedata@var1121 .@expr6820 tokens@var1123 .@expr6823 front (@expr6824 ) ) {
3184: filelist@var1098 .@expr6738 push_back (@exprUNIQUE filedata@var1121 .@expr6820 tokens@var1123 .@expr6823 front (@expr6824 ) ) ; }
3185: }
3186:
3187: return cache@var1097 ;
3188: }
3189:
3190: static bool preprocessToken ( simplecpp :: TokenList & output@var1124 , const simplecpp :: Token * * tok1@var1125 , std :: unordered_map < std :: string , Macro > & macros@var1126 , std :: vector < std :: string > & files@var1127 , std :: list < Output > * outputList@var1128 )
3191: {
3192: const simplecpp ::@expr6828 Token *@exprUNIQUE const tok@var1129 ; tok@var1129 =@exprUNIQUE *@expr6830 tok1@var1125 ;
3193: const std :: unordered_map < std :: string , Macro > :: const_iterator it@var1130 =@exprUNIQUE macros@var1126 .@exprUNIQUE find (@exprUNIQUE tok@var1129 .@expr6835 str (@expr6836 ) ) ;
3194: if ( it@var1130 !=@exprUNIQUE macros@var1126 .@exprUNIQUE end (@exprUNIQUE ) ) {
3195: simplecpp ::@exprUNIQUE TokenList value@var1131 (@exprUNIQUE files@var1127 ) ;
3196: try {
3197: *@expr6830 tok1@var1125 =@exprUNIQUE it@var1130 .@exprUNIQUE second@var1132 .@exprUNIQUE expand (@exprUNIQUE &@exprUNIQUE value@var1131 ,@exprUNIQUE tok@var1129 ,@exprUNIQUE macros@var1126 ,@exprUNIQUE files@var1127 ) ;
3198: } catch (@exprUNIQUE simplecpp ::@exprUNIQUE Macro ::@exprUNIQUE Error &@exprUNIQUE err@var1133 ) {
3199: if ( outputList@var1128 ) {
3200: simplecpp ::@exprUNIQUE Output out@var1134 (@exprUNIQUE files@var1127 ) ;
3201: out@var1134 .@exprUNIQUE type@var1135 =@exprUNIQUE simplecpp ::@exprUNIQUE Output ::@exprUNIQUE SYNTAX_ERROR ;
3202: out@var1134 .@exprUNIQUE location@var1136 =@exprUNIQUE err@var1133 .@exprUNIQUE location@var1137 ;
3203: out@var1134 .@exprUNIQUE msg@var1138 =@exprUNIQUE "failed to expand \'"@exprUNIQUE +@exprUNIQUE tok@var1129 .@expr6835 str (@expr6836 ) +@exprUNIQUE "\', "@exprUNIQUE +@exprUNIQUE err@var1133 .@exprUNIQUE what@var1139 ;
3204: outputList@var1128 .@exprUNIQUE push_back (@exprUNIQUE out@var1134 ) ;
3205: }
3206: return false@exprUNIQUE ;
3207: }
3208: output@var1124 .@exprUNIQUE takeTokens (@exprUNIQUE value@var1131 ) ;
3209: } else {
3210: if ( !@exprUNIQUE tok@var1129 .@exprUNIQUE comment@var1140 ) {
3211: output@var1124 .@exprUNIQUE push_back (@exprUNIQUE new@exprUNIQUE simplecpp ::@expr6828 Token (@exprUNIQUE *@exprUNIQUE tok@var1129 ) ) ; }
3212: *@expr6830 tok1@var1125 =@exprUNIQUE tok@var1129 .@exprUNIQUE next@var1141 ;
3213: }
3214: return true@exprUNIQUE ;
3215: }
3216:
3217: static void getLocaltime ( struct tm & ltime@var1142 )
3218: {
3219: time_t t@var1143 ;
3220: time (@exprUNIQUE &@expr6898 t@var1143 ) ;
3221:
3222:
3223: localtime_r (@exprUNIQUE &@expr6898 t@var1143 ,@exprUNIQUE &@exprUNIQUE ltime@var1142 ) ;
3224:
3225:
3226:
3227: }
3228:
3229: static std :: string getDateDefine ( const struct tm * timep@var1144 )
3230: {
3231: char buf@var1145 [@exprUNIQUE 12 ] = "??? ?? ????" ;
3232: strftime (@exprUNIQUE buf@var1145 ,@exprUNIQUE sizeof (@exprUNIQUE buf@var1145 ) ,@exprUNIQUE "%b %d %Y"@exprUNIQUE ,@exprUNIQUE timep@var1144 ) ;
3233: return std ::@exprUNIQUE string (@exprUNIQUE "\""@expr6917 ) .@exprUNIQUE append (@exprUNIQUE buf@var1145 ) .@exprUNIQUE append (@exprUNIQUE "\""@expr6917 ) ;
3234: }
3235:
3236: static std :: string getTimeDefine ( const struct tm * timep@var1146 )
3237: {
3238: char buf@var1147 [@exprUNIQUE 9 ] = "??:??:??" ;
3239: strftime (@exprUNIQUE buf@var1147 ,@exprUNIQUE sizeof (@exprUNIQUE buf@var1147 ) ,@exprUNIQUE "%T"@exprUNIQUE ,@exprUNIQUE timep@var1146 ) ;
3240: return std ::@exprUNIQUE string (@exprUNIQUE "\""@expr6937 ) .@exprUNIQUE append (@exprUNIQUE buf@var1147 ) .@exprUNIQUE append (@exprUNIQUE "\""@expr6937 ) ;
3241: }
3242:
3243: void simplecpp :: preprocess ( simplecpp :: TokenList & output@var1148 , const simplecpp :: TokenList & rawtokens@var1149 , std :: vector < std :: string > & files@var1150 , simplecpp :: FileDataCache & cache@var1151 , const simplecpp :: DUI & dui@var1152 , std :: list < Output > * outputList@var1153 , std :: list < simplecpp :: MacroUsage > * macroUsage@var1154 , std :: list < simplecpp :: IfCond > * ifCond@var1155 )
3244: {
3245:
|
3249:
3250: std ::@exprUNIQUE map < std :: string , unsigned long > sizeOfType@var1156 (@exprUNIQUE rawtokens@var1149 .@exprUNIQUE sizeOfType@var1157 ) ;
3251: sizeOfType@var1156 .@expr6950 insert (@exprUNIQUE std ::@expr6952 make_pair (@exprUNIQUE "char"@exprUNIQUE ,@exprUNIQUE sizeof (@expr6956 char@expr6955 ) ) ) ;
3252: sizeOfType@var1156 .@expr6950 insert (@exprUNIQUE std ::@expr6952 make_pair (@exprUNIQUE "short"@expr6960 ,@exprUNIQUE sizeof (@expr6962 short@expr6961 ) ) ) ;
3253: sizeOfType@var1156 .@expr6950 insert (@exprUNIQUE std ::@expr6952 make_pair (@exprUNIQUE "short int"@exprUNIQUE ,@exprUNIQUE sizeOfType@var1156 [@exprUNIQUE "short"@expr6960 ] ) ) ;
3254: sizeOfType@var1156 .@expr6950 insert (@exprUNIQUE std ::@expr6952 make_pair (@exprUNIQUE "int"@exprUNIQUE ,@exprUNIQUE sizeof (@expr6973 int@expr6972 ) ) ) ;
3255: sizeOfType@var1156 .@expr6950 insert (@exprUNIQUE std ::@expr6952 make_pair (@exprUNIQUE "long"@expr6977 ,@exprUNIQUE sizeof (@exprUNIQUE long@exprUNIQUE ) ) ) ;
3256: sizeOfType@var1156 .@expr6950 insert (@exprUNIQUE std ::@expr6952 make_pair (@exprUNIQUE "long int"@exprUNIQUE ,@exprUNIQUE sizeOfType@var1156 [@exprUNIQUE "long"@expr6977 ] ) ) ;
3257: sizeOfType@var1156 .@expr6950 insert (@exprUNIQUE std ::@expr6952 make_pair (@exprUNIQUE "long long"@exprUNIQUE ,@exprUNIQUE sizeof (@exprUNIQUE long long@exprUNIQUE ) ) ) ;
3258: sizeOfType@var1156 .@expr6950 insert (@exprUNIQUE std ::@expr6952 make_pair (@exprUNIQUE "float"@exprUNIQUE ,@exprUNIQUE sizeof (@expr6996 float@expr6995 ) ) ) ;
3259: sizeOfType@var1156 .@expr6950 insert (@exprUNIQUE std ::@expr6952 make_pair (@exprUNIQUE "double"@exprUNIQUE ,@exprUNIQUE sizeof (@exprUNIQUE double@exprUNIQUE ) ) ) ;
3260: sizeOfType@var1156 .@expr6950 insert (@exprUNIQUE std ::@expr6952 make_pair (@exprUNIQUE "long double"@exprUNIQUE ,@exprUNIQUE sizeof (@exprUNIQUE long double@exprUNIQUE ) ) ) ;
3261: sizeOfType@var1156 .@expr6950 insert (@exprUNIQUE std ::@expr6952 make_pair (@exprUNIQUE "char *"@exprUNIQUE ,@exprUNIQUE sizeof (@expr6956 char@expr6955 * ) ) ) ;
3262: sizeOfType@var1156 .@expr6950 insert (@exprUNIQUE std ::@expr6952 make_pair (@exprUNIQUE "short *"@expr7016 ,@exprUNIQUE sizeof (@expr6962 short@expr6961 * ) ) ) ;
3263: sizeOfType@var1156 .@expr6950 insert (@exprUNIQUE std ::@expr6952 make_pair (@exprUNIQUE "short int *"@exprUNIQUE ,@exprUNIQUE sizeOfType@var1156 [@exprUNIQUE "short *"@expr7016 ] ) ) ;
3264: sizeOfType@var1156 .@expr6950 insert (@exprUNIQUE std ::@expr6952 make_pair (@exprUNIQUE "int *"@exprUNIQUE ,@exprUNIQUE sizeof (@expr6973 int@expr6972 * ) ) ) ;
3265: sizeOfType@var1156 .@expr6950 insert (@exprUNIQUE std ::@expr6952 make_pair (@exprUNIQUE "long *"@expr7029 ,@exprUNIQUE sizeof (@exprUNIQUE long@exprUNIQUE * ) ) ) ;
3266: sizeOfType@var1156 .@expr6950 insert (@exprUNIQUE std ::@expr6952 make_pair (@exprUNIQUE "long int *"@exprUNIQUE ,@exprUNIQUE sizeOfType@var1156 [@exprUNIQUE "long *"@expr7029 ] ) ) ;
3267: sizeOfType@var1156 .@expr6950 insert (@exprUNIQUE std ::@expr6952 make_pair (@exprUNIQUE "long long *"@exprUNIQUE ,@exprUNIQUE sizeof (@exprUNIQUE long long@exprUNIQUE * ) ) ) ;
3268: sizeOfType@var1156 .@expr6950 insert (@exprUNIQUE std ::@expr6952 make_pair (@exprUNIQUE "float *"@exprUNIQUE ,@exprUNIQUE sizeof (@expr6996 float@expr6995 * ) ) ) ;
3269: sizeOfType@var1156 .@expr6950 insert (@exprUNIQUE std ::@expr6952 make_pair (@exprUNIQUE "double *"@exprUNIQUE ,@exprUNIQUE sizeof (@exprUNIQUE double@exprUNIQUE * ) ) ) ;
3270: sizeOfType@var1156 .@expr6950 insert (@exprUNIQUE std ::@expr6952 make_pair (@exprUNIQUE "long double *"@exprUNIQUE ,@exprUNIQUE sizeof (@exprUNIQUE long double@exprUNIQUE * ) ) ) ;
3271:
3272:
3273: std ::@exprUNIQUE vector < std :: string > dummy@var1158 ;
3274:
3275: const bool hasInclude@var1159 =@exprUNIQUE isCpp17OrLater (@exprUNIQUE dui@var1152 ) ||@exprUNIQUE isGnu (@expr7066 dui@var1152 ) ;
3276: std ::@exprUNIQUE unordered_map < std :: string , Macro > macros@var1160 ;
3277: bool strictAnsiDefined@var1161 ; strictAnsiDefined@var1161 = false ;
3278: for ( std :: list < std :: string > :: const_iterator it@var1162 =@exprUNIQUE dui@var1152 .@expr7070 defines@var1163 .@exprUNIQUE begin (@exprUNIQUE ) ;@exprUNIQUE it@var1162 !=@exprUNIQUE dui@var1152 .@expr7070 defines@var1163 .@exprUNIQUE end (@exprUNIQUE ) ;@exprUNIQUE ++@exprUNIQUE it@var1162 ) {
3279: const std :: string & macrostr@var1164 =@exprUNIQUE *@exprUNIQUE it@var1162 ;
3280: const std :: string :: size_type eq@var1165 =@exprUNIQUE macrostr@var1164 .@expr7085 find (@exprUNIQUE '='@exprUNIQUE ) ;
3281: const std :: string :: size_type par@var1166 =@exprUNIQUE macrostr@var1164 .@expr7085 find (@exprUNIQUE '('@expr7089 ) ;
3282: const std :: string macroname@var1167 =@exprUNIQUE macrostr@var1164 .@expr7093 substr (@exprUNIQUE 0 ,@exprUNIQUE std ::@exprUNIQUE min (@exprUNIQUE eq@var1165 ,@exprUNIQUE par@var1166 ) ) ;
3283: if ( macroname@var1167 ==@exprUNIQUE "__STRICT_ANSI__"@expr7102 ) {
3284: strictAnsiDefined@var1161 = true ; }
3285: if ( dui@var1152 .@expr7104 undefined@var1168 .@expr7105 find (@exprUNIQUE macroname@var1167 ) !=@exprUNIQUE dui@var1152 .@expr7104 undefined@var1168 .@expr7107 end (@expr7108 ) ) {
3286: continue ; }
3287: const std ::@exprUNIQUE string lhs@var1169 (@exprUNIQUE macrostr@var1164 .@expr7093 substr (@exprUNIQUE 0 ,@exprUNIQUE eq@var1165 ) ) ;
3288: const std ::@exprUNIQUE string rhs@var1170 (@exprUNIQUE eq@var1165 ==@exprUNIQUE std ::@expr7116 string ::@exprUNIQUE npos ?@exprUNIQUE std ::@expr7116 string (@exprUNIQUE "1"@expr7122 ) :@exprUNIQUE macrostr@var1164 .@expr7093 substr (@exprUNIQUE eq@var1165 +@exprUNIQUE 1 ) ) ;
3289: const Macro macro@var1171 (@exprUNIQUE lhs@var1169 ,@exprUNIQUE rhs@var1170 ,@exprUNIQUE dummy@var1158 ) ;
3290: macros@var1160 .@expr7133 insert (@exprUNIQUE std ::@exprUNIQUE pair < std :: string , Macro > (@exprUNIQUE macro@var1171 .@exprUNIQUE name (@exprUNIQUE ) ,@exprUNIQUE macro@var1171 ) ) ;
3291: }
3292:
3293: const bool strictAnsiUndefined@var1172 =@exprUNIQUE dui@var1152 .@expr7104 undefined@var1168 .@expr7105 find (@exprUNIQUE "__STRICT_ANSI__"@expr7102 ) !=@exprUNIQUE dui@var1152 .@expr7104 undefined@var1168 .@exprUNIQUE cend (@exprUNIQUE ) ;
3294: if ( !@exprUNIQUE isGnu (@expr7066 dui@var1152 ) &&@exprUNIQUE !@exprUNIQUE strictAnsiDefined@var1161 &&@exprUNIQUE !@exprUNIQUE strictAnsiUndefined@var1172 ) {
3295: macros@var1160 .@expr7133 insert (@exprUNIQUE std ::@exprUNIQUE pair < std :: string , Macro > (@exprUNIQUE "__STRICT_ANSI__"@expr7102 ,@exprUNIQUE Macro (@exprUNIQUE "__STRICT_ANSI__"@expr7102 ,@exprUNIQUE "1"@expr7122 ,@exprUNIQUE dummy@var1158 ) ) ) ; }
3296:
3297: macros@var1160 .@expr7133 insert (@exprUNIQUE std ::@expr6952 make_pair (@exprUNIQUE "__FILE__"@expr7162 ,@exprUNIQUE Macro (@exprUNIQUE "__FILE__"@expr7162 ,@exprUNIQUE "__FILE__"@expr7162 ,@exprUNIQUE dummy@var1158 ) ) ) ;
3298: macros@var1160 .@expr7133 insert (@exprUNIQUE std ::@expr6952 make_pair (@exprUNIQUE "__LINE__"@expr7169 ,@exprUNIQUE Macro (@exprUNIQUE "__LINE__"@expr7169 ,@exprUNIQUE "__LINE__"@expr7169 ,@exprUNIQUE dummy@var1158 ) ) ) ;
3299: macros@var1160 .@expr7133 insert (@exprUNIQUE std ::@expr6952 make_pair (@exprUNIQUE "__COUNTER__"@expr7176 ,@exprUNIQUE Macro (@exprUNIQUE "__COUNTER__"@expr7176 ,@exprUNIQUE "__COUNTER__"@expr7176 ,@exprUNIQUE dummy@var1158 ) ) ) ;
3300: struct tm ltime@var1173 ; ltime@var1173 =@exprUNIQUE { } ;
3301: getLocaltime (@exprUNIQUE ltime@var1173 ) ;
3302: macros@var1160 .@expr7133 insert (@exprUNIQUE std ::@expr6952 make_pair (@exprUNIQUE "__DATE__"@expr7186 ,@exprUNIQUE Macro (@exprUNIQUE "__DATE__"@expr7186 ,@exprUNIQUE getDateDefine (@exprUNIQUE &@expr7188 ltime@var1173 ) ,@exprUNIQUE dummy@var1158 ) ) ) ;
3303: macros@var1160 .@expr7133 insert (@exprUNIQUE std ::@expr6952 make_pair (@exprUNIQUE "__TIME__"@expr7196 ,@exprUNIQUE Macro (@exprUNIQUE "__TIME__"@expr7196 ,@exprUNIQUE getTimeDefine (@exprUNIQUE &@expr7188 ltime@var1173 ) ,@exprUNIQUE dummy@var1158 ) ) ) ;
3304:
3305: if ( !@exprUNIQUE dui@var1152 .@expr7205 std@var1174 .@exprUNIQUE empty (@exprUNIQUE ) ) {
3306: const cstd_t c_std@var1175 =@exprUNIQUE simplecpp ::@exprUNIQUE getCStd (@exprUNIQUE dui@var1152 .@expr7205 std@var1174 ) ;
3307: if ( c_std@var1175 !=@exprUNIQUE CUnknown@exprUNIQUE ) {
3308: const std :: string std_def@var1176 =@exprUNIQUE simplecpp ::@exprUNIQUE getCStdString (@exprUNIQUE c_std@var1175 ) ;
3309: if ( !@exprUNIQUE std_def@var1176 .@exprUNIQUE empty (@exprUNIQUE ) ) {
3310: macros@var1160 .@expr7133 insert (@exprUNIQUE std ::@expr6952 make_pair (@exprUNIQUE "__STDC_VERSION__"@expr7224 ,@exprUNIQUE Macro (@exprUNIQUE "__STDC_VERSION__"@expr7224 ,@exprUNIQUE std_def@var1176 ,@exprUNIQUE dummy@var1158 ) ) ) ; }
3311: } else {
3312: const cppstd_t cpp_std@var1177 =@exprUNIQUE simplecpp ::@exprUNIQUE getCppStd (@exprUNIQUE dui@var1152 .@expr7205 std@var1174 ) ;
3313: if ( cpp_std@var1177 ==@exprUNIQUE CPPUnknown@exprUNIQUE ) {
3314: if ( outputList@var1153 ) {
3315: simplecpp ::@exprUNIQUE Output err@var1178 (@exprUNIQUE files@var1150 ) ;
3316: err@var1178 .@exprUNIQUE type@var1179 =@exprUNIQUE Output ::@exprUNIQUE DUI_ERROR ;
3317: err@var1178 .@exprUNIQUE msg@var1180 =@exprUNIQUE "unknown standard specified: '"@exprUNIQUE +@exprUNIQUE dui@var1152 .@expr7205 std@var1174 +@exprUNIQUE "'"@exprUNIQUE ;
3318: outputList@var1153 .@expr7251 push_back (@exprUNIQUE err@var1178 ) ;
3319: }
3320: output@var1148 .@expr7254 clear (@expr7255 ) ;
3321: return ;
3322: }
3323: const std :: string std_def@var1181 =@exprUNIQUE simplecpp ::@exprUNIQUE getCppStdString (@exprUNIQUE cpp_std@var1177 ) ;
3324: if ( !@exprUNIQUE std_def@var1181 .@exprUNIQUE empty (@exprUNIQUE ) ) {
3325: macros@var1160 .@expr7133 insert (@exprUNIQUE std ::@expr6952 make_pair (@exprUNIQUE "__cplusplus"@expr7263 ,@exprUNIQUE Macro (@exprUNIQUE "__cplusplus"@expr7263 ,@exprUNIQUE std_def@var1181 ,@exprUNIQUE dummy@var1158 ) ) ) ; }
3326: }
3327: }
3328:
|
3331:
3332: enum IfState { True , ElseIsTrue , AlwaysFalse } ;
3333: std ::@exprUNIQUE stack < int > ifstates@var1182 ;
3334: std ::@exprUNIQUE stack < const Token * > iftokens@var1183 ;
3335: ifstates@var1182 .@expr7273 push (@expr7275 True@expr7274 ) ;
3336:
3337: std ::@exprUNIQUE stack < const Token * > includetokenstack@var1184 ;
3338:
3339: std ::@exprUNIQUE set < std :: string > pragmaOnce@var1185 ;
3340:
3341: includetokenstack@var1184 .@expr7278 push (@exprUNIQUE rawtokens@var1149 .@exprUNIQUE cfront (@exprUNIQUE ) ) ;
3342: for ( std :: list < std :: string > :: const_iterator it@var1186 =@exprUNIQUE dui@var1152 .@expr7283 includes@var1187 .@exprUNIQUE begin (@exprUNIQUE ) ;@exprUNIQUE it@var1186 !=@exprUNIQUE dui@var1152 .@expr7283 includes@var1187 .@exprUNIQUE end (@exprUNIQUE ) ;@exprUNIQUE ++@exprUNIQUE it@var1186 ) {
3343: const FileData * const filedata@var1188 ; filedata@var1188 =@exprUNIQUE cache@var1151 .@expr7294 get (@exprUNIQUE ""@expr7295 ,@exprUNIQUE *@exprUNIQUE it@var1186 ,@exprUNIQUE dui@var1152 ,@exprUNIQUE false@exprUNIQUE ,@exprUNIQUE files@var1150 ,@exprUNIQUE outputList@var1153 ) .@exprUNIQUE first@var1189 ;
3344: if ( filedata@var1188 !=@exprUNIQUE nullptr &&@exprUNIQUE filedata@var1188 .@expr7308 tokens@var1190 .@expr7309 cfront (@expr7310 ) !=@exprUNIQUE nullptr ) {
3345: includetokenstack@var1184 .@expr7278 push (@exprUNIQUE filedata@var1188 .@expr7308 tokens@var1190 .@expr7309 cfront (@expr7310 ) ) ; }
3346: }
3347:
3348: std ::@exprUNIQUE map < std :: string , std :: list < Location > > maybeUsedMacros@var1191 ;
3349:
3350: for ( const Token * rawtok@var1192 = nullptr ; rawtok@var1192 ||@exprUNIQUE !@exprUNIQUE includetokenstack@var1184 .@exprUNIQUE empty (@exprUNIQUE ) ;@exprUNIQUE ) {
3351: if ( rawtok@var1192 ==@exprUNIQUE nullptr ) {
3352: rawtok@var1192 =@exprUNIQUE includetokenstack@var1184 .@exprUNIQUE top (@exprUNIQUE ) ;
3353: includetokenstack@var1184 .@exprUNIQUE pop (@exprUNIQUE ) ;
3354: continue ;
3355: }
3356:
3357: if ( rawtok@var1192 .@expr7328 op@var1193 ==@expr7330 '#'@expr7329 &&@exprUNIQUE !@exprUNIQUE sameline (@exprUNIQUE rawtok@var1192 .@exprUNIQUE previousSkipComments (@exprUNIQUE ) ,@exprUNIQUE rawtok@var1192 ) ) {
3358: if ( !@expr7342 sameline (@expr7341 rawtok@var1192 ,@expr7340 rawtok@var1192 .@expr7339 next@var1194 ) ) {
3359: rawtok@var1192 =@expr7343 rawtok@var1192 .@expr7339 next@var1194 ;
3360: continue ;
3361: }
3362: rawtok@var1192 =@expr7343 rawtok@var1192 .@expr7339 next@var1194 ;
3363: if ( !@exprUNIQUE rawtok@var1192 .@exprUNIQUE name@var1195 ) {
3364: rawtok@var1192 =@expr7348 gotoNextLine (@expr7347 rawtok@var1192 ) ;
3365: continue ;
3366: }
3367:
3368: if ( ifstates@var1182 .@exprUNIQUE size (@exprUNIQUE ) <=@exprUNIQUE 1U &&@exprUNIQUE ( rawtok@var1192 .@expr7355 str (@expr7356 ) ==@expr7357 ELIF@var218 ||@exprUNIQUE rawtok@var1192 .@expr7355 str (@expr7356 ) ==@expr7358 ELSE@var217 ||@exprUNIQUE rawtok@var1192 .@expr7355 str (@expr7356 ) ==@expr7360 ENDIF@var219 ) ) {
3369: if ( outputList@var1153 ) {
3370: simplecpp ::@exprUNIQUE Output err@var1196 (@exprUNIQUE files@var1150 ) ;
3371: err@var1196 .@exprUNIQUE type@var1197 =@exprUNIQUE Output ::@expr7367 SYNTAX_ERROR ;
3372: err@var1196 .@exprUNIQUE location@var1198 =@exprUNIQUE rawtok@var1192 .@expr7370 location@var1199 ;
3373: err@var1196 .@exprUNIQUE msg@var1200 =@exprUNIQUE "#"@exprUNIQUE +@exprUNIQUE rawtok@var1192 .@expr7355 str (@expr7356 ) +@exprUNIQUE " without #if"@exprUNIQUE ;
3374: outputList@var1153 .@expr7251 push_back (@exprUNIQUE err@var1196 ) ;
3375: }
3376: output@var1148 .@expr7254 clear (@expr7255 ) ;
3377: return ;
3378: }
3379:
3380: if ( ifstates@var1182 .@expr7379 top (@expr7380 ) ==@expr7381 True@expr7274 &&@exprUNIQUE ( rawtok@var1192 .@expr7355 str (@expr7356 ) ==@expr7382 ERROR@var211 ||@exprUNIQUE rawtok@var1192 .@expr7355 str (@expr7356 ) ==@exprUNIQUE WARNING@var212 ) ) {
3381: if ( outputList@var1153 ) {
3382: simplecpp ::@exprUNIQUE Output err@var1201 (@exprUNIQUE rawtok@var1192 .@expr7370 location@var1199 .@expr7387 files@var1202 ) ;
3383: err@var1201 .@exprUNIQUE type@var1203 =@exprUNIQUE rawtok@var1192 .@expr7355 str (@expr7356 ) ==@expr7382 ERROR@var211 ?@exprUNIQUE Output ::@exprUNIQUE ERROR :@exprUNIQUE Output ::@exprUNIQUE WARNING ;
3384: err@var1201 .@exprUNIQUE location@var1204 =@exprUNIQUE rawtok@var1192 .@expr7370 location@var1199 ;
3385: for ( const Token * tok@var1205 =@exprUNIQUE rawtok@var1192 .@expr7339 next@var1194 ;@exprUNIQUE tok@var1205 &&@exprUNIQUE sameline (@exprUNIQUE rawtok@var1192 ,@exprUNIQUE tok@var1205 ) ;@exprUNIQUE tok@var1205 =@exprUNIQUE tok@var1205 .@exprUNIQUE next@var1206 ) {
3386: if ( !@exprUNIQUE err@var1201 .@expr7407 msg@var1207 .@exprUNIQUE empty (@exprUNIQUE ) &&@exprUNIQUE isNameChar (@exprUNIQUE tok@var1205 .@expr7412 str (@expr7413 ) [@exprUNIQUE 0 ] ) ) {
3387: err@var1201 .@expr7407 msg@var1207 +=@exprUNIQUE ' '@expr7417 ; }
3388: err@var1201 .@expr7407 msg@var1207 +=@exprUNIQUE tok@var1205 .@expr7412 str (@expr7413 ) ;
3389: }
3390: err@var1201 .@expr7407 msg@var1207 =@exprUNIQUE '#'@expr7329 +@exprUNIQUE rawtok@var1192 .@expr7355 str (@expr7356 ) +@exprUNIQUE ' '@expr7417 +@exprUNIQUE err@var1201 .@expr7407 msg@var1207 ;
3391: outputList@var1153 .@expr7251 push_back (@exprUNIQUE err@var1201 ) ;
3392: }
3393: if ( rawtok@var1192 .@expr7355 str (@expr7356 ) ==@expr7382 ERROR@var211 ) {
3394: output@var1148 .@expr7254 clear (@expr7255 ) ;
3395: return ;
3396: }
3397: }
3398:
3399: if ( rawtok@var1192 .@expr7355 str (@expr7356 ) ==@exprUNIQUE DEFINE@var208 ) {
3400: if ( ifstates@var1182 .@expr7379 top (@expr7380 ) !=@expr7426 True@expr7274 ) {
3401: continue ; }
3402: try {
3403: const Macro & macro@var1208 =@exprUNIQUE Macro (@exprUNIQUE rawtok@var1192 .@exprUNIQUE previous@var1209 ,@exprUNIQUE files@var1150 ) ;
3404: if ( dui@var1152 .@expr7104 undefined@var1168 .@expr7105 find (@exprUNIQUE macro@var1208 .@expr7431 name (@expr7432 ) ) ==@exprUNIQUE dui@var1152 .@expr7104 undefined@var1168 .@expr7107 end (@expr7108 ) ) {
3405: const MacroMap :: iterator it@var1210 =@exprUNIQUE macros@var1160 .@expr7435 find (@exprUNIQUE macro@var1208 .@expr7431 name (@expr7432 ) ) ;
3406: if ( it@var1210 ==@exprUNIQUE macros@var1160 .@expr7438 end (@expr7439 ) ) {
3407: macros@var1160 .@expr7133 insert (@exprUNIQUE std ::@exprUNIQUE pair < std :: string , Macro > (@exprUNIQUE macro@var1208 .@expr7431 name (@expr7432 ) ,@exprUNIQUE macro@var1208 ) ) ; }
3408: else {
3409: it@var1210 .@exprUNIQUE second@var1211 =@exprUNIQUE macro@var1208 ; }
3410: }
3411: } catch (@exprUNIQUE const std ::@exprUNIQUE runtime_error & ) {
3412: if ( outputList@var1153 ) {
3413: simplecpp ::@exprUNIQUE Output err@var1212 (@exprUNIQUE files@var1150 ) ;
3414: err@var1212 .@exprUNIQUE type@var1213 =@exprUNIQUE Output ::@expr7367 SYNTAX_ERROR ;
3415: err@var1212 .@exprUNIQUE location@var1214 =@exprUNIQUE rawtok@var1192 .@expr7370 location@var1199 ;
3416: err@var1212 .@exprUNIQUE msg@var1215 = "Failed to parse #define" ;
3417: outputList@var1153 .@expr7251 push_back (@exprUNIQUE err@var1212 ) ;
3418: }
3419: output@var1148 .@expr7254 clear (@expr7255 ) ;
3420: return ;
3421: } catch (@exprUNIQUE simplecpp ::@exprUNIQUE Macro ::@exprUNIQUE Error &@exprUNIQUE err@var1216 ) {
3422: if ( outputList@var1153 ) {
3423: simplecpp ::@exprUNIQUE Output out@var1217 (@exprUNIQUE files@var1150 ) ;
3424: out@var1217 .@exprUNIQUE type@var1218 =@exprUNIQUE simplecpp ::@exprUNIQUE Output ::@exprUNIQUE SYNTAX_ERROR ;
3425: out@var1217 .@exprUNIQUE location@var1219 =@exprUNIQUE err@var1216 .@exprUNIQUE location@var1220 ;
3426: out@var1217 .@exprUNIQUE msg@var1221 =@exprUNIQUE "Failed to parse #define, "@exprUNIQUE +@exprUNIQUE err@var1216 .@exprUNIQUE what@var1222 ;
3427: outputList@var1153 .@expr7251 push_back (@exprUNIQUE out@var1217 ) ;
3428: }
3429: output@var1148 .@expr7254 clear (@expr7255 ) ;
3430: return ;
3431: }
3432: } else { if ( ifstates@var1182 .@expr7379 top (@expr7380 ) ==@expr7381 True@expr7274 &&@exprUNIQUE rawtok@var1192 .@expr7355 str (@expr7356 ) ==@exprUNIQUE INCLUDE@var210 ) {
3433: TokenList inc1@var1223 (@exprUNIQUE files@var1150 ) ;
3434: for ( const Token * inctok@var1224 =@exprUNIQUE rawtok@var1192 .@expr7339 next@var1194 ;@exprUNIQUE sameline (@exprUNIQUE rawtok@var1192 ,@exprUNIQUE inctok@var1224 ) ;@exprUNIQUE inctok@var1224 =@exprUNIQUE inctok@var1224 .@exprUNIQUE next@var1225 ) {
3435: if ( !@exprUNIQUE inctok@var1224 .@exprUNIQUE comment@var1226 ) {
3436: inc1@var1223 .@exprUNIQUE push_back (@exprUNIQUE new@exprUNIQUE Token (@exprUNIQUE *@exprUNIQUE inctok@var1224 ) ) ; }
3437: }
3438: TokenList inc2@var1227 (@exprUNIQUE files@var1150 ) ;
3439: if ( !@expr7501 inc1@var1223 .@expr7499 empty (@expr7500 ) &&@exprUNIQUE inc1@var1223 .@expr7502 cfront (@expr7503 ) .@exprUNIQUE name@var1330 ) {
3440: const Token * inctok@var1228 ; inctok@var1228 =@exprUNIQUE inc1@var1223 .@expr7502 cfront (@expr7503 ) ;
3441: if ( !@exprUNIQUE preprocessToken (@exprUNIQUE inc2@var1227 ,@exprUNIQUE &@exprUNIQUE inctok@var1228 ,@exprUNIQUE macros@var1160 ,@exprUNIQUE files@var1150 ,@exprUNIQUE outputList@var1153 ) ) {
3442: output@var1148 .@expr7254 clear (@expr7255 ) ;
3443: return ;
3444: }
3445: } else {
3446: inc2@var1227 .@exprUNIQUE takeTokens (@exprUNIQUE inc1@var1223 ) ;
3447: }
3448:
3449: if ( !@expr7501 inc1@var1223 .@expr7499 empty (@expr7500 ) &&@exprUNIQUE !@exprUNIQUE inc2@var1227 .@expr7518 empty (@expr7519 ) &&@exprUNIQUE inc2@var1227 .@expr7522 cfront (@expr7523 ) .@exprUNIQUE op@var1324 ==@exprUNIQUE '<'@expr7525 &&@exprUNIQUE inc2@var1227 .@exprUNIQUE cback (@exprUNIQUE ) .@exprUNIQUE op@var1324 ==@exprUNIQUE '>'@expr7532 ) {
3450: std ::@exprUNIQUE string hdr@var1229 ;
3451:
3452:
3453: for ( const Token * tok@var1230 =@exprUNIQUE inc2@var1227 .@expr7522 cfront (@expr7523 ) ;@exprUNIQUE tok@var1230 ;@exprUNIQUE tok@var1230 =@exprUNIQUE tok@var1230 .@exprUNIQUE next@var1231 ) {
3454: hdr@var1229 +=@exprUNIQUE tok@var1230 .@exprUNIQUE str (@exprUNIQUE ) ;
3455: }
3456: inc2@var1227 .@exprUNIQUE clear (@exprUNIQUE ) ;
3457: inc2@var1227 .@exprUNIQUE push_back (@exprUNIQUE new@exprUNIQUE Token (@exprUNIQUE hdr@var1229 ,@exprUNIQUE inc1@var1223 .@expr7502 cfront (@expr7503 ) .@exprUNIQUE location@var1325 ) ) ;
3458: inc2@var1227 .@exprUNIQUE front (@exprUNIQUE ) .@exprUNIQUE op@var1324 = '<' ;
3459: }
3460:
3461: if ( inc2@var1227 .@expr7518 empty (@expr7519 ) ||@exprUNIQUE inc2@var1227 .@expr7522 cfront (@expr7523 ) .@exprUNIQUE str (@exprUNIQUE ) .@exprUNIQUE size (@exprUNIQUE ) <=@exprUNIQUE 2U ) {
3462: if ( outputList@var1153 ) {
3463: simplecpp ::@exprUNIQUE Output err@var1232 (@exprUNIQUE files@var1150 ) ;
3464: err@var1232 .@exprUNIQUE type@var1233 =@exprUNIQUE Output ::@expr7367 SYNTAX_ERROR ;
3465: err@var1232 .@exprUNIQUE location@var1234 =@exprUNIQUE rawtok@var1192 .@expr7370 location@var1199 ;
3466: err@var1232 .@exprUNIQUE msg@var1235 = "No header in #include" ;
3467: outputList@var1153 .@expr7251 push_back (@exprUNIQUE err@var1232 ) ;
3468: }
3469: output@var1148 .@expr7254 clear (@expr7255 ) ;
3470: return ;
3471: }
3472:
3473: const Token * const inctok@var1236 ; inctok@var1236 =@exprUNIQUE inc2@var1227 .@expr7522 cfront (@expr7523 ) ;
3474:
3475: const bool systemheader@var1237 =@exprUNIQUE inctok@var1236 .@expr7572 str (@expr7573 ) [@exprUNIQUE 0 ] ==@exprUNIQUE '<'@expr7525 ;
3476: const std ::@exprUNIQUE string header@var1238 (@exprUNIQUE inctok@var1236 .@expr7572 str (@expr7573 ) .@exprUNIQUE substr (@exprUNIQUE 1U ,@exprUNIQUE inctok@var1236 .@expr7572 str (@expr7573 ) .@exprUNIQUE size (@exprUNIQUE ) -@exprUNIQUE 2U ) ) ;
3477: const FileData * const filedata@var1239 ; filedata@var1239 =@exprUNIQUE cache@var1151 .@expr7294 get (@exprUNIQUE rawtok@var1192 .@expr7370 location@var1199 .@expr7586 file (@expr7587 ) ,@exprUNIQUE header@var1238 ,@exprUNIQUE dui@var1152 ,@exprUNIQUE systemheader@var1237 ,@exprUNIQUE files@var1150 ,@exprUNIQUE outputList@var1153 ) .@exprUNIQUE first@var1189 ;
3478: if ( filedata@var1239 ==@exprUNIQUE nullptr ) {
3479: if ( outputList@var1153 ) {
3480: simplecpp ::@exprUNIQUE Output out@var1240 (@exprUNIQUE files@var1150 ) ;
3481: out@var1240 .@exprUNIQUE type@var1241 =@exprUNIQUE Output ::@exprUNIQUE MISSING_HEADER ;
3482: out@var1240 .@exprUNIQUE location@var1242 =@exprUNIQUE rawtok@var1192 .@expr7370 location@var1199 ;
3483: out@var1240 .@exprUNIQUE msg@var1243 =@exprUNIQUE "Header not found: "@exprUNIQUE +@exprUNIQUE inctok@var1236 .@expr7572 str (@expr7573 ) ;
3484: outputList@var1153 .@expr7251 push_back (@exprUNIQUE out@var1240 ) ;
3485: }
3486: } else { if ( includetokenstack@var1184 .@exprUNIQUE size (@exprUNIQUE ) >=@exprUNIQUE 400 ) {
3487: if ( outputList@var1153 ) {
3488: simplecpp ::@exprUNIQUE Output out@var1244 (@exprUNIQUE files@var1150 ) ;
3489: out@var1244 .@exprUNIQUE type@var1245 =@exprUNIQUE Output ::@exprUNIQUE INCLUDE_NESTED_TOO_DEEPLY ;
3490: out@var1244 .@exprUNIQUE location@var1246 =@exprUNIQUE rawtok@var1192 .@expr7370 location@var1199 ;
3491: out@var1244 .@exprUNIQUE msg@var1247 = "#include nested too deeply" ;
3492: outputList@var1153 .@expr7251 push_back (@exprUNIQUE out@var1244 ) ;
3493: }
3494: } else { if ( pragmaOnce@var1185 .@exprUNIQUE find (@exprUNIQUE filedata@var1239 .@exprUNIQUE filename@var1248 ) ==@exprUNIQUE pragmaOnce@var1185 .@exprUNIQUE end (@exprUNIQUE ) ) {
3495: includetokenstack@var1184 .@expr7278 push (@exprUNIQUE gotoNextLine (@expr7347 rawtok@var1192 ) ) ;
3496: rawtok@var1192 =@exprUNIQUE filedata@var1239 .@exprUNIQUE tokens@var1249 .@exprUNIQUE cfront (@exprUNIQUE ) ;
3497: continue ;
3498: } } }
3499: } else { if ( rawtok@var1192 .@expr7355 str (@expr7356 ) ==@expr7635 IF@var213 ||@exprUNIQUE rawtok@var1192 .@expr7355 str (@expr7356 ) ==@expr7636 IFDEF@var214 ||@exprUNIQUE rawtok@var1192 .@expr7355 str (@expr7356 ) ==@expr7638 IFNDEF@var215 ||@exprUNIQUE rawtok@var1192 .@expr7355 str (@expr7356 ) ==@expr7357 ELIF@var218 ) {
3500: if ( !@expr7342 sameline (@expr7341 rawtok@var1192 ,@expr7340 rawtok@var1192 .@expr7339 next@var1194 ) ) {
3501: if ( outputList@var1153 ) {
3502: simplecpp ::@exprUNIQUE Output out@var1250 (@exprUNIQUE files@var1150 ) ;
3503: out@var1250 .@exprUNIQUE type@var1251 =@exprUNIQUE Output ::@expr7367 SYNTAX_ERROR ;
3504: out@var1250 .@exprUNIQUE location@var1252 =@exprUNIQUE rawtok@var1192 .@expr7370 location@var1199 ;
3505: out@var1250 .@exprUNIQUE msg@var1253 =@exprUNIQUE "Syntax error in #"@exprUNIQUE +@exprUNIQUE rawtok@var1192 .@expr7355 str (@expr7356 ) ;
3506: outputList@var1153 .@expr7251 push_back (@exprUNIQUE out@var1250 ) ;
3507: }
3508: output@var1148 .@expr7254 clear (@expr7255 ) ;
3509: return ;
3510: }
3511:
3512: bool conditionIsTrue@var1254 ;
3513: if ( ifstates@var1182 .@expr7379 top (@expr7380 ) ==@exprUNIQUE AlwaysFalse@expr7652 ||@exprUNIQUE ( ifstates@var1182 .@expr7379 top (@expr7380 ) ==@expr7655 ElseIsTrue@expr7654 &&@exprUNIQUE rawtok@var1192 .@expr7355 str (@expr7356 ) !=@expr7656 ELIF@var218 ) ) {
3514: conditionIsTrue@var1254 = false ; }
3515: else { if ( rawtok@var1192 .@expr7355 str (@expr7356 ) ==@expr7636 IFDEF@var214 ) {
3516: conditionIsTrue@var1254 =@exprUNIQUE macros@var1160 .@expr7435 find (@expr7661 rawtok@var1192 .@expr7339 next@var1194 .@expr7659 str (@expr7660 ) ) !=@exprUNIQUE macros@var1160 .@expr7438 end (@expr7439 ) ||@exprUNIQUE ( hasInclude@var1159 &&@expr7664 rawtok@var1192 .@expr7339 next@var1194 .@expr7659 str (@expr7660 ) ==@expr7663 HAS_INCLUDE@var222 ) ;
3517: maybeUsedMacros@var1191 [@expr7667 rawtok@var1192 .@expr7339 next@var1194 .@expr7659 str (@expr7660 ) ] .@expr7668 push_back (@expr7670 rawtok@var1192 .@expr7339 next@var1194 .@expr7669 location@var1255 ) ;
3518: } else { if ( rawtok@var1192 .@expr7355 str (@expr7356 ) ==@expr7638 IFNDEF@var215 ) {
3519: conditionIsTrue@var1254 =@exprUNIQUE macros@var1160 .@expr7435 find (@expr7661 rawtok@var1192 .@expr7339 next@var1194 .@expr7659 str (@expr7660 ) ) ==@exprUNIQUE macros@var1160 .@expr7438 end (@expr7439 ) &&@exprUNIQUE !@exprUNIQUE ( hasInclude@var1159 &&@expr7664 rawtok@var1192 .@expr7339 next@var1194 .@expr7659 str (@expr7660 ) ==@expr7663 HAS_INCLUDE@var222 ) ;
3520: maybeUsedMacros@var1191 [@expr7667 rawtok@var1192 .@expr7339 next@var1194 .@expr7659 str (@expr7660 ) ] .@expr7668 push_back (@expr7670 rawtok@var1192 .@expr7339 next@var1194 .@expr7669 location@var1255 ) ;
3521: } else {
3522: TokenList expr@var1256 (@exprUNIQUE files@var1150 ) ;
3523: for ( const Token * tok@var1257 =@exprUNIQUE rawtok@var1192 .@expr7339 next@var1194 ;@exprUNIQUE tok@var1257 &&@exprUNIQUE tok@var1257 .@expr7677 location@var1258 .@exprUNIQUE sameline (@exprUNIQUE rawtok@var1192 .@expr7370 location@var1199 ) ;@exprUNIQUE tok@var1257 =@expr7682 tok@var1257 .@expr7681 next@var1259 ) {
3524: if ( !@exprUNIQUE tok@var1257 .@exprUNIQUE name@var1260 ) {
3525: expr@var1256 .@expr7687 push_back (@exprUNIQUE new@exprUNIQUE Token (@exprUNIQUE *@exprUNIQUE tok@var1257 ) ) ;
3526: continue ;
3527: }
3528:
3529: if ( tok@var1257 .@expr7692 str (@expr7693 ) ==@exprUNIQUE DEFINED@var216 ) {
3530: tok@var1257 =@expr7682 tok@var1257 .@expr7681 next@var1259 ;
3531: const bool par@var1261 =@exprUNIQUE tok@var1257 &&@expr7697 tok@var1257 .@expr7695 op@var1262 ==@expr7696 '('@expr7089 ;
3532: if ( par@var1261 ) {
3533: tok@var1257 =@expr7682 tok@var1257 .@expr7681 next@var1259 ; }
3534: maybeUsedMacros@var1191 [@expr7667 rawtok@var1192 .@expr7339 next@var1194 .@expr7659 str (@expr7660 ) ] .@expr7668 push_back (@expr7670 rawtok@var1192 .@expr7339 next@var1194 .@expr7669 location@var1255 ) ;
3535: if ( tok@var1257 ) {
3536: if ( macros@var1160 .@expr7435 find (@exprUNIQUE tok@var1257 .@expr7692 str (@expr7693 ) ) !=@exprUNIQUE macros@var1160 .@expr7438 end (@expr7439 ) ) {
3537: expr@var1256 .@expr7687 push_back (@expr7704 new@expr7703 Token (@expr7702 "1"@expr7122 ,@expr7701 tok@var1257 .@expr7677 location@var1258 ) ) ; }
3538: else { if ( hasInclude@var1159 &&@expr7706 tok@var1257 .@expr7692 str (@expr7693 ) ==@expr7705 HAS_INCLUDE@var222 ) {
3539: expr@var1256 .@expr7687 push_back (@expr7704 new@expr7703 Token (@expr7702 "1"@expr7122 ,@expr7701 tok@var1257 .@expr7677 location@var1258 ) ) ; }
3540: else {
3541: expr@var1256 .@expr7687 push_back (@expr7711 new@expr7710 Token (@expr7709 "0"@expr7707 ,@expr7708 tok@var1257 .@expr7677 location@var1258 ) ) ; } }
3542: }
3543: if ( par@var1261 ) {
3544: tok@var1257 =@expr7682 tok@var1257 ?@expr7713 tok@var1257 .@expr7681 next@var1259 :@expr7712 nullptr ; }
3545: if ( !@expr7714 tok@var1257 ||@expr7718 !@expr7717 sameline (@expr7716 rawtok@var1192 ,@expr7715 tok@var1257 ) ||@exprUNIQUE ( par@var1261 &&@exprUNIQUE tok@var1257 .@expr7695 op@var1262 !=@expr7720 ')'@expr7719 ) ) {
3546: if ( outputList@var1153 ) {
3547: Output out@var1263 (@exprUNIQUE rawtok@var1192 .@expr7370 location@var1199 .@expr7387 files@var1202 ) ;
3548: out@var1263 .@exprUNIQUE type@var1264 =@exprUNIQUE Output ::@expr7367 SYNTAX_ERROR ;
3549: out@var1263 .@exprUNIQUE location@var1265 =@exprUNIQUE rawtok@var1192 .@expr7370 location@var1199 ;
3550: out@var1263 .@exprUNIQUE msg@var1266 =@exprUNIQUE "failed to evaluate "@expr7729 +@expr7735 std ::@expr7116 string (@expr7734 rawtok@var1192 .@expr7355 str (@expr7356 ) ==@expr7635 IF@var213 ?@expr7733 "#if"@expr7730 :@expr7732 "#elif"@expr7731 ) +@expr7737 " condition"@expr7736 ;
3551: outputList@var1153 .@expr7251 push_back (@exprUNIQUE out@var1263 ) ;
3552: }
3553: output@var1148 .@expr7254 clear (@expr7255 ) ;
3554: return ;
3555: }
3556: continue ;
3557: }
3558:
3559: if ( hasInclude@var1159 &&@expr7706 tok@var1257 .@expr7692 str (@expr7693 ) ==@expr7705 HAS_INCLUDE@var222 ) {
3560: tok@var1257 =@expr7682 tok@var1257 .@expr7681 next@var1259 ;
3561: const bool par@var1267 =@exprUNIQUE tok@var1257 &&@expr7697 tok@var1257 .@expr7695 op@var1262 ==@expr7696 '('@expr7089 ;
3562: if ( par@var1267 ) {
3563: tok@var1257 =@expr7682 tok@var1257 .@expr7681 next@var1259 ; }
3564: bool closingAngularBracket@var1268 ; closingAngularBracket@var1268 = false ;
3565: if ( tok@var1257 ) {
3566: const std :: string & sourcefile@var1269 =@exprUNIQUE rawtok@var1192 .@expr7370 location@var1199 .@expr7586 file (@expr7587 ) ;
3567: const bool systemheader@var1270 =@exprUNIQUE tok@var1257 &&@exprUNIQUE tok@var1257 .@expr7695 op@var1262 ==@exprUNIQUE '<'@expr7525 ;
3568: std ::@exprUNIQUE string header@var1271 ;
3569:
3570: if ( systemheader@var1270 ) {
3571: while ( ( tok@var1257 =@expr7682 tok@var1257 .@expr7681 next@var1259 ) &&@exprUNIQUE tok@var1257 .@expr7695 op@var1262 !=@exprUNIQUE '>'@expr7532 ) {
3572: header@var1271 +=@exprUNIQUE tok@var1257 .@expr7692 str (@expr7693 ) ; }
3573: if ( tok@var1257 &&@exprUNIQUE tok@var1257 .@expr7695 op@var1262 ==@exprUNIQUE '>'@expr7532 ) {
3574: closingAngularBracket@var1268 = true ; }
3575: } else {
3576: header@var1271 =@exprUNIQUE tok@var1257 .@expr7692 str (@expr7693 ) .@exprUNIQUE substr (@exprUNIQUE 1U ,@exprUNIQUE tok@var1257 .@expr7692 str (@expr7693 ) .@exprUNIQUE size (@exprUNIQUE ) -@exprUNIQUE 2U ) ;
3577: closingAngularBracket@var1268 = true ;
3578: }
3579: std ::@exprUNIQUE ifstream f@var1272 ;
3580: const std :: string header2@var1273 =@exprUNIQUE openHeader (@exprUNIQUE f@var1272 ,@exprUNIQUE dui@var1152 ,@exprUNIQUE sourcefile@var1269 ,@exprUNIQUE header@var1271 ,@exprUNIQUE systemheader@var1270 ) ;
3581: expr@var1256 .@expr7687 push_back (@expr7711 new@expr7710 Token (@expr7709 header2@var1273 .@exprUNIQUE empty (@exprUNIQUE ) ?@exprUNIQUE "0"@expr7707 :@exprUNIQUE "1"@expr7122 ,@expr7708 tok@var1257 .@expr7677 location@var1258 ) ) ;
3582: }
3583: if ( par@var1267 ) {
3584: tok@var1257 =@expr7682 tok@var1257 ?@expr7713 tok@var1257 .@expr7681 next@var1259 :@expr7712 nullptr ; }
3585: if ( !@expr7714 tok@var1257 ||@expr7718 !@expr7717 sameline (@expr7716 rawtok@var1192 ,@expr7715 tok@var1257 ) ||@exprUNIQUE ( par@var1267 &&@exprUNIQUE tok@var1257 .@expr7695 op@var1262 !=@expr7720 ')'@expr7719 ) ||@exprUNIQUE ( !@exprUNIQUE closingAngularBracket@var1268 ) ) {
3586: if ( outputList@var1153 ) {
3587: Output out@var1274 (@exprUNIQUE rawtok@var1192 .@expr7370 location@var1199 .@expr7387 files@var1202 ) ;
3588: out@var1274 .@exprUNIQUE type@var1275 =@exprUNIQUE Output ::@expr7367 SYNTAX_ERROR ;
3589: out@var1274 .@exprUNIQUE location@var1276 =@exprUNIQUE rawtok@var1192 .@expr7370 location@var1199 ;
3590: out@var1274 .@exprUNIQUE msg@var1277 =@exprUNIQUE "failed to evaluate "@expr7729 +@expr7735 std ::@expr7116 string (@expr7734 rawtok@var1192 .@expr7355 str (@expr7356 ) ==@expr7635 IF@var213 ?@expr7733 "#if"@expr7730 :@expr7732 "#elif"@expr7731 ) +@expr7737 " condition"@expr7736 ;
3591: outputList@var1153 .@expr7251 push_back (@exprUNIQUE out@var1274 ) ;
3592: }
3593: output@var1148 .@expr7254 clear (@expr7255 ) ;
3594: return ;
3595: }
3596: continue ;
3597: }
3598:
3599: maybeUsedMacros@var1191 [@expr7667 rawtok@var1192 .@expr7339 next@var1194 .@expr7659 str (@expr7660 ) ] .@expr7668 push_back (@expr7670 rawtok@var1192 .@expr7339 next@var1194 .@expr7669 location@var1255 ) ;
3600:
3601: const Token * tmp@var1278 ; tmp@var1278 =@exprUNIQUE tok@var1257 ;
3602: if ( !@exprUNIQUE preprocessToken (@exprUNIQUE expr@var1256 ,@exprUNIQUE &@exprUNIQUE tmp@var1278 ,@exprUNIQUE macros@var1160 ,@exprUNIQUE files@var1150 ,@exprUNIQUE outputList@var1153 ) ) {
3603: output@var1148 .@expr7254 clear (@expr7255 ) ;
3604: return ;
3605: }
3606: if ( !@exprUNIQUE tmp@var1278 ) {
3607: break ; }
3608: tok@var1257 =@exprUNIQUE tmp@var1278 .@exprUNIQUE previous@var1279 ;
3609: }
3610: try {
3611: if ( ifCond@var1155 ) {
3612: std ::@exprUNIQUE string E@var1280 ;
3613: for ( const simplecpp :: Token * tok@var1281 =@exprUNIQUE expr@var1256 .@exprUNIQUE cfront (@exprUNIQUE ) ;@exprUNIQUE tok@var1281 ;@exprUNIQUE tok@var1281 =@exprUNIQUE tok@var1281 .@exprUNIQUE next@var1282 ) {
3614: E@var1280 +=@exprUNIQUE ( E@var1280 .@exprUNIQUE empty (@exprUNIQUE ) ?@exprUNIQUE ""@expr7295 :@exprUNIQUE " "@exprUNIQUE ) +@exprUNIQUE tok@var1281 .@exprUNIQUE str (@exprUNIQUE ) ; }
3615: const long long result@var1283 =@exprUNIQUE evaluate (@expr7813 expr@var1256 ,@expr7811 dui@var1152 ,@expr7812 sizeOfType@var1156 ) ;
3616: conditionIsTrue@var1254 =@exprUNIQUE result@var1283 !=@exprUNIQUE 0 ;
3617: ifCond@var1155 .@exprUNIQUE push_back (@exprUNIQUE IfCond (@exprUNIQUE rawtok@var1192 .@expr7370 location@var1199 ,@exprUNIQUE E@var1280 ,@exprUNIQUE result@var1283 ) ) ;
3618: } else {
3619: const long long result@var1284 =@exprUNIQUE evaluate (@expr7813 expr@var1256 ,@expr7811 dui@var1152 ,@expr7812 sizeOfType@var1156 ) ;
3620: conditionIsTrue@var1254 =@exprUNIQUE result@var1284 !=@exprUNIQUE 0 ;
3621: }
3622: } catch (@exprUNIQUE const std ::@exprUNIQUE exception &@exprUNIQUE e@var1285 ) {
3623: if ( outputList@var1153 ) {
3624: Output out@var1286 (@exprUNIQUE rawtok@var1192 .@expr7370 location@var1199 .@expr7387 files@var1202 ) ;
3625: out@var1286 .@exprUNIQUE type@var1287 =@exprUNIQUE Output ::@expr7367 SYNTAX_ERROR ;
3626: out@var1286 .@exprUNIQUE location@var1288 =@exprUNIQUE rawtok@var1192 .@expr7370 location@var1199 ;
3627: out@var1286 .@expr7835 msg@var1289 =@exprUNIQUE "failed to evaluate "@expr7729 +@expr7735 std ::@expr7116 string (@expr7734 rawtok@var1192 .@expr7355 str (@expr7356 ) ==@expr7635 IF@var213 ?@expr7733 "#if"@expr7730 :@expr7732 "#elif"@expr7731 ) +@expr7737 " condition"@expr7736 ;
3628: if ( e@var1285 .@expr7838 what (@expr7839 ) &&@exprUNIQUE *@exprUNIQUE e@var1285 .@expr7838 what (@expr7839 ) ) {
3629: out@var1286 .@expr7835 msg@var1289 +=@exprUNIQUE std ::@expr7116 string (@exprUNIQUE ", "@exprUNIQUE ) +@exprUNIQUE e@var1285 .@expr7838 what (@expr7839 ) ; }
3630: outputList@var1153 .@expr7251 push_back (@exprUNIQUE out@var1286 ) ;
3631: }
3632: output@var1148 .@expr7254 clear (@expr7255 ) ;
3633: return ;
3634: }
3635: } } }
3636:
3637: if ( rawtok@var1192 .@expr7355 str (@expr7356 ) !=@expr7656 ELIF@var218 ) {
3638:
3639: if ( ifstates@var1182 .@expr7379 top (@expr7380 ) !=@expr7426 True@expr7274 ) {
3640: ifstates@var1182 .@expr7273 push (@exprUNIQUE AlwaysFalse@expr7652 ) ; }
3641: else {
3642: ifstates@var1182 .@expr7273 push (@expr7275 conditionIsTrue@var1254 ?@exprUNIQUE True@expr7274 :@exprUNIQUE ElseIsTrue@expr7654 ) ; }
3643: iftokens@var1183 .@exprUNIQUE push (@exprUNIQUE rawtok@var1192 ) ;
3644: } else { if ( ifstates@var1182 .@expr7379 top (@expr7380 ) ==@expr7381 True@expr7274 ) {
3645: ifstates@var1182 .@expr7379 top (@expr7380 ) = AlwaysFalse ;
3646: iftokens@var1183 .@expr7852 top (@expr7853 ) .@expr7855 nextcond =@expr7856 rawtok@var1192 ;
3647: iftokens@var1183 .@expr7852 top (@expr7853 ) =@expr7857 rawtok@var1192 ;
3648: } else { if ( ifstates@var1182 .@expr7379 top (@expr7380 ) ==@expr7655 ElseIsTrue@expr7654 &&@exprUNIQUE conditionIsTrue@var1254 ) {
3649: ifstates@var1182 .@expr7379 top (@expr7380 ) = True ;
3650: iftokens@var1183 .@expr7852 top (@expr7853 ) .@expr7855 nextcond =@expr7856 rawtok@var1192 ;
3651: iftokens@var1183 .@expr7852 top (@expr7853 ) =@expr7857 rawtok@var1192 ;
3652: } } }
3653: } else { if ( rawtok@var1192 .@expr7355 str (@expr7356 ) ==@expr7358 ELSE@var217 ) {
3654: ifstates@var1182 .@expr7379 top (@expr7380 ) =@exprUNIQUE ( ifstates@var1182 .@expr7379 top (@expr7380 ) ==@expr7655 ElseIsTrue@expr7654 ) ?@exprUNIQUE True@expr7274 :@exprUNIQUE AlwaysFalse@expr7652 ;
3655: iftokens@var1183 .@expr7852 top (@expr7853 ) .@expr7855 nextcond =@expr7856 rawtok@var1192 ;
3656: iftokens@var1183 .@expr7852 top (@expr7853 ) =@expr7857 rawtok@var1192 ;
3657: } else { if ( rawtok@var1192 .@expr7355 str (@expr7356 ) ==@expr7360 ENDIF@var219 ) {
3658: ifstates@var1182 .@exprUNIQUE pop (@exprUNIQUE ) ;
3659: iftokens@var1183 .@expr7852 top (@expr7853 ) .@expr7855 nextcond =@expr7856 rawtok@var1192 ;
3660: iftokens@var1183 .@exprUNIQUE pop (@exprUNIQUE ) ;
3661: } else { if ( rawtok@var1192 .@expr7355 str (@expr7356 ) ==@exprUNIQUE UNDEF@var209 ) {
3662: if ( ifstates@var1182 .@expr7379 top (@expr7380 ) ==@expr7381 True@expr7274 ) {
3663: const Token * tok@var1290 ; tok@var1290 =@exprUNIQUE rawtok@var1192 .@expr7339 next@var1194 ;
3664: while ( sameline (@expr7869 rawtok@var1192 ,@expr7868 tok@var1290 ) &&@exprUNIQUE tok@var1290 .@exprUNIQUE comment@var1291 ) {
3665: tok@var1290 =@exprUNIQUE tok@var1290 .@exprUNIQUE next@var1292 ; }
3666: if ( sameline (@expr7869 rawtok@var1192 ,@expr7868 tok@var1290 ) ) {
3667: macros@var1160 .@exprUNIQUE erase (@exprUNIQUE tok@var1290 .@exprUNIQUE str (@exprUNIQUE ) ) ; }
3668: }
3669: } else { if ( ifstates@var1182 .@expr7379 top (@expr7380 ) ==@expr7381 True@expr7274 &&@exprUNIQUE rawtok@var1192 .@expr7355 str (@expr7356 ) ==@exprUNIQUE PRAGMA@var220 &&@exprUNIQUE rawtok@var1192 .@expr7339 next@var1194 &&@exprUNIQUE rawtok@var1192 .@expr7339 next@var1194 .@expr7659 str (@expr7660 ) ==@exprUNIQUE ONCE@var221 &&@exprUNIQUE sameline (@expr7341 rawtok@var1192 ,@expr7340 rawtok@var1192 .@expr7339 next@var1194 ) ) {
3670: pragmaOnce@var1185 .@exprUNIQUE insert (@exprUNIQUE rawtok@var1192 .@expr7370 location@var1199 .@expr7586 file (@expr7587 ) ) ;
3671: } } } } } } }
3672: if ( ifstates@var1182 .@expr7379 top (@expr7380 ) !=@expr7426 True@expr7274 &&@exprUNIQUE rawtok@var1192 .@expr7887 nextcond@var1293 ) {
3673: rawtok@var1192 =@exprUNIQUE rawtok@var1192 .@expr7887 nextcond@var1293 .@exprUNIQUE previous@var1294 ; }
3674: else {
3675: rawtok@var1192 =@expr7348 gotoNextLine (@expr7347 rawtok@var1192 ) ; }
3676: continue ;
3677: }
3678:
3679: if ( ifstates@var1182 .@expr7379 top (@expr7380 ) !=@expr7426 True@expr7274 ) {
3680:
3681: rawtok@var1192 =@expr7348 gotoNextLine (@expr7347 rawtok@var1192 ) ;
3682: continue ;
3683: }
3684:
3685: bool hash@var1295 ; hash@var1295 = false ; bool hashhash@var1296 ; hashhash@var1296 = false ;
3686: if ( rawtok@var1192 .@expr7328 op@var1193 ==@expr7330 '#'@expr7329 &&@exprUNIQUE sameline (@expr7341 rawtok@var1192 ,@expr7340 rawtok@var1192 .@expr7339 next@var1194 ) ) {
3687: if ( rawtok@var1192 .@expr7339 next@var1194 .@exprUNIQUE op@var1297 !=@exprUNIQUE '#'@expr7329 ) {
3688: hash@var1295 = true ;
3689: rawtok@var1192 =@expr7343 rawtok@var1192 .@expr7339 next@var1194 ;
3690: } else { if ( sameline (@exprUNIQUE rawtok@var1192 ,@exprUNIQUE rawtok@var1192 .@expr7339 next@var1194 .@expr7894 next@var1298 ) ) {
3691: hashhash@var1296 = true ;
3692: rawtok@var1192 =@exprUNIQUE rawtok@var1192 .@expr7339 next@var1194 .@expr7894 next@var1298 ;
3693: } }
3694: }
3695:
3696: const Location loc@var1299 (@exprUNIQUE rawtok@var1192 .@expr7370 location@var1199 ) ;
3697: TokenList tokens@var1300 (@exprUNIQUE files@var1150 ) ;
3698:
3699: if ( !@exprUNIQUE preprocessToken (@exprUNIQUE tokens@var1300 ,@exprUNIQUE &@exprUNIQUE rawtok@var1192 ,@exprUNIQUE macros@var1160 ,@exprUNIQUE files@var1150 ,@exprUNIQUE outputList@var1153 ) ) {
3700: output@var1148 .@expr7254 clear (@expr7255 ) ;
3701: return ;
3702: }
3703:
3704: if ( hash@var1295 ||@exprUNIQUE hashhash@var1296 ) {
3705: std ::@exprUNIQUE string s@var1301 ;
3706: for ( const Token * hashtok@var1302 =@exprUNIQUE tokens@var1300 .@exprUNIQUE cfront (@exprUNIQUE ) ;@exprUNIQUE hashtok@var1302 ;@exprUNIQUE hashtok@var1302 =@exprUNIQUE hashtok@var1302 .@exprUNIQUE next@var1303 ) {
3707: s@var1301 +=@exprUNIQUE hashtok@var1302 .@exprUNIQUE str (@exprUNIQUE ) ; }
3708: if ( hash@var1295 ) {
3709: output@var1148 .@expr7919 push_back (@exprUNIQUE new@exprUNIQUE Token (@exprUNIQUE '\"'@expr7920 +@exprUNIQUE s@var1301 +@exprUNIQUE '\"'@expr7920 ,@exprUNIQUE loc@var1299 ) ) ; }
3710: else { if ( output@var1148 .@expr7928 back (@expr7929 ) ) {
3711: output@var1148 .@expr7928 back (@expr7929 ) .@exprUNIQUE setstr (@exprUNIQUE output@var1148 .@exprUNIQUE cback (@exprUNIQUE ) .@exprUNIQUE str (@exprUNIQUE ) +@exprUNIQUE s@var1301 ) ; }
3712: else {
3713: output@var1148 .@expr7919 push_back (@exprUNIQUE new@exprUNIQUE Token (@exprUNIQUE s@var1301 ,@exprUNIQUE loc@var1299 ) ) ; } }
3714: } else {
3715: output@var1148 .@exprUNIQUE takeTokens (@exprUNIQUE tokens@var1300 ) ;
3716: }
3717: }
3718:
3719: if ( macroUsage@var1154 ) {
3720: for ( std :: unordered_map < std :: string , Macro > :: const_iterator macroIt@var1304 =@exprUNIQUE macros@var1160 .@exprUNIQUE begin (@exprUNIQUE ) ;@exprUNIQUE macroIt@var1304 !=@exprUNIQUE macros@var1160 .@expr7438 end (@expr7439 ) ;@exprUNIQUE ++@exprUNIQUE macroIt@var1304 ) {
3721: const Macro & macro@var1305 =@exprUNIQUE macroIt@var1304 .@exprUNIQUE second@var1306 ;
3722: std ::@exprUNIQUE list < Location > usage@var1307 ; usage@var1307 =@exprUNIQUE macro@var1305 .@exprUNIQUE usage (@exprUNIQUE ) ;
3723: const std :: list < Location > & temp@var1308 =@exprUNIQUE maybeUsedMacros@var1191 [@exprUNIQUE macro@var1305 .@expr7958 name (@expr7959 ) ] ;
3724: usage@var1307 .@exprUNIQUE insert (@exprUNIQUE usage@var1307 .@expr7963 end (@expr7964 ) ,@exprUNIQUE temp@var1308 .@exprUNIQUE begin (@exprUNIQUE ) ,@exprUNIQUE temp@var1308 .@exprUNIQUE end (@exprUNIQUE ) ) ;
3725: for ( std :: list < Location > :: const_iterator usageIt@var1309 =@exprUNIQUE usage@var1307 .@exprUNIQUE begin (@exprUNIQUE ) ;@exprUNIQUE usageIt@var1309 !=@exprUNIQUE usage@var1307 .@expr7963 end (@expr7964 ) ;@exprUNIQUE ++@exprUNIQUE usageIt@var1309 ) {
3726: MacroUsage mu@var1310 (@exprUNIQUE usageIt@var1309 .@exprUNIQUE files@var1311 ,@exprUNIQUE macro@var1305 .@exprUNIQUE valueDefinedInCode (@exprUNIQUE ) ) ;
3727: mu@var1310 .@exprUNIQUE macroName@var1312 =@exprUNIQUE macro@var1305 .@expr7958 name (@expr7959 ) ;
3728: mu@var1310 .@exprUNIQUE macroLocation@var1313 =@exprUNIQUE macro@var1305 .@exprUNIQUE defineLocation (@exprUNIQUE ) ;
3729: mu@var1310 .@exprUNIQUE useLocation@var1314 =@exprUNIQUE *@exprUNIQUE usageIt@var1309 ;
3730: macroUsage@var1154 .@exprUNIQUE push_back (@exprUNIQUE mu@var1310 ) ;
3731: }
3732: }
3733: }
3734: }
3735:
3736: void simplecpp :: cleanup ( FileDataCache & cache@var1315 )
3737: {
3738: cache@var1315 .@exprUNIQUE clear (@exprUNIQUE ) ;
3739: }
3740:
3741: simplecpp :: cstd_t simplecpp :: getCStd ( const std :: string & std@var1316 )
3742: {
3743: if ( std@var1316 ==@exprUNIQUE "c90"@exprUNIQUE ||@exprUNIQUE std@var1316 ==@exprUNIQUE "c89"@exprUNIQUE ||@exprUNIQUE std@var1316 ==@exprUNIQUE "iso9899:1990"@exprUNIQUE ||@exprUNIQUE std@var1316 ==@exprUNIQUE "iso9899:199409"@exprUNIQUE ||@exprUNIQUE std@var1316 ==@exprUNIQUE "gnu90"@exprUNIQUE ||@exprUNIQUE std@var1316 ==@exprUNIQUE "gnu89"@exprUNIQUE ) {
3744: return C89@exprUNIQUE ; }
3745: if ( std@var1316 ==@exprUNIQUE "c99"@exprUNIQUE ||@exprUNIQUE std@var1316 ==@exprUNIQUE "c9x"@exprUNIQUE ||@exprUNIQUE std@var1316 ==@exprUNIQUE "iso9899:1999"@exprUNIQUE ||@exprUNIQUE std@var1316 ==@exprUNIQUE "iso9899:199x"@exprUNIQUE ||@exprUNIQUE std@var1316 ==@exprUNIQUE "gnu99"@exprUNIQUE ||@exprUNIQUE std@var1316 ==@exprUNIQUE "gnu9x"@exprUNIQUE ) {
3746: return C99@exprUNIQUE ; }
3747: if ( std@var1316 ==@exprUNIQUE "c11"@exprUNIQUE ||@exprUNIQUE std@var1316 ==@exprUNIQUE "c1x"@exprUNIQUE ||@exprUNIQUE std@var1316 ==@exprUNIQUE "iso9899:2011"@exprUNIQUE ||@exprUNIQUE std@var1316 ==@exprUNIQUE "gnu11"@exprUNIQUE ||@exprUNIQUE std@var1316 ==@exprUNIQUE "gnu1x"@exprUNIQUE ) {
3748: return C11@exprUNIQUE ; }
3749: if ( std@var1316 ==@exprUNIQUE "c17"@exprUNIQUE ||@exprUNIQUE std@var1316 ==@exprUNIQUE "c18"@exprUNIQUE ||@exprUNIQUE std@var1316 ==@exprUNIQUE "iso9899:2017"@exprUNIQUE ||@exprUNIQUE std@var1316 ==@exprUNIQUE "iso9899:2018"@exprUNIQUE ||@exprUNIQUE std@var1316 ==@exprUNIQUE "gnu17"@exprUNIQUE ||@exprUNIQUE std@var1316 ==@exprUNIQUE "gnu18"@exprUNIQUE ) {
3750: return C17@exprUNIQUE ; }
3751: if ( std@var1316 ==@exprUNIQUE "c23"@exprUNIQUE ||@exprUNIQUE std@var1316 ==@exprUNIQUE "gnu23"@exprUNIQUE ||@exprUNIQUE std@var1316 ==@exprUNIQUE "c2x"@exprUNIQUE ||@exprUNIQUE std@var1316 ==@exprUNIQUE "gnu2x"@exprUNIQUE ) {
3752: return C23@exprUNIQUE ; }
3753: return CUnknown@exprUNIQUE ;
3754: }
3755:
3756: std :: string simplecpp :: getCStdString ( cstd_t std@var1317 )
3757: {
3758: switch ( std@var1317 ) {
3759: case C89@exprUNIQUE : ;
3760:
3761: return ""@expr8083 ;
3762: case C99@exprUNIQUE : ;
3763: return "199901L"@exprUNIQUE ;
3764: case C11@exprUNIQUE : ;
3765: return "201112L"@exprUNIQUE ;
3766: case C17@exprUNIQUE : ;
3767: return "201710L"@exprUNIQUE ;
3768: case C23@exprUNIQUE : ;
3769:
|
3772:
3773: return "202311L"@exprUNIQUE ;
3774: case CUnknown@exprUNIQUE : ;
3775: return ""@expr8083 ;
3776: }
3777: return ""@expr8083 ;
3778: }
3779:
3780: std :: string simplecpp :: getCStdString ( const std :: string & std@var1318 )
3781: {
3782: return getCStdString (@exprUNIQUE getCStd (@exprUNIQUE std@var1318 ) ) ;
3783: }
3784:
3785: simplecpp :: cppstd_t simplecpp :: getCppStd ( const std :: string & std@var1319 )
3786: {
3787: if ( std@var1319 ==@exprUNIQUE "c++98"@exprUNIQUE ||@exprUNIQUE std@var1319 ==@exprUNIQUE "c++03"@exprUNIQUE ||@exprUNIQUE std@var1319 ==@exprUNIQUE "gnu++98"@exprUNIQUE ||@exprUNIQUE std@var1319 ==@exprUNIQUE "gnu++03"@exprUNIQUE ) {
3788: return CPP03@exprUNIQUE ; }
3789: if ( std@var1319 ==@exprUNIQUE "c++11"@exprUNIQUE ||@exprUNIQUE std@var1319 ==@exprUNIQUE "gnu++11"@exprUNIQUE ||@exprUNIQUE std@var1319 ==@exprUNIQUE "c++0x"@exprUNIQUE ||@exprUNIQUE std@var1319 ==@exprUNIQUE "gnu++0x"@exprUNIQUE ) {
3790: return CPP11@exprUNIQUE ; }
3791: if ( std@var1319 ==@exprUNIQUE "c++14"@exprUNIQUE ||@exprUNIQUE std@var1319 ==@exprUNIQUE "c++1y"@exprUNIQUE ||@exprUNIQUE std@var1319 ==@exprUNIQUE "gnu++14"@exprUNIQUE ||@exprUNIQUE std@var1319 ==@exprUNIQUE "gnu++1y"@exprUNIQUE ) {
3792: return CPP14@exprUNIQUE ; }
3793: if ( std@var1319 ==@exprUNIQUE "c++17"@exprUNIQUE ||@exprUNIQUE std@var1319 ==@exprUNIQUE "c++1z"@exprUNIQUE ||@exprUNIQUE std@var1319 ==@exprUNIQUE "gnu++17"@exprUNIQUE ||@exprUNIQUE std@var1319 ==@exprUNIQUE "gnu++1z"@exprUNIQUE ) {
3794: return CPP17@exprUNIQUE ; }
3795: if ( std@var1319 ==@exprUNIQUE "c++20"@exprUNIQUE ||@exprUNIQUE std@var1319 ==@exprUNIQUE "c++2a"@exprUNIQUE ||@exprUNIQUE std@var1319 ==@exprUNIQUE "gnu++20"@exprUNIQUE ||@exprUNIQUE std@var1319 ==@exprUNIQUE "gnu++2a"@exprUNIQUE ) {
3796: return CPP20@exprUNIQUE ; }
3797: if ( std@var1319 ==@exprUNIQUE "c++23"@exprUNIQUE ||@exprUNIQUE std@var1319 ==@exprUNIQUE "c++2b"@exprUNIQUE ||@exprUNIQUE std@var1319 ==@exprUNIQUE "gnu++23"@exprUNIQUE ||@exprUNIQUE std@var1319 ==@exprUNIQUE "gnu++2b"@exprUNIQUE ) {
3798: return CPP23@exprUNIQUE ; }
3799: if ( std@var1319 ==@exprUNIQUE "c++26"@exprUNIQUE ||@exprUNIQUE std@var1319 ==@exprUNIQUE "c++2c"@exprUNIQUE ||@exprUNIQUE std@var1319 ==@exprUNIQUE "gnu++26"@exprUNIQUE ||@exprUNIQUE std@var1319 ==@exprUNIQUE "gnu++2c"@exprUNIQUE ) {
3800: return CPP26@exprUNIQUE ; }
3801: return CPPUnknown@exprUNIQUE ;
3802: }
3803:
3804: std :: string simplecpp :: getCppStdString ( cppstd_t std@var1320 )
3805: {
3806: switch ( std@var1320 ) {
3807: case CPP03@exprUNIQUE : ;
3808: return "199711L"@exprUNIQUE ;
3809: case CPP11@exprUNIQUE : ;
3810: return "201103L"@exprUNIQUE ;
3811: case CPP14@exprUNIQUE : ;
3812: return "201402L"@exprUNIQUE ;
3813: case CPP17@exprUNIQUE : ;
3814: return "201703L"@exprUNIQUE ;
3815: case CPP20@exprUNIQUE : ;
3816:
3817: return "202002L"@exprUNIQUE ;
3818: case CPP23@exprUNIQUE : ;
3819:
|
3822:
3823: return "202302L"@exprUNIQUE ;
3824: case CPP26@exprUNIQUE : ;
3825:
3826: return "202400L"@exprUNIQUE ;
3827: case CPPUnknown@exprUNIQUE : ;
3828: return ""@expr8197 ;
3829: }
3830: return ""@expr8197 ;
3831: }
3832:
3833: std :: string simplecpp :: getCppStdString ( const std :: string & std@var1321 )
3834: {
3835: return getCppStdString (@exprUNIQUE getCppStd (@exprUNIQUE std@var1321 ) ) ;
3836: }



##Value flow
File simplecpp-1.5.1/simplecpp.h
Line 51
  CUnknown always -1
  = always -1
  -1 always -1
  , always 0
  C89 always 0
  , always 1
  C99 always 1
  , always 2
  C11 always 2
  , always 3
  C17 always 3
  , always 4
  C23 always 4
Line 54
  CPPUnknown always -1
  = always -1
  -1 always -1
  , always 0
  CPP03 always 0
  , always 1
  CPP11 always 1
  , always 2
  CPP14 always 2
  , always 3
  CPP17 always 3
  , always 4
  CPP20 always 4
  , always 5
  CPP23 always 5
  , always 6
  CPP26 always 6
Line 65
  ( possible lifetime[SubObject]=(std::vector<std::string>&f)
  fileIndex always !<=-1
  0 always 0
  line always !<=-1
  1U always 1
  col always !<=-1
  0U always 0
Line 67
  fileIndex always !<=-1
  . always !<=-1
  fileIndex always !<=-1
  line always !<=-1
  . always !<=-1
  line always !<=-1
  col always !<=-1
  . always !<=-1
  col always !<=-1
Line 70
  this always !0
  != always {!<=-1,!>=2}
  & {lifetime[Address]=(other),!0}
Line 71
  fileIndex always !<=-1
  = always !<=-1
  . always !<=-1
  fileIndex always !<=-1
Line 72
  line always !<=-1
  = always !<=-1
  . always !<=-1
  line always !<=-1
Line 73
  col always !<=-1
  = always !<=-1
  . always !<=-1
  col always !<=-1
Line 75
  this always !0
Line 81
  ( always {!<=-1,!>=2}
Line 82
  fileIndex always !<=-1
  != always {!<=-1,!>=2}
  . always !<=-1
  fileIndex always !<=-1
Line 83
  return always {!<=-1,!>=2}
  fileIndex always {!<=-1,!symbolic=(rhs.fileIndex)}
  < always {!<=-1,!>=2}
  . always {!<=-1,!symbolic=(fileIndex)}
  fileIndex always !<=-1
Line 84
  line always !<=-1
  != always {!<=-1,!>=2}
  . always !<=-1
  line always !<=-1
Line 85
  return always {!<=-1,!>=2}
  line always {!<=-1,!symbolic=(rhs.line)}
  < always {!<=-1,!>=2}
  . always {!<=-1,!symbolic=(line)}
  line always !<=-1
Line 86
  return always {!<=-1,!>=2}
  col always !<=-1
  < always {!<=-1,!>=2}
  . always !<=-1
  col always !<=-1
Line 89
  ( always {!<=-1,!>=2}
Line 90
  return always {!<=-1,!>=2}
  fileIndex always !<=-1
  == always {!<=-1,!>=2}
  . always !<=-1
  fileIndex always !<=-1
  && always {!<=-1,!>=2}
  line always !<=-1
  == always {!<=-1,!>=2}
  . always !<=-1
  line always !<=-1
Line 94
  fileIndex always !<=-1
  < always {!<=-1,!>=2}
  ( always !<=-1
  fileIndex {!<=-1,<=symbolic=(files.size()-1),!>=symbolic=(files.size())}
Line 98
  fileIndex always !<=-1
Line 99
  line always !<=-1
Line 100
  col always !<=-1
Line 111
  wsahead always {!<=-1,!>=2}
  = always 0
  false always 0
Line 112
  whitespaceahead always {!<=-1,!>=2}
  wsahead always {!<=-1,!>=2}
  nullptr always 0
  nullptr always 0
  nullptr always 0
Line 117
  comment always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  comment always {!<=-1,!>=2}
  name always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  name always {!<=-1,!>=2}
  number always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  number always {!<=-1,!>=2}
  whitespaceahead always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  whitespaceahead always {!<=-1,!>=2}
  nullptr always 0
  nullptr always 0
  nullptr always 0
Line 121
  name always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always !<=-1
  0 always 0
  || always {!<=-1,!>=2}
  0 always 0
  == always {!<=-1,!>=2}
  '_' always 95
  || always {!<=-1,!>=2}
  0 always 0
  == always {!<=-1,!>=2}
  '$' always 36
Line 122
  && always {!<=-1,!>=2}
  ( {lifetime[Object]=(string),!0}
  '\'' always 39
  ( always !<=-1
  == always {!<=-1,!>=2}
  nullptr always 0
Line 123
  comment always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always !<=-1
  > always {!<=-1,!>=2}
  1U always 1
  && always {!<=-1,!>=2}
  string {>=size=2,!<=size=1}
  0 always 0
  == always {!<=-1,!>=2}
  '/' always 47
  && always {!<=-1,!>=2}
  string {>=size=2,!<=size=1}
  1 always 1
  == always {!<=-1,!>=2}
  '/' always 47
  || always {!<=-1,!>=2}
  string always !<=size=1
  1 always 1
  == always {!<=-1,!>=2}
  '*' always 42
Line 124
  number always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 125
  ( always !<=-1
  == always {!<=-1,!>=2}
  1U always 1
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  name always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  comment always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  number always {!<=-1,!>=2}
  string possible size=1
  0 always 0
  : always 0
  '\0' always 0
Line 132
  = possible {"0"@254,"&&"@120,"||"@122,"!="@156}
  s possible {"0"@254,"&&"@120,"||"@122,"!="@156}
Line 136
  ( always {!<=-1,!>=2}
Line 137
  ( always {!<=-1,!>=2}
Line 138
  ( always {!<=-1,!>=2}
Line 139
  ( always {!<=-1,!>=2}
Line 140
  return always {!<=-1,!>=2}
  ( possible 0
  ( {!<=-1,45,43}
  [ possible {45,43}
  0 always 0
  || always {!<=-1,!>=2}
Line 141
  ( always !<=-1
  > always {!<=-1,!>=2}
  1U always 1
  && always {!<=-1,!>=2}
  str {>=size=2,!<=size=1}
  0 always 0
  == always {!<=-1,!>=2}
  '-' always 45
  || always {!<=-1,!>=2}
  str always !<=size=1
  0 always 0
  == always {!<=-1,!>=2}
  '+' always 43
  && always {!<=-1,!>=2}
  ( always !<=-1
  str {>=size=2,!<=size=1}
  1 always 1
Line 146
  comment always {!<=-1,!>=2}
Line 147
  name always {!<=-1,!>=2}
Line 148
  number always {!<=-1,!>=2}
Line 149
  whitespaceahead always {!<=-1,!>=2}
Line 156
  this always !0
Line 157
  tok possible symbolic=(this->previous)
  && always {!<=-1,!>=2}
  tok {symbolic=(this->previous),!0}
  . always {!<=-1,!>=2}
  comment always {!<=-1,!>=2}
Line 158
  tok always !0
Line 159
  tok possible {symbolic=(this->previous),0}
Line 163
  this always !0
Line 164
  tok possible symbolic=(this->next)
  && always {!<=-1,!>=2}
  tok {symbolic=(this->next),!0}
  . always {!<=-1,!>=2}
  comment always {!<=-1,!>=2}
Line 165
  tok always !0
Line 166
  tok possible {symbolic=(this->next),0}
Line 171
  mExpandedFrom possible lifetime[Object]=(m)
Line 172
  . always {!<=-1,!>=2}
  whitespaceahead always {!<=-1,!>=2}
Line 173
  whitespaceahead always {!<=-1,!>=2}
  = always 1
  true always 1
Line 175
  ( always {!<=-1,!>=2}
Line 176
  return always {!<=-1,!>=2}
  mExpandedFrom possible lifetime[Object]=(m)
  ( possible lifetime[Iterator]=(mExpandedFrom)
  m possible lifetime[Object]=(macros)@102
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mExpandedFrom),end=0}
Line 192
  ERROR always 0
Line 194
  ERROR always 0
Line 195
  WARNING always 1
Line 196
  MISSING_HEADER always 2
Line 197
  INCLUDE_NESTED_TOO_DEEPLY always 3
Line 198
  SYNTAX_ERROR always 4
Line 199
  PORTABILITY_BACKSLASH always 5
Line 200
  UNHANDLED_CHAR_ERROR always 6
Line 201
  EXPLICIT_INCLUDE_NOT_FOUND always 7
Line 202
  FILE_NOT_FOUND always 8
Line 203
  DUI_ERROR always 9
Line 205
  ( possible lifetime[SubObject]=(type)
Line 219
  = always 0
  nullptr always 0
Line 221
  = always 0
  nullptr always 0
Line 223
  = always 0
  nullptr always 0
Line 225
  = always 0
  nullptr always 0
Line 227
  && always {!<=-1,!>=2}
Line 230
  && always {!<=-1,!>=2}
Line 233
  ( always {!<=-1,!>=2}
Line 234
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 241
  , always 0
  = always 0
  nullptr always 0
Line 263
  ! {!<=-1,!>=2,1@9}
  tok possible {symbolic=(tok->previous)@118,0@9}
Line 265
  tok always !0
Line 266
  tok always !0
Line 267
  prev always symbolic=(tok->previous)
Line 268
  prev {symbolic=(tok->previous),!0}
  = always symbolic=(tok->next)
  next always symbolic=(tok->next)
Line 269
  next always symbolic=(tok->next)
Line 270
  next {symbolic=(tok->next),!0}
  = always symbolic=(tok->previous)
  prev always symbolic=(tok->previous)
Line 271
  == always {!<=-1,!>=2}
  tok always !0
Line 272
  = always symbolic=(tok->next)
  next always symbolic=(tok->next)
Line 273
  == always {!<=-1,!>=2}
  tok always !0
Line 274
  = always symbolic=(tok->previous)
  prev always symbolic=(tok->previous)
Line 275
  tok always !0
Line 279
  ! always {!<=-1,!>=2}
Line 281
  ! always {!<=-1,!>=2}
Line 282
  = always !0
  . always !0
Line 284
  = always !0
  . always !0
Line 285
  . always !0
Line 288
  = always 0
  = always 0
  nullptr always 0
Line 313
  = always 1000
  1000 always 1000
Line 314
  = always 1000
  1000 always 1000
Line 315
  ( always {!<=-1,!>=2}
  = always 1000
  1000 always 1000
Line 317
  ( always !<=-1
Line 326
  macroValueKnown_ always {!<=-1,!>=2}
  macroValueKnown always {!<=-1,!>=2}
  macroValueKnown_ always {!<=-1,!>=2}
Line 330
  macroValueKnown always {!<=-1,!>=2}
Line 346
  clearIncludeCache always {!<=-1,!>=2}
  false always 0
  removeComments always {!<=-1,!>=2}
  false always 0
Line 352
  clearIncludeCache always {!<=-1,!>=2}
Line 353
  removeComments always {!<=-1,!>=2}
Line 358
  , always 0
  = always 0
  nullptr always 0
Line 372
  , always 0
  = always 0
  nullptr always 0
  , always 0
  = always 0
  nullptr always 0
  , always 0
  = always 0
  nullptr always 0
Line 411
  && always {!<=-1,!>=2}
Line 414
  && always {!<=-1,!>=2}
Line 421
  ( possible lifetime[Object]=(data)
Line 423
  newdata always size=0
Line 424
  newdata inconclusive size=0
  newdata inconclusive size=0
Line 439
  ( always !<=-1
Line 442
  return possible lifetime[Iterator]=(mData)
  ( {lifetime[Iterator]=(mData),start=0}
Line 445
  return possible lifetime[Iterator]=(mData)
  ( {lifetime[Iterator]=(mData),end=0}
Line 448
  return possible lifetime[Iterator]=(mData)
  ( {lifetime[Iterator]=(mData),start=0}
Line 451
  return possible lifetime[Iterator]=(mData)
  ( {lifetime[Iterator]=(mData),end=0}
Line 454
  return possible lifetime[Iterator]=(mData)
  ( {lifetime[Iterator]=(mData),start=0}
Line 457
  return possible lifetime[Iterator]=(mData)
  ( {lifetime[Iterator]=(mData),end=0}
Line 480
  ( always {!<=-1,!>=2}
  true always 1
Line 481
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 485
  ( always !<=-1
Line 490
  return always !<=-1
  ( always !<=-1
  ^ always !<=-1
  ( always !<=-1
Line 499
  ( always {!<=-1,!>=2}
File simplecpp-1.5.1/simplecpp.cpp
Line 49
  ( always {!<=-1,!>=2}
Line 51
  return always {!<=-1,!>=2}
  ( always !<=-1
  > always {!<=-1,!>=2}
  2 always 2
  && always {!<=-1,!>=2}
  s {>=size=3,!<=size=2}
  0 always 0
  2 always 2
  "0x" always "0x"
  == always {!<=-1,!>=2}
  0 always 0
  || always {!<=-1,!>=2}
  0 always 0
  2 always 2
  "0X" always "0X"
  == always {!<=-1,!>=2}
  0 always 0
Line 54
  ( always {!<=-1,!>=2}
Line 56
  return always {!<=-1,!>=2}
  ( always !<=-1
  > always {!<=-1,!>=2}
  1 always 1
  && always {!<=-1,!>=2}
  s {>=size=2,!<=size=1}
  0 always 0
  == always {!<=-1,!>=2}
  '0' always 48
  && always {!<=-1,!>=2}
  s {>=size=2,!<=size=1}
  1 always 1
  >= always {!<=-1,!>=2}
  '0' always 48
  && always {!<=-1,!>=2}
  [ possible >=48
  1 always 1
  < {!<=-1,!>=2,>=1}
  '8' always 56
Line 60
  ( always {!<=-1,!>=2}
Line 62
  return always {!<=-1,!>=2}
  ( always !<=-1
  > always {!<=-1,!>=2}
  1 always 1
  && always {!<=-1,!>=2}
  s {>=size=2,!<=size=1}
  0 always 0
  == always {!<=-1,!>=2}
  '\"' always 34
  && always {!<=-1,!>=2}
  s {>=size=2,!<=size=1}
  ( {lifetime[Iterator]=(s),>=size=2,!<=size=1,start=0}
  == always {!<=-1,!>=2}
  '\"' always 34
Line 66
  ( always {!<=-1,!>=2}
Line 70
  return always {!<=-1,!>=2}
  ( always !<=-1
  > always {!<=-1,!>=2}
  1 always 1
  && always {!<=-1,!>=2}
  s {>=size=2,!<=size=1}
  0 always 0
  == always {!<=-1,!>=2}
  '\'' always 39
  && always {!<=-1,!>=2}
  s {>=size=2,!<=size=1}
  ( {lifetime[Iterator]=(s),>=size=2,!<=size=1,start=0}
  == always {!<=-1,!>=2}
  '\'' always 39
Line 73
  "define" always "define"
Line 74
  "undef" always "undef"
Line 76
  "include" always "include"
Line 78
  "error" always "error"
Line 79
  "warning" always "warning"
Line 81
  "if" always "if"
Line 82
  "ifdef" always "ifdef"
Line 83
  "ifndef" always "ifndef"
Line 84
  "defined" always "defined"
Line 85
  "else" always "else"
Line 86
  "elif" always "elif"
Line 87
  "endif" always "endif"
Line 89
  "pragma" always "pragma"
Line 90
  "once" always "once"
Line 92
  "__has_include" always "__has_include"
Line 98
  t possible {symbolic=(lhs/rhs)@227,symbolic=(lhs%rhs)@227}
Line 114
  hex {!<=-1,!>=2,0}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 115
  oct {!<=-1,!>=2,0}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 116
  hex {symbolic=(isHex(s)),!<=-1,!>=2,0}
  2 always 2
  oct {!<=-1,!>=2,0}
  1 always 1
Line 117
  hex {symbolic=(isHex(s)),!<=-1,!>=2}
Line 119
  oct always {!<=-1,!>=2}
Line 125
  ( always !<=-1
Line 127
  ret always !<=-1
Line 128
  hex {!<=-1,!>=2,0}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 129
  oct {!<=-1,!>=2,0}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 130
  hex {symbolic=(isHex(s)),!<=-1,!>=2,0}
  2 always 2
  oct {!<=-1,!>=2,0}
  1 always 1
Line 131
  hex {symbolic=(isHex(s)),!<=-1,!>=2}
Line 133
  oct always {!<=-1,!>=2}
Line 135
  ret always !<=-1
Line 136
  return always !<=-1
  ret always !<=-1
Line 139
  ( always {!<=-1,!>=2}
Line 141
  return always {!<=-1,!>=2}
  s possible >=size=4@72
  ( {!<=-1,>=4@72}
  >= always {!<=-1,!>=2}
  e possible "/."@20
  ( always !<=-1
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  e possible "/."@20
  ( {lifetime[Iterator]=(e),start=0}
  e possible "/."@20
  ( {lifetime[Iterator]=(e),end=0}
  ( {lifetime[Iterator]=(s),start=0}
Line 144
  ( always {!<=-1,!>=2}
Line 146
  return always {!<=-1,!>=2}
  tok1 {symbolic=(tok)@8,symbolic=(lpar)@9,0@27}
  && {!<=-1,!>=2,0@27}
  tok2 {symbolic=(rawtok->next)@144,symbolic=(rawtok->nextSkipComments())@189,symbolic=(B->next)@76,symbolic=(tok3?tok3->next:nullptr)@155,symbolic=(tok->next)@156,symbolic=(tok->next)@252,symbolic=(lpar)@8,symbolic=(nameTokDef->next->next)@23}
  && {!<=-1,!>=2,0@27}
  tok1 {!0,symbolic=(tok)@8,symbolic=(lpar)@9}
  ( always {!<=-1,!>=2}
  tok2 {!0,symbolic=(rawtok->next)@144,symbolic=(rawtok->nextSkipComments())@189,symbolic=(B->next)@76,symbolic=(tok3?tok3->next:nullptr)@155,symbolic=(tok->next)@156,symbolic=(tok->next)@252,symbolic=(lpar)@8,symbolic=(nameTokDef->next->next)@23}
Line 149
  ( always {!<=-1,!>=2}
Line 151
  return always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  name always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 152
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 153
  && always {!<=-1,!>=2}
Line 154
  && always {!<=-1,!>=2}
Line 155
  . always !0
  . always {!<=-1,!>=2}
  number always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  . always !0
  . always {!<=-1,!>=2}
  name always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  . always !0
  == always {!<=-1,!>=2}
  ')' always 41
  && always {!<=-1,!>=2}
Line 156
  . always !0
  . always {!<=-1,!>=2}
  number always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  . always !0
  . always {!<=-1,!>=2}
  name always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  . always !0
  == always {!<=-1,!>=2}
  '(' always 40
Line 159
  ( always {!<=-1,!>=2}
Line 161
  return always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  name always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 162
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  . always !0
  == always {!<=-1,!>=2}
  '(' always 40
  && always {!<=-1,!>=2}
Line 163
  && always {!<=-1,!>=2}
  . always !0
  . always {!<=-1,!>=2}
  name always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  . always !0
  . always {!<=-1,!>=2}
  number always {!<=-1,!>=2}
Line 168
  pos always !<=-1
  = always !<=-1
  ( always !<=-1
  from possible "\\\\"@47
  pos always !<=-1
  != always {!<=-1,!>=2}
  pos always !<=-1
  = always !<=-1
  ( always !<=-1
  from inconclusive "\\\\"@47
  pos always !<=-1
  + always !<=-1
  to inconclusive "\\"@47
  ( always !<=-1
Line 169
  pos always !<=-1
  from inconclusive "\\\\"@47
  ( always !<=-1
  to inconclusive "\\"@47
Line 177
  ( {lifetime[Object]=(str),!0}
  "\r\n" always "\r\n"
  == always {!<=-1,!>=2}
  nullptr always 0
Line 178
  col always !<=-1
  += always !<=-1
  ( always !<=-1
Line 182
  i always !<=-1
  = always 0
  0U always 0
  i {!<=-1,0}
  < always {!<=-1,!>=2}
  ( {!<=-1,>=symbolic=(i+1),<=symbolic=(i)}
  ++ always !<=0
  i always !<=-1
Line 183
  col always !<=-1
  ++ always !<=-1
Line 184
  [ possible 13
  i always !<=-1
  == {!<=-1,!>=2,0}
  '\n' always 10
  || {!<=-1,!>=2,1}
  [ possible 13
  i always !<=-1
  == {!<=-1,!>=2,1}
  '\r' always 13
Line 185
  col always !<=-1
  = always 1
  1 always 1
Line 186
  line always !<=-1
  ++ always !<=-1
Line 187
  [ possible {10,13}
  i always !<=-1
  == {!<=-1,!>=2,0,1}
  '\r' always 13
  && {!<=-1,!>=2,0}
  i always !<=-1
  + always !<=0
  1 always 1
  < always {!<=-1,!>=2}
  ( always !<=-1
  && {!<=-1,!>=2,0}
  i {!<=-1,<=symbolic=(str.size()-2),!>=symbolic=(str.size()-1)}
  + always !<=0
  1 always 1
  == always {!<=-1,!>=2}
  '\n' always 10
Line 188
  ++ {!<=0,<=symbolic=(str.size()-1),!>=symbolic=(str.size())}
  i {!<=-1,<=symbolic=(str.size()-2),!>=symbolic=(str.size()-1)}
Line 193
  ( always {!<=-1,!>=2}
Line 195
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  '\0' always 0
  && always {!<=-1,!>=2}
  ops possible {"+-*/%&|^"@27,"#="@35}
  op always !0
  != always {!<=-1,!>=2}
  nullptr always 0
Line 198
  ( always {!<=-1,!>=2}
Line 200
  return always {!<=-1,!>=2}
  c possible "<>=!"@157
  0 always 0
  != always {!<=-1,!>=2}
  nullptr always 0
Line 203
  ( always {!<=-1,!>=2}
Line 205
  return always {!<=-1,!>=2}
  ( always !<=-1
  - always !<=-1
  1U always 1
  != always {!<=-1,!>=2}
  nullptr always 0
Line 210
  = always !0
  this always !0
Line 211
  . possible 0
Line 212
  = always !0
  . always !0
Line 215
  ( always {!<=-1,!>=2}
  . always !0
  ' ' always 32
  : always 10
  '\n' always 10
Line 224
  = always !0
  this always !0
Line 225
  != always {!<=-1,!>=2}
  this always !0
Line 226
  ( always {!<=-1,!>=2}
  ' ' always 32
  : always 10
  '\n' always 10
Line 238
  0 always 0
Line 239
  0 always 0
Line 240
  0 always 0
Line 241
  ( always {!<=-1,!>=2}
  0 always 0
Line 243
  ( always !<=-1
Line 244
  ch always !<=-1
  ch always !<=-1
  = always !<=-1
  ( always !<=-1
Line 248
  isUtf16 always {!<=-1,!>=2}
Line 249
  ch2 always !<=-1
  = always !<=-1
  ( always !<=-1
Line 250
  ch always !<=-1
  ch2 always !<=-1
Line 251
  ch always !<=-1
  = {255,!<=-1}
  ( {255,!<=-1}
  >= always {!<=-1,!>=2}
  0x80 always 128
  ? possible 255
  0xff always 255
  : always 255
  ch16 {!>=128,<=127}
Line 255
  ch {symbolic=(static_cast<unsigned char>((ch16>=0x80)?0xff:ch16)),!<=-1,255}
  == {!<=-1,!>=2,0}
  '\r' always 13
Line 256
  ch always !<=-1
  = always 10
  '\n' always 10
Line 259
  isUtf16 always {!<=-1,!>=2}
Line 264
  != always {!<=-1,!>=2}
  '\n' always 10
Line 268
  return always !<=-1
  ch {!<=-1,255,10}
Line 271
  ( always !<=-1
Line 272
  ch always !<=-1
  ch always !<=-1
  = always !<=-1
  ( always !<=-1
Line 276
  isUtf16 always {!<=-1,!>=2}
Line 278
  ch2 always !<=-1
  = always !<=-1
  ( always !<=-1
Line 280
  ch always !<=-1
  ch2 always !<=-1
Line 281
  ch always !<=-1
  = {255,!<=-1}
  ( {255,!<=-1}
  >= always {!<=-1,!>=2}
  0x80 always 128
  ? possible 255
  0xff always 255
  : always 255
  ch16 {!>=128,<=127}
Line 285
  ch {symbolic=(static_cast<unsigned char>((ch16>=0x80)?0xff:ch16)),!<=-1,255}
  == {!<=-1,!>=2,0}
  '\r' always 13
Line 286
  ch always !<=-1
  = always 10
  '\n' always 10
Line 288
  return always !<=-1
  ch {!<=-1,255,10}
Line 293
  isUtf16 always {!<=-1,!>=2}
Line 300
  isUtf16 always {!<=-1,!>=2}
  = always 0
  false always 0
Line 301
  bom always !<=-1
  = always !<=-1
  ( always !<=-1
Line 302
  isUtf16 always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  bom always !<=-1
  == always {!<=-1,!>=2}
  0xfeff always 65279
  || always {!<=-1,!>=2}
  bom always {!<=-1,!65279}
  == always {!<=-1,!>=2}
  0xfffe always 65534
Line 306
  ch always !<=-1
  ch2 always !<=-1
Line 307
  bom always !<=-1
  == always {!<=-1,!>=2}
  0xfeff always 65279
  ch always !<=-1
  8 always 8
  ch2 always !<=-1
  ch2 always !<=-1
  8 always 8
  ch always !<=-1
Line 310
  ( always !<=-1
Line 314
  >= always {!<=-1,!>=2}
  0xfe always 254
Line 316
  byte always !<=-1
  = {!<=-1,>=65024}
  ( {>=254,!<=253}
  ch1 {>=254,!<=253}
  << possible >=65024
  8 always 8
Line 317
  >= always {!<=-1,!>=2}
  0xfe always 254
Line 318
  return always !<=-1
  byte always !<=-1
  ( always !<=-1
Line 320
  return always !<=-1
  0 always 0
Line 324
  ch1 {!>=254,<=253}
  == {!<=-1,!>=2,<=0}
  0xef always 239
Line 326
  == always {!<=-1,!>=2}
  0xbb always 187
Line 328
  == always {!<=-1,!>=2}
  0xbf always 191
Line 330
  return always !<=-1
  0 always 0
Line 337
  return always !<=-1
  0 always 0
Line 340
  bom always !<=-1
Line 342
  isUtf16 always {!<=-1,!>=2}
Line 348
  ( possible lifetime[SubObject]=(std::istream&istr)
Line 350
  ( always {!<=-1,!>=2}
Line 363
  ( always {!<=-1,!>=2}
Line 364
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 374
  size always !<=-1
Line 375
  : always !<=-1
  ( always !<=-1
Line 376
  size always !<=-1
  size always !<=-1
Line 377
  pos always !<=-1
  0 always 0
Line 378
  0 always 0
Line 383
  pos always !<=-1
  >= always {!<=-1,!>=2}
  size always !<=-1
Line 385
  [ always !<=-1
  pos {!<=-1,!>=symbolic=(size),<=symbolic=(size-1)}
  ++ {!<=-1,!>=symbolic=(size),<=symbolic=(size-1)}
Line 388
  pos always !<=-1
  >= always {!<=-1,!>=2}
  size always !<=-1
Line 390
  [ always !<=-1
  pos {!<=-1,!>=symbolic=(size),<=symbolic=(size-1)}
Line 393
  -- always !<=-1
  pos always !<=-1
Line 395
  ( always {!<=-1,!>=2}
Line 396
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 401
  size always !<=-1
Line 402
  pos always !<=-1
Line 410
  file possible 0
  ( possible 0
  ( {lifetime[Object]=(filename),!0}
  "rb" always "rb"
Line 411
  0 always 0
Line 412
  0 always 0
Line 413
  ! always {!<=-1,!>=2}
Line 415
  files always !size=0
  :: always 8
  FILE_NOT_FOUND always 8
  "File is missing: " always "File is missing: "
Line 422
  = always 0
  nullptr always 0
Line 438
  ( always {!<=-1,!>=2}
Line 439
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 444
  isUtf16 always {!<=-1,!>=2}
Line 447
  -1 always -1
  1 always 1
Line 460
  nullptr always 0
  nullptr always 0
Line 463
  nullptr always 0
  nullptr always 0
Line 469
  size always !<=-1
Line 470
  nullptr always 0
  nullptr always 0
Line 472
  size always !<=-1
Line 476
  size always !<=-1
Line 477
  nullptr always 0
  nullptr always 0
Line 479
  size always !<=-1
Line 484
  nullptr always 0
  nullptr always 0
Line 494
  nullptr always 0
  nullptr always 0
Line 496
  this always !0
Line 499
  && always {!<=-1,!>=2}
  nullptr always 0
  nullptr always 0
Line 501
  this always !0
  = possible lifetime[Object]=(other)
  ( possible lifetime[Object]=(other)
Line 511
  this always !0
  != always {!<=-1,!>=2}
  & {lifetime[Address]=(other),!0}
Line 518
  this always !0
Line 521
  && always {!<=-1,!>=2}
Line 523
  this always !0
  != always {!<=-1,!>=2}
  & {lifetime[Address]=(other),!0}
Line 526
  = always 0
  nullptr always 0
Line 528
  = always 0
  nullptr always 0
Line 530
  = possible lifetime[Object]=(other)
  ( possible lifetime[Object]=(other)
Line 532
  this always !0
Line 537
  = always 0
  nullptr always 0
Line 538
  frontToken possible symbolic=(frontToken->next)
Line 539
  frontToken {symbolic=(frontToken->next),!0}
Line 540
  frontToken {symbolic=(frontToken->next),!0}
Line 541
  = always symbolic=(frontToken->next)
  next always symbolic=(frontToken->next)
Line 548
  ! always {!<=-1,!>=2}
Line 566
  < always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 567
  "\n#line " always "\n#line "
  . possible <=symbolic=(loc.line-1)
  " \"" always " \""
  "\"\n" always "\"\n"
Line 571
  . possible symbolic=(loc)
  > always {!<=-1,!>=2}
  loc possible symbolic=(tok->location)
Line 572
  '\n' always 10
Line 576
  ( always {!<=-1,!>=2}
Line 577
  ' ' always 32
Line 587
  ( always {!<=-1,!>=2}
  ch always !<=-1
Line 589
  return always {!<=-1,!>=2}
  ( possible 0
  ch {!<=-1,95,36,47@56,34@56,39@56}
  || always {!<=-1,!>=2}
  ch always !<=-1
  == always {!<=-1,!>=2}
  '_' always 95
  || always {!<=-1,!>=2}
  ch always {!<=-1,!95}
  == always {!<=-1,!>=2}
  '$' always 36
Line 595
  '\"' always 34
Line 596
  i always !<=-1
  = always 1
  1U always 1
  i {!<=0,1}
  < always {!<=-1,!>=2}
  ( always !<=-1
  - always !<=-1
  1 always 1
  ++ always !<=1
  i always !<=0
Line 597
  c possible {92,34,39}
  i {<=symbolic=(str.size()-1-1),!>=symbolic=(str.size()-1),!<=0,1}
Line 598
  c {symbolic=(str[i]),34,39}
  == {!<=-1,!>=2,0}
  '\\' always 92
  || always {!<=-1,!>=2}
  c {symbolic=(str[i]),39,!92}
  == {!<=-1,!>=2,0}
  '\"' always 34
  || always {!<=-1,!>=2}
  c {symbolic=(str[i]),!92,!34}
  == always {!<=-1,!>=2}
  '\'' always 39
Line 599
  '\\' always 92
Line 600
  c {symbolic=(str[i]),92,34,39}
Line 602
  '\"' always 34
Line 608
  ! always {!<=-1,!>=2}
Line 611
  = always 5
  :: always 5
  PORTABILITY_BACKSLASH always 5
Line 613
  = always "Combination 'backslash space newline' is not portable."
  "Combination 'backslash space newline' is not portable." always "Combination 'backslash space newline' is not portable."
Line 614
  outputList always !0
Line 617
  ( always {!<=-1,!>=2}
Line 619
  return always {!<=-1,!>=2}
  str possible {size=1,size=2,size=3}
  == {!<=-1,!>=2,0}
  "u" always "u"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "U" always "U"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "L" always "L"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "u8" always "u8"
  || always {!<=-1,!>=2}
Line 620
  == always {!<=-1,!>=2}
  "R" always "R"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "uR" always "uR"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "UR" always "UR"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "LR" always "LR"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "u8R" always "u8R"
Line 623
  fileIndex always !<=-1
  line always !<=-1
Line 625
  fileIndex always !<=-1
  != always {!<=-1,!>=2}
  location possible {lifetime[Address]=(location)@43,lifetime[Address]=(location)@45}
  . always !<=-1
  fileIndex always !<=-1
  || always {!<=-1,!>=2}
  line always !<=-1
  >= always {!<=-1,!>=2}
  location possible {lifetime[Address]=(location)@43,lifetime[Address]=(location)@45}
  . always !<=-1
  line always !<=-1
Line 626
  location possible {lifetime[Address]=(location)@43,lifetime[Address]=(location)@45}
  . always !<=-1
  fileIndex always !<=-1
  = always !<=-1
  fileIndex always !<=-1
Line 627
  location possible {lifetime[Address]=(location)@43,lifetime[Address]=(location)@45}
  . always !<=-1
  line always !<=-1
  = always !<=-1
  line always !<=-1
Line 631
  line always !<=-1
  + always !<=1
  2 always 2
  >= always {!<=-1,!>=2}
  location possible {lifetime[Address]=(location)@43,lifetime[Address]=(location)@45}
  . always !<=-1
  line always !<=-1
Line 632
  . always !<=-1
  line always !<=-1
  = {!<=-1,>=symbolic=(location->line-2),!<=symbolic=(location->line-3)}
  line {!<=-1,>=symbolic=(location->line-2),!<=symbolic=(location->line-3)}
Line 633
  != always {!<=-1,!>=2}
  '#' always 35
Line 640
  "*/" always "*/"
Line 646
  multiline always !<=-1
  multiline always !<=-1
  = always 0
  0U always 0
Line 648
  = always 0
  nullptr always 0
Line 651
  = always !<=-1
  ( always !<=-1
Line 652
  = always 1
  1U always 1
Line 653
  = always 1
  1U always 1
Line 654
  ( always {!<=-1,!>=2}
Line 655
  ch always !<=-1
  ch always !<=-1
  = always !<=-1
  ( always !<=-1
Line 656
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 659
  ch always !<=-1
  >= always {!<=-1,!>=2}
  0x80 always 128
Line 662
  = always 6
  :: always 6
  UNHANDLED_CHAR_ERROR always 6
Line 665
  ( always !<=127
  ch always !<=127
Line 666
  "The code contains unhandled character(s) (character code=" always "The code contains unhandled character(s) (character code="
  "). Neither unicode nor extended ascii is supported." always "). Neither unicode nor extended ascii is supported."
Line 667
  outputList always !0
Line 673
  ch {!<=-1,!>=128,<=127}
  == {!<=-1,!>=2,<=0}
  '\n' always 10
Line 674
  && always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
  '\\' always 92
Line 675
  > always {!<=-1,!>=2}
  ( always !0
  . always !<=-1
  col always !<=-1
  + always !<=0
  1U always 1
Line 676
  ( always !0
Line 677
  ++ always !<=0
  multiline always !<=-1
Line 680
  multiline always !<=-1
  + always !<=0
  1 always 1
Line 681
  multiline always !<=-1
  = always 0
  0U always 0
Line 683
  ! {!<=-1,!>=2,1}
  multiline {!<=-1,0}
Line 684
  = always 1
  1 always 1
Line 686
  != always {!<=-1,!>=2}
Line 687
  = always !symbolic=(oldLastToken)
  ( always !symbolic=(oldLastToken)
Line 688
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 690
  lastline possible {size=12,size=13,size=18,size=9}
Line 691
  lastline possible {size=12,size=13,size=18,size=9}
  == {!<=-1,!>=2,0}
  "# file %str%" always "# file %str%"
Line 693
  strtok possible symbolic=(cback())
Line 696
  = always !<=-1
  ( always !<=-1
  strtok possible symbolic=(cback())
  1U always 1
  strtok possible symbolic=(cback())
  2U always 2
Line 697
  = always 1
  1U always 1
Line 698
  lastline possible {size=13,size=18,size=9}
  == {!<=-1,!>=2,0}
  "# line %num%" always "# line %num%"
Line 700
  numtok possible symbolic=(cback())
Line 702
  numtok possible symbolic=(cback())
  & {lifetime[Address]=(location),!0}
Line 703
  lastline possible {size=18,size=9}
  == {!<=-1,!>=2,0}
  "# %num% %str%" always "# %num% %str%"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "# line %num% %str%" always "# line %num% %str%"
Line 705
  strtok possible symbolic=(cback())
Line 707
  strtok possible symbolic=(cback())
Line 708
  numtok possible symbolic=(strtok->previous)
Line 710
  ( always !<=-1
  1U always 1
  2U always 2
  "\\\\" always "\\\\"
  "\\" always "\\"
Line 711
  numtok possible symbolic=(strtok->previous)
  & {lifetime[Address]=(location),!0}
Line 714
  == always {!<=-1,!>=2}
  "# endfile" always "# endfile"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 715
  loc always !size=0
Line 716
  loc always !size=0
Line 723
  ch {!<=-1,!>=128,<=127,!10}
  <= {!<=-1,!>=2,<=0}
  ' ' always 32
Line 730
  && always {!<=-1,!>=2}
  ( always !0
  . always !<=-1
  line always !<=-1
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  && always {!<=-1,!>=2}
  . always !0
  == always {!<=-1,!>=2}
  '#' always 35
Line 732
  && always {!<=-1,!>=2}
  llTok always !0
  == always {!<=-1,!>=2}
  '#' always 35
  && always {!<=-1,!>=2}
  llTok always !0
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "error" always "error"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "warning" always "warning"
Line 733
  = always 32
  ' ' always 32
Line 734
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  prev possible 32
  == {!<=-1,!>=2,0}
  '\\' always 92
  || always {!<=-1,!>=2}
  ch always !<=-1
  != always {!<=-1,!>=2}
  '\r' always 13
  && always {!<=-1,!>=2}
  ch always {!<=-1,!13}
  != always {!<=-1,!>=2}
  '\n' always 10
Line 735
  ch {!<=-1,92}
Line 736
  = always !<=-1
  ch always !<=-1
Line 737
  ch always !<=-1
  = always !<=-1
  ( always !<=-1
Line 740
  currentToken possible size=0
Line 747
  ( always {!<=-1,!>=2}
  ch {!<=-1,47,34,39}
Line 748
  num {!<=-1,!>=2,0}
  = always {!<=-1,!>=2}
  ch always !<=-1
Line 749
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ch always !<=-1
Line 750
  ch always !<=-1
Line 751
  ch always !<=-1
  = always !<=-1
  ( always !<=-1
Line 752
  num always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ch always !<=-1
  == always {!<=-1,!>=2}
  '\'' always 39
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always !<=-1
Line 753
  ch always !<=-1
  = always !<=-1
  ( always !<=-1
Line 760
  ch {!<=-1,47,34,39}
  == {!<=-1,!>=2,1,0}
  '/' always 47
  && {!<=-1,!>=2,0}
  ( always !<=-1
  == always {!<=-1,!>=2}
  '/' always 47
Line 761
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ch always !<=-1
  != always {!<=-1,!>=2}
  '\n' always 10
Line 762
  ch always {!<=-1,!10}
Line 763
  ch always !<=-1
  = always !<=-1
  ( always !<=-1
Line 764
  ch always !<=-1
  == always {!<=-1,!>=2}
  '\\' always 92
Line 766
  = always 92
  ch always 92
Line 767
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  '\\' always 92
  || always {!<=-1,!>=2}
  tmp_ch always !92
  == always {!<=-1,!>=2}
  ' ' always 32
  || always {!<=-1,!>=2}
  tmp_ch always {!92,!32}
  == always {!<=-1,!>=2}
  '\t' always 9
Line 769
  = always !<=-1
  ( always !<=-1
Line 771
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 775
  != always {!<=-1,!>=2}
  '\n' always 10
Line 778
  currentToken always !<=size=0
Line 779
  pos {!<=-1,<=symbolic=(check_portability.size()-1U-1),>=symbolic=(check_portability.size()-1U)}
  = always !<=-1
  check_portability always symbolic=(currentToken+tmp)
  ( always !<=-1
  " \t" always " \t"
Line 780
  pos always !<=-1
  < always {!<=-1,!>=2}
  check_portability always symbolic=(currentToken+tmp)
  ( always !<=-1
  - always !<=-1
  1U always 1
  && always {!<=-1,!>=2}
  check_portability always symbolic=(currentToken+tmp)
  pos {!<=-1,<=symbolic=(check_portability.size()-1U-1),!>=symbolic=(check_portability.size()-1U)}
  == always {!<=-1,!>=2}
  '\\' always 92
Line 782
  ++ always !<=0
  multiline always !<=-1
Line 783
  = always !<=-1
  ( always !<=-1
Line 784
  '\n' always 10
Line 786
  ch always !<=-1
  = always !<=-1
Line 789
  ch {!<=-1,10}
  == {!<=-1,!>=2,1}
  '\n' always 10
Line 795
  ch {!<=-1,34,39}
  == {!<=-1,!>=2,0}
  '/' always 47
  && {!<=-1,!>=2,0}
  ( always !<=-1
  == always {!<=-1,!>=2}
  '*' always 42
Line 796
  = always "/*"
  "/*" always "/*"
Line 797
  ( always !<=-1
  ( always !<=-1
Line 798
  ch always !<=-1
  = always !<=-1
  ( always !<=-1
Line 799
  ( always {!<=-1,!>=2}
Line 800
  ch always !<=-1
Line 801
  currentToken always !<=size=0
  ( always !<=0
  >= always {!<=-1,!>=2}
  4U always 4
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  currentToken {>=size=4,!<=size=3}
Line 803
  ch always !<=-1
  = always !<=-1
  ( always !<=-1
Line 807
  :: always !<=-1
  pos always !<=-1
  pos always !<=-1
  = always 0
  0 always 0
Line 808
  pos always !<=-1
  = always !<=-1
  currentToken possible {"/*",size=2}
  ( always !<=-1
  "\\\n" always "\\\n"
  pos {!<=-1,0}
  != always {!<=-1,!>=2}
Line 809
  pos always !<=-1
  2 always 2
Line 810
  ++ always !<=0
  multiline always !<=-1
Line 812
  multiline always !<=-1
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 813
  pos always !<=-1
  = always 0
  0 always 0
Line 814
  pos always !<=-1
  = always !<=-1
  ( always !<=-1
  '\n' always 10
  pos {!<=-1,0}
  != always {!<=-1,!>=2}
Line 815
  pos always !<=-1
  1 always 1
Line 816
  ++ always !<=0
  multiline always !<=-1
Line 822
  ch {!<=-1,39,34}
  == {!<=-1,!>=2,0,1}
  '\"' always 34
  || {!<=-1,!>=2,1}
  ch always {!<=-1,!34}
  == always {!<=-1,!>=2}
  '\'' always 39
Line 824
  && always {!<=-1,!>=2}
  ( always !0
  . always {!<=-1,!>=2}
  name always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always !0
  && always {!<=-1,!>=2}
Line 825
  . always !<=-1
  col always !<=-1
  + always !<=-1
  ( always !<=-1
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 826
  . always !<=-1
  line always !<=-1
  == always {!<=-1,!>=2}
Line 827
  ( always !0
Line 830
  ch always !<=-1
  == always {!<=-1,!>=2}
  '\"' always 34
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(cback()->str()),start=0}
  == always {!<=-1,!>=2}
  'R' always 82
Line 832
  = always 34
  ch always 34
Line 833
  prefix always !size=0
  ( always !<=-1
  - always !<=-1
  1 always 1
Line 834
  ch always !<=-1
  = always !<=-1
  ( always !<=-1
Line 835
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ch always !<=-1
  != always {!<=-1,!>=2}
  '(' always 40
  && always {!<=-1,!>=2}
  ch always {!<=-1,!40}
  != always {!<=-1,!>=2}
  '\n' always 10
Line 836
  ch always {!<=-1,!40,!10}
Line 837
  ch always !<=-1
  = always !<=-1
  ( always !<=-1
Line 839
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ch always !<=-1
  == always {!<=-1,!>=2}
  '\n' always 10
Line 842
  = always 4
  :: always 4
  SYNTAX_ERROR always 4
Line 844
  = always "Invalid newline in raw string delimiter."
  "Invalid newline in raw string delimiter." always "Invalid newline in raw string delimiter."
Line 845
  outputList always !0
Line 849
  ')' always 41
  currentToken always !<=-1
Line 850
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !<=-1
  > always {!<=-1,!>=2}
  1 always 1
Line 851
  ( always !<=-1
Line 852
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 855
  = always 4
  :: always 4
  SYNTAX_ERROR always 4
Line 857
  = always "Raw string missing terminating delimiter."
  "Raw string missing terminating delimiter." always "Raw string missing terminating delimiter."
Line 858
  outputList always !0
Line 862
  ( always !<=-1
  - always !<=-1
  ( always !<=-1
  ( always !<=-1
  - always !<=-1
  1U always 1
Line 864
  ( possible lifetime[Iterator]=(currentToken)
  0 always 0
Line 867
  ( always !<=-1
  "\r\n" always "\r\n"
  == always {!<=-1,!>=2}
Line 868
  2 always 2
  + always !<=1
  2 always 2
  * always !<=-1
  ( always !<=-1
Line 870
  1 always 1
  + always !<=0
  ( always !<=-1
Line 875
  ch always !<=-1
  ch always !<=-1
Line 876
  ( always !<=-1
  < always {!<=-1,!>=2}
  2U always 2
Line 880
  = {!<=size=1,>=size=2}
  currentToken {!<=size=1,>=size=2}
Line 881
  :: always !<=-1
  pos always !<=-1
Line 882
  = always 0
  0 always 0
Line 883
  pos always !<=-1
  = always !<=-1
  s possible {symbolic=(currentToken),>=size=2}
  ( always !<=-1
  "\r\n" always "\r\n"
  != always {!<=-1,!>=2}
Line 884
  pos always !<=-1
  1 always 1
Line 888
  ( always {!<=-1,!>=2}
Line 889
  ( always !<=-1
Line 891
  prefix always !size=0
Line 893
  > always {!<=-1,!>=2}
  0 always 0
Line 895
  && always {!<=-1,!>=2}
  llTok always !0
  == always {!<=-1,!>=2}
  '#' always 35
  && always {!<=-1,!>=2}
  llTok always !0
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "define" always "define"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "pragma" always "pragma"
  && always {!<=-1,!>=2}
Line 896
  multiline always !<=-1
  += always !<=-1
  newlines always !<=0
Line 902
  currentToken always !<=size=1
Line 907
  ch always {!<=-1,!34,!39}
Line 910
  ( {lifetime[Iterator]=(currentToken),start=0}
  == always {!<=-1,!>=2}
  '<' always 60
Line 912
  && always {!<=-1,!>=2}
  llTok always !0
  == always {!<=-1,!>=2}
  '#' always 35
  && always {!<=-1,!>=2}
  llTok always !0
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "include" always "include"
Line 913
  '<' always 60
  '>' always 62
Line 914
  ( always !<=-1
  < always {!<=-1,!>=2}
  2U always 2
Line 919
  currentToken possible >=size=2
  ( always !<=-1
Line 921
  multiline always !<=-1
Line 922
  ( always !<=-1
Line 935
  tok possible 0
  && {!<=-1,!>=2,0}
  tok always !0
  != always {!<=-1,!>=2}
  '(' always 40
Line 936
  tok always !0
Line 939
  ! {!<=-1,!>=2,1}
  tok possible 0
Line 950
  & {lifetime[Address]=(tok),!0}
Line 953
  != always {!<=-1,!>=2}
  '(' always 40
Line 956
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  ')' always 41
Line 959
  = always !0
  . always !0
Line 960
  tok always !0
Line 961
  tok always !0
Line 965
  ( always {!<=-1,!>=2}
Line 967
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  tok always !0
  ( always !<=-1
  != always {!<=-1,!>=2}
  1U always 1
Line 968
  return always {!<=-1,!>=2}
  false always 0
Line 969
  c possible 102
  tok always !0
  ( always size=1
  0 always 0
Line 970
  return always {!<=-1,!>=2}
  c possible 108
  == {!<=-1,!>=2,0}
  'f' always 102
  || always {!<=-1,!>=2}
  c always !102
  == always {!<=-1,!>=2}
  'l' always 108
Line 976
  executableScope always size=0
  false always 0
Line 978
  . possible {125,46}
  == {!<=-1,!>=2,0}
  '{' always 123
Line 979
  ( always {!<=-1,!>=2}
Line 980
  true always 1
Line 984
  prev possible {symbolic=(tok->previous),0}
  && {!<=-1,!>=2,0}
  prev {symbolic=(tok->previous),!0}
  ";{}()" always ";{}()"
Line 985
  prev always !0
Line 986
  prev possible {symbolic=(tok->previous),0}
  && {!<=-1,!>=2,0}
  prev always !0
  == always {!<=-1,!>=2}
  ')' always 41
Line 989
  . {46,!123}
  == {!<=-1,!>=2,0}
  '}' always 125
Line 990
  ( always !<=-1
  > always {!<=-1,!>=2}
  1 always 1
Line 991
  executableScope {>=size=2,!<=size=1}
Line 995
  . always {!123,!125}
  == always {!<=-1,!>=2}
  '.' always 46
Line 997
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  '.' always 46
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  1 always 1
  && always {!<=-1,!>=2}
Line 998
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  '.' always 46
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  2 always 2
Line 999
  "..." always "..."
Line 1005
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  "._" always "._"
  == always {!<=-1,!>=2}
Line 1006
  '.' always 46
Line 1008
  ( always {!<=-1,!>=2}
  . possible 0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  "AaBbCcDdEeFfPp" always "AaBbCcDdEeFfPp"
Line 1013
  && always {!<=-1,!>=2}
Line 1019
  lastChar possible {69,101,80,112}
  1 always 1
Line 1020
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 1021
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  'E' always 69
  || always {!<=-1,!>=2}
  lastChar always !69
  == always {!<=-1,!>=2}
  'e' always 101
  || always {!<=-1,!>=2}
Line 1022
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  'P' always 80
  || always {!<=-1,!>=2}
  lastChar always !80
  == always {!<=-1,!>=2}
  'p' always 112
  && always {!<=-1,!>=2}
Line 1023
  && always {!<=-1,!>=2}
  "+-" always "+-"
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 1029
  == always {!<=-1,!>=2}
  '\0' always 0
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  '\0' always 0
Line 1031
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  . always !0
Line 1033
  1U always 1
  != always {!<=-1,!>=2}
  . always !0
Line 1036
  . possible {symbolic=(tok->op),58,62}
  == {!<=-1,!>=2,0}
  '=' always 61
  && {!<=-1,!>=2,0}
  "=!<>+-*/%&|^" always "=!<>+-*/%&|^"
Line 1037
  == always {!<=-1,!>=2}
  '&' always 38
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1040
  = always 0
  0 always 0
Line 1042
  indentlevel possible 0
  >= {!<=-1,!>=2,1}
  0 always 0
  && always {!<=-1,!>=2}
  start possible symbolic=(tok)
Line 1043
  start {symbolic=(tok),!0}
  . possible 40
  == {!<=-1,!>=2,0}
  ')' always 41
Line 1044
  ++ always !<=0
  indentlevel always !<=-1
Line 1045
  start always !0
  . always !41
  == always {!<=-1,!>=2}
  '(' always 40
Line 1046
  -- always !<=-2
  indentlevel always !<=-1
Line 1047
  start always !0
  ";{}" always ";{}"
Line 1049
  start always !0
Line 1051
  indentlevel possible {>=0,<=-1}
  == {!<=-1,!>=2,>=0,<=1}
  -1 always -1
  && {!<=-1,!>=2,0}
Line 1052
  = always !0
  start always !0
Line 1053
  isFuncDecl always {!<=-1,!>=2}
  isFuncDecl always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ftok {symbolic=(start),!0}
Line 1054
  isFuncDecl {symbolic=(ftok->name),!<=-1,!>=2}
Line 1055
  ! always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  "::" always "::"
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  '*' always 42
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  '&' always 38
Line 1056
  isFuncDecl always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1057
  ! always {!<=-1,!>=2}
Line 1059
  . always !0
  ";{}:" always ";{}:"
Line 1063
  isFuncDecl always {!<=-1,!>=2}
  &= always {!<=-1,!>=2}
  start possible symbolic=(ftok)
  != {!<=-1,!>=2,0}
  ftok possible symbolic=(start)
  && {!<=-1,!>=2,0}
  start always !symbolic=(ftok)
Line 1064
  isFuncDecl always {!<=-1,!>=2}
Line 1070
  "=" always "="
Line 1072
  . possible {symbolic=(tok->next->op),38,58,45,60,62,43}
  == {!<=-1,!>=2,0}
  '|' always 124
  || {!<=-1,!>=2,0}
  . possible {58,45,60,62,43}
  == {!<=-1,!>=2,0}
  '&' always 38
  && {!<=-1,!>=2,0}
  == always {!<=-1,!>=2}
Line 1075
  . possible {symbolic=(tok->next->op),45,60,62,43}
  == {!<=-1,!>=2,0}
  ':' always 58
  && {!<=-1,!>=2,0}
  == always {!<=-1,!>=2}
  ':' always 58
Line 1078
  . possible {symbolic=(tok->next->op),60,62,43,45}
  == {!<=-1,!>=2,0,1}
  '-' always 45
  && {!<=-1,!>=2,0}
  == always {!<=-1,!>=2}
  '>' always 62
Line 1081
  . possible {symbolic=(tok->next->op),62,43,45}
  == {!<=-1,!>=2,0}
  '<' always 60
  || {!<=-1,!>=2,0}
  . possible {43,45}
  == {!<=-1,!>=2,0}
  '>' always 62
  && {!<=-1,!>=2,0}
  == always {!<=-1,!>=2}
Line 1083
  . possible 0
Line 1084
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  '=' always 61
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  '=' always 61
Line 1088
  . possible 45
  == {!<=-1,!>=2,0}
  '+' always 43
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  '-' always 45
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 1089
  1U always 1
  != always {!<=-1,!>=2}
Line 1091
  && always {!<=-1,!>=2}
Line 1093
  && always {!<=-1,!>=2}
Line 1101
  "compl" always "compl"
Line 1102
  "not" always "not"
Line 1105
  && always {!<=-1,!>=2}
  tok always !0
  != always {!<=-1,!>=2}
  ')' always 41
Line 1107
  ( always {!<=-1,!>=2}
Line 1108
  = always 33
  '!' always 33
Line 1110
  ( always {!<=-1,!>=2}
Line 1111
  = always 126
  '~' always 126
Line 1113
  . possible {33,126}
  == {!<=-1,!>=2,1,0}
  '!' always 33
  && {!<=-1,!>=2,0}
  && {!<=-1,!>=2,0}
  . always !0
  . always {!<=-1,!>=2}
  number always {!<=-1,!>=2}
Line 1114
  == always {!<=-1,!>=2}
  "0" always "0"
  "1" always "1"
  : always "0"
  "0" always "0"
Line 1116
  . possible 126
  == {!<=-1,!>=2,1}
  '~' always 126
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  . always !0
  . always {!<=-1,!>=2}
  number always {!<=-1,!>=2}
Line 1120
  && always {!<=-1,!>=2}
  . always !0
  . always {!<=-1,!>=2}
  number always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  . always !0
  . always {!<=-1,!>=2}
  name always {!<=-1,!>=2}
Line 1122
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  . always !0
  . always {!<=-1,!>=2}
  number always {!<=-1,!>=2}
Line 1125
  '+' always 43
Line 1129
  '-' always 45
Line 1140
  && always {!<=-1,!>=2}
  tok always !0
  != always {!<=-1,!>=2}
  ')' always 41
Line 1141
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  . always !0
  . always {!<=-1,!>=2}
  number always {!<=-1,!>=2}
Line 1143
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  . always !0
  . always {!<=-1,!>=2}
  number always {!<=-1,!>=2}
Line 1147
  . possible {47,37}
  == {!<=-1,!>=2,0}
  '*' always 42
Line 1148
  . always !0
  . always !0
Line 1149
  . {37,47,!42}
  == {!<=-1,!>=2,0,1}
  '/' always 47
  || {!<=-1,!>=2,1}
  . always {!42,!47}
  == always {!<=-1,!>=2}
  '%' always 37
Line 1150
  rhs possible {0,-1}
  . always !0
Line 1151
  rhs {symbolic=(stringToLL(tok->next->str())),0,-1}
  == {!<=-1,!>=2,1,0}
  0 always 0
Line 1152
  "division/modulo by zero" always "division/modulo by zero"
Line 1154
  rhs {symbolic=(stringToLL(tok->next->str())),-1,!0}
  == {!<=-1,!>=2,1}
  -1 always -1
  && always {!<=-1,!>=2}
  lhs always symbolic=(stringToLL(tok->previous->str()))
  == always {!<=-1,!>=2}
Line 1155
  "division overflow" always "division overflow"
Line 1156
  == always {!<=-1,!>=2}
  '/' always 47
Line 1157
  lhs always symbolic=(stringToLL(tok->previous->str()))
  rhs always !0
Line 1159
  lhs always symbolic=(stringToLL(tok->previous->str()))
  rhs always !0
Line 1163
  = always !0
  . always !0
Line 1164
  tok always !0
  result possible {symbolic=(lhs/rhs),symbolic=(lhs%rhs)}
Line 1165
  tok always !0
Line 1166
  tok always !0
Line 1172
  && always {!<=-1,!>=2}
  tok always !0
  != always {!<=-1,!>=2}
  ')' always 41
Line 1173
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  . always !0
  . always {!<=-1,!>=2}
  number always {!<=-1,!>=2}
Line 1175
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  . always !0
  . always {!<=-1,!>=2}
  number always {!<=-1,!>=2}
Line 1179
  . possible 45
  == {!<=-1,!>=2,0}
  '+' always 43
Line 1180
  . always !0
  . always !0
Line 1181
  . always !43
  == always {!<=-1,!>=2}
  '-' always 45
Line 1182
  . always !0
  . always !0
Line 1186
  = always !0
  . always !0
Line 1187
  tok always !0
Line 1188
  tok always !0
Line 1189
  tok always !0
Line 1195
  && always {!<=-1,!>=2}
  tok always !0
  != always {!<=-1,!>=2}
  ')' always 41
Line 1196
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  . always !0
  . always {!<=-1,!>=2}
  number always {!<=-1,!>=2}
Line 1198
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  . always !0
  . always {!<=-1,!>=2}
  number always {!<=-1,!>=2}
Line 1202
  ( possible size=2
  == always {!<=-1,!>=2}
  "<<" always "<<"
Line 1203
  . always !0
  . always !0
Line 1204
  == always {!<=-1,!>=2}
  ">>" always ">>"
Line 1205
  . always !0
  . always !0
Line 1209
  = always !0
  . always !0
Line 1210
  tok always !0
Line 1211
  tok always !0
Line 1212
  tok always !0
Line 1216
  "not_eq" always "not_eq"
Line 1219
  && always {!<=-1,!>=2}
  tok always !0
  != always {!<=-1,!>=2}
  ')' always 41
Line 1220
  ( always {!<=-1,!>=2}
Line 1221
  "!=" always "!="
Line 1223
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "<>=!" always "<>=!"
Line 1225
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  . always !0
  . always {!<=-1,!>=2}
  number always {!<=-1,!>=2}
Line 1227
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  . always !0
  . always {!<=-1,!>=2}
  number always {!<=-1,!>=2}
Line 1231
  ( possible {size=2,size=1}
  == {!<=-1,!>=2,0}
  "==" always "=="
Line 1232
  = always {!<=-1,!>=2}
  . always !0
  == always {!<=-1,!>=2}
  . always !0
Line 1233
  ( possible {size=1,size=2}
  == {!<=-1,!>=2,0}
  "!=" always "!="
Line 1234
  = always {!<=-1,!>=2}
  . always !0
  != always {!<=-1,!>=2}
  . always !0
Line 1235
  ( possible {size=2,size=1}
  == {!<=-1,!>=2,0}
  ">" always ">"
Line 1236
  = always {!<=-1,!>=2}
  . always !0
  > always {!<=-1,!>=2}
  . always !0
Line 1237
  ( possible {size=1,size=2}
  == {!<=-1,!>=2,0}
  ">=" always ">="
Line 1238
  = always {!<=-1,!>=2}
  . always !0
  >= always {!<=-1,!>=2}
  . always !0
Line 1239
  ( possible size=2
  == {!<=-1,!>=2,0}
  "<" always "<"
Line 1240
  = always {!<=-1,!>=2}
  . always !0
  < always {!<=-1,!>=2}
  . always !0
Line 1241
  == always {!<=-1,!>=2}
  "<=" always "<="
Line 1242
  = always {!<=-1,!>=2}
  . always !0
  <= always {!<=-1,!>=2}
  . always !0
Line 1246
  = always !0
  . always !0
Line 1247
  tok always !0
Line 1248
  tok always !0
Line 1249
  tok always !0
Line 1253
  "bitand" always "bitand"
Line 1254
  "bitor" always "bitor"
Line 1255
  "xor" always "xor"
Line 1259
  = always "&^|"
  "&^|" always "&^|"
  * possible {38,124}
  op possible "&^|"
Line 1261
  * possible 124
  == {!<=-1,!>=2,0}
  '&' always 38
Line 1262
  = {&,lifetime[Address]=(BITAND),!0}
  & {&,lifetime[Address]=(BITAND),!0}
Line 1263
  * always !38
  == always {!<=-1,!>=2}
  '|' always 124
Line 1264
  = {&,lifetime[Address]=(BITOR),!0}
  & {&,lifetime[Address]=(BITOR),!0}
Line 1266
  = {&,lifetime[Address]=(XOR),!0}
  & {&,lifetime[Address]=(XOR),!0}
Line 1267
  && always {!<=-1,!>=2}
  tok always !0
  != always {!<=-1,!>=2}
  ')' always 41
Line 1268
  != always {!<=-1,!>=2}
  * possible {38,94}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  alternativeOp possible {lifetime[Address]=(BITAND),lifetime[Address]=(BITOR),lifetime[Address]=(XOR)}
Line 1270
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  . always !0
  . always {!<=-1,!>=2}
  number always {!<=-1,!>=2}
Line 1272
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  . always !0
  . always {!<=-1,!>=2}
  number always {!<=-1,!>=2}
Line 1275
  * possible 94
  == {!<=-1,!>=2,0}
  '&' always 38
Line 1276
  . always !0
  . always !0
Line 1277
  * always !38
  == always {!<=-1,!>=2}
  '^' always 94
Line 1278
  . always !0
  . always !0
Line 1280
  . always !0
  . always !0
Line 1281
  = always !0
  . always !0
Line 1282
  tok always !0
Line 1283
  tok always !0
Line 1284
  tok always !0
Line 1289
  "and" always "and"
Line 1290
  "or" always "or"
Line 1293
  && always {!<=-1,!>=2}
  tok always !0
  != always {!<=-1,!>=2}
  ')' always 41
Line 1294
  . always {!<=-1,!>=2}
  name always {!<=-1,!>=2}
Line 1295
  ( always {!<=-1,!>=2}
Line 1296
  "&&" always "&&"
Line 1297
  ( always {!<=-1,!>=2}
Line 1298
  "||" always "||"
Line 1300
  ( possible size=2
  != always {!<=-1,!>=2}
  "&&" always "&&"
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  "||" always "||"
Line 1302
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  . always !0
  . always {!<=-1,!>=2}
  number always {!<=-1,!>=2}
Line 1304
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  . always !0
  . always {!<=-1,!>=2}
  number always {!<=-1,!>=2}
Line 1308
  == always {!<=-1,!>=2}
  "||" always "||"
Line 1309
  = always {!<=-1,!>=2}
  . always !0
  || always {!<=-1,!>=2}
  . always !0
Line 1311
  = always {!<=-1,!>=2}
  . always !0
  && always {!<=-1,!>=2}
  . always !0
Line 1313
  = always !0
  . always !0
Line 1314
  tok always !0
Line 1315
  tok always !0
Line 1316
  tok always !0
Line 1322
  gotoTok1 always {!<=-1,!>=2}
  gotoTok1 always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1323
  && always {!<=-1,!>=2}
  tok always !0
  != always {!<=-1,!>=2}
  ')' always 41
  gotoTok1 {!<=-1,!>=2,1}
Line 1324
  gotoTok1 always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1325
  != always {!<=-1,!>=2}
  "?" always "?"
Line 1327
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 1328
  "invalid expression" always "invalid expression"
Line 1329
  ! always {!<=-1,!>=2}
  . always !0
Line 1331
  . always !0
  . always !0
  != always {!<=-1,!>=2}
  ':' always 58
Line 1335
  trueTok always symbolic=(tok->next)
Line 1336
  ! always {!<=-1,!>=2}
  falseTok always symbolic=(trueTok->next->next)
Line 1337
  "invalid expression" always "invalid expression"
Line 1338
  condTok always symbolic=(tok->previous)
  == always {!<=-1,!>=2}
Line 1339
  condTok always {symbolic=(tok->previous),symbolic=(*tok1)}
  != always {!<=-1,!>=2}
  "0" always "0"
  trueTok always symbolic=(tok->next)
  : always {1,symbolic=(tok->next),symbolic=(trueTok->next->next)}
  falseTok {symbolic=(trueTok->next->next),!0}
Line 1340
  condTok always symbolic=(tok->previous)
Line 1341
  trueTok always symbolic=(tok->next)
Line 1342
  condTok always symbolic=(tok->previous)
  == always {!<=-1,!>=2}
  "0" always "0"
Line 1343
  condTok always symbolic=(tok->previous)
Line 1344
  gotoTok1 always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1351
  tok possible symbolic=(frontToken)
Line 1352
  = {symbolic=(frontToken),!0}
  tok {symbolic=(frontToken),!0}
Line 1353
  tok {symbolic=(frontToken),symbolic=(tok1),!0}
Line 1354
  tok1 {symbolic=(frontToken),!0}
Line 1355
  tok1 always !0
Line 1362
  start possible 60@103
Line 1364
  backslash always {!<=-1,!>=2}
  backslash always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1365
  = always 0
  0 always 0
Line 1366
  ch possible {symbolic=(next),symbolic=(end),0,62@103}
  != {!<=-1,!>=2,0}
  end possible {symbolic=(ch),62@103}
  && {!<=-1,!>=2,0}
  ch {!symbolic=(end),0}
  != {!<=-1,!>=2,1}
  '\r' always 13
  && {!<=-1,!>=2,0}
  ch {!symbolic=(end),0,!13}
  != {!<=-1,!>=2,1}
  '\n' always 10
  && {!<=-1,!>=2,0}
  ( always {!<=-1,!>=2}
Line 1367
  = always !<=-1
  ( always !<=-1
Line 1368
  backslash always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  '\n' always 10
Line 1369
  = always 0
  0 always 0
Line 1370
  backslash always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1373
  backslash always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1374
  ch possible 92
Line 1375
  == always {!<=-1,!>=2}
  '\\' always 92
Line 1376
  update_ch always {!<=-1,!>=2}
  update_ch always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1377
  = always 0
  0 always 0
Line 1379
  = always !<=-1
  ( always !<=-1
Line 1380
  next possible {10,92}
  == {!<=-1,!>=2,0}
  '\r' always 13
  || always {!<=-1,!>=2}
  next {92,!13}
  == {!<=-1,!>=2,0}
  '\n' always 10
Line 1381
  ( always !<=-1
  - always !<=-1
  1U always 1
Line 1382
  backslash always {!<=-1,!>=2}
  = {!<=-1,!>=2,1,0}
  next possible {13,10}
  == {!<=-1,!>=2,1,0}
  '\r' always 13
Line 1383
  update_ch always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1384
  next always {!13,!10}
  == always {!<=-1,!>=2}
  '\\' always 92
Line 1385
  update_ch always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  update_ch always {!<=-1,!>=2}
Line 1386
  next possible {13,10,92}
Line 1387
  next possible 92
  == {!<=-1,!>=2,1}
  '\\' always 92
Line 1388
  update_ch always {!<=-1,!>=2}
Line 1393
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  end possible 62@103
Line 1397
  = always 4
  :: always 4
  SYNTAX_ERROR always 4
Line 1399
  "No pair for character (" always "No pair for character ("
  "). Can't process file. File is either invalid or unicode, which is currently not supported." always "). Can't process file. File is either invalid or unicode, which is currently not supported."
Line 1400
  outputList always !0
Line 1402
  "" always ""
Line 1411
  = always 0
  0 always 0
Line 1413
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1418
  > always {!<=-1,!>=2}
Line 1419
  "" always ""
Line 1420
  ! {!<=-1,!>=2,0}
  ret possible size=0
  ( {!<=-1,!>=2,1}
Line 1421
  ' ' always 32
Line 1423
  0 always 0
  == always {!<=-1,!>=2}
  '\"' always 34
Line 1424
  "%rts%" always "%rts%"
Line 1426
  "%mun%" always "%mun%"
Line 1429
  ( {lifetime[Iterator]=(ret),end=0}
  ( {lifetime[Iterator]=(ret),end=0}
Line 1432
  ( {lifetime[Iterator]=(ret),start=0}
  ( {lifetime[Iterator]=(ret),end=0}
Line 1438
  = always 0
  nullptr always 0
Line 1439
  = always 0
  0 always 0
Line 1441
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1445
  > always {!<=-1,!>=2}
Line 1446
  nullptr always 0
Line 1452
  ( always {!<=-1,!>=2}
Line 1455
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  prevTok always !0
  == always {!<=-1,!>=2}
  '#' always 35
Line 1458
  ( always !<=-1
Line 1460
  i always !<=-1
  = always 0
  0 always 0
  i {!<=-1,0}
  < always {!<=-1,!>=2}
  ( {!<=-1,>=symbolic=(i+1),<=symbolic=(i)}
  ++ always !<=0
  i always !<=-1
Line 1461
  i {!<=-1,<=symbolic=(files.size()-1),!>=symbolic=(files.size())}
  == always {!<=-1,!>=2}
Line 1462
  return always !<=-1
  i always {!<=-1,!>=symbolic=(files.size())}
Line 1465
  return always !<=-1
  files always !size=0
  ( always !<=0
  - always !<=-1
  1U always 1
Line 1475
  nullptr always 0
  nullptr always 0
  nullptr always 0
  variadic always {!<=-1,!>=2}
  false always 0
  variadicOpt always {!<=-1,!>=2}
  false always 0
  nullptr always 0
  nullptr always 0
  valueDefinedInCode_ always {!<=-1,!>=2}
  false always 0
Line 1477
  nullptr always 0
  valueDefinedInCode_ always {!<=-1,!>=2}
  true always 1
Line 1478
  ( always {!<=-1,!>=2}
Line 1479
  "bad macro syntax" always "bad macro syntax"
Line 1480
  != always {!<=-1,!>=2}
  '#' always 35
Line 1481
  "bad macro syntax" always "bad macro syntax"
Line 1483
  tok always symbolic=(hashtok)
Line 1484
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  tok always !0
  != always {!<=-1,!>=2}
Line 1485
  "bad macro syntax" always "bad macro syntax"
Line 1486
  tok always !0
Line 1487
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  tok always !0
  . always {!<=-1,!>=2}
  name always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
Line 1488
  "bad macro syntax" always "bad macro syntax"
Line 1489
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
Line 1490
  "bad macro syntax" always "bad macro syntax"
Line 1493
  nullptr always 0
  valueDefinedInCode_ always {!<=-1,!>=2}
  false always 0
Line 1494
  name possible {"__STRICT_ANSI__"@10,"__FILE__"@11,"__LINE__"@12,"__COUNTER__"@13,"__DATE__"@15,"__TIME__"@17,"__STDC_VERSION__"@21,"__cplusplus"@25}
  ' ' always 32
  value possible {"1"@10,"__FILE__"@11,"__LINE__"@12,"__COUNTER__"@13}
Line 1495
  ( {lifetime[Object]=(def),!0}
  ( {lifetime[Object]=(def),!0}
  ( always !<=-1
Line 1497
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1498
  "bad macro syntax. macroname=" always "bad macro syntax. macroname="
  " value=" always " value="
Line 1501
  nullptr always 0
  valueDefinedInCode_ always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  valueDefinedInCode_ always {!<=-1,!>=2}
Line 1502
  this always !0
Line 1511
  this always !0
  != always {!<=-1,!>=2}
  & {lifetime[Address]=(other),!0}
Line 1513
  valueDefinedInCode_ always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  valueDefinedInCode_ always {!<=-1,!>=2}
Line 1514
  ( always {!<=-1,!>=2}
Line 1518
  ( always {!<=-1,!>=2}
Line 1522
  this always !0
Line 1525
  ( always {!<=-1,!>=2}
Line 1526
  return always {!<=-1,!>=2}
  valueDefinedInCode_ always {!<=-1,!>=2}
Line 1550
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  . always !0
  == always {!<=-1,!>=2}
  '(' always 40
Line 1554
  rawtok always symbolic=(rawtok1)
  rawtok1 always symbolic=(rawtok)
  rawtok always symbolic=(rawtok1)
  . always {!<=-1,!>=2}
  whitespaceahead always {!<=-1,!>=2}
Line 1555
  = always !0
  rawtok always symbolic=(rawtok1)
  . always !0
Line 1556
  rawtok always !0
  rawtok always !0
  . always {!<=-1,!>=2}
  whitespaceahead always {!<=-1,!>=2}
Line 1557
  rawtok always !0
Line 1558
  = always 1
  1 always 1
Line 1559
  && always {!<=-1,!>=2}
  par possible 1
  > {!<=-1,!>=2,1}
  0 always 0
Line 1560
  rawtok always !0
  . possible {41,35}
  == {!<=-1,!>=2,0}
  '(' always 40
Line 1561
  ++ always !<=1
  par always !<=0
Line 1562
  rawtok always !0
  . {35,!40}
  == {!<=-1,!>=2,0}
  ')' always 41
Line 1563
  -- always !<=-1
  par always !<=0
Line 1564
  rawtok always !0
  . always {!40,!41}
  == always {!<=-1,!>=2}
  '#' always 35
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  rawtok always !0
  rawtok always !0
Line 1565
  "it is invalid to use a preprocessor directive as macro parameter" always "it is invalid to use a preprocessor directive as macro parameter"
Line 1566
  . always {!<=-1,!>=2}
  whitespaceahead always {!<=-1,!>=2}
Line 1569
  & {lifetime[Address]=(output2),!0}
  expandedmacros always size=0
Line 1572
  & {lifetime[Address]=(output2),!0}
  expandedmacros always size=0
Line 1574
  && always {!<=-1,!>=2}
  rawtok possible symbolic=(rawtok2->next)
Line 1575
  par always !<=-1
  par always !<=-1
  = always 0
  0 always 0
Line 1578
  macro2tok always !0
  . possible 41
  == {!<=-1,!>=2,0}
  '(' always 40
Line 1579
  par always !<=-1
  == always {!<=-1,!>=2}
  0 always 0
Line 1581
  -- always {!<=-1,!>=4294967296}
  par always !<=0
Line 1582
  macro2tok always !0
  . always !40
  == always {!<=-1,!>=2}
  ')' always 41
Line 1583
  ++ always !<=0
  par always !<=-1
Line 1584
  macro2tok always !0
Line 1586
  macro2tok possible 0
Line 1587
  macro2tok always !0
Line 1589
  rawtok always !0
  == always {!<=-1,!>=2}
  '(' always 40
Line 1591
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  macro2tok always !0
  . always {!<=-1,!>=2}
  name always {!<=-1,!>=2}
Line 1593
  != always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  macro2tok always !0
  == always {!<=-1,!>=2}
  this always !0
Line 1595
  macro possible {symbolic=(macros.end()),end=0}
  = possible lifetime[Iterator]=(macros)
  ( possible lifetime[Iterator]=(macros)
  macro2tok always !0
Line 1596
  macro {lifetime[Iterator]=(macros),symbolic=(macros.find(macro2tok->str()))}
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(macros),end=0}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  macro {lifetime[Iterator]=(macros),symbolic=(macros.find(macro2tok->str())),!symbolic=(macros.end()),!end=0}
Line 1600
  macro2tok possible symbolic=(next)
Line 1601
  next possible symbolic=(macro2tok)
  macro2tok {symbolic=(next),!0}
Line 1602
  macro2tok always !0
Line 1603
  macro2tok always !0
Line 1606
  par always !<=-1
  = always !<=-1
  != always {!<=-1,!>=2}
  ? always !<=-1
  1U always 1
  : always 0
  0U always 0
Line 1608
  rawtok2 possible symbolic=(rawtok)
Line 1609
  rawtok2 possible symbolic=(rawtok)
Line 1610
  rawtok2 possible symbolic=(rawtok)
  . possible 41
  == {!<=-1,!>=2,0}
  '(' always 40
Line 1611
  ++ always !<=0
  par always !<=-1
Line 1612
  . always !40
  == always {!<=-1,!>=2}
  ')' always 41
Line 1613
  par always !<=-1
  <= always {!<=-1,!>=2}
  1U always 1
Line 1615
  -- {!>=4294967296,!<=0,>=1}
  par {!<=1,>=2}
Line 1618
  ! always {!<=-1,!>=2}
  rawtok2 possible symbolic=(rawtok)
  || always {!<=-1,!>=2}
  par always !<=-1
  != always {!<=-1,!>=2}
  1U always 1
Line 1620
  & {lifetime[Address]=(output2),!0}
  != always {!<=-1,!>=2}
  nullptr always 0
Line 1622
  rawtok2 always !0
Line 1625
  rawtok possible {symbolic=(rawtok2->next),0}
Line 1644
  ( always {!<=-1,!>=2}
Line 1645
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 1646
  . always !0
  == always {!<=-1,!>=2}
  '(' always 40
  && always {!<=-1,!>=2}
Line 1647
  && always {!<=-1,!>=2}
Line 1648
  . always !<=-1
  col always !<=-1
  == always {!<=-1,!>=2}
  . always !<=-1
  col always !<=-1
  + always !<=-1
  ( always !<=-1
Line 1660
  "Wrong number of parameters for macro \'" always "Wrong number of parameters for macro \'"
  "\'." always "\'."
Line 1666
  "Invalid ## usage when expanding \'" always "Invalid ## usage when expanding \'"
  "\': " always "\': "
Line 1673
  "Unexpected token '" always "Unexpected token '"
  tokenA possible symbolic=(tok->next->next)@36
  "'" always "'"
Line 1677
  "Combining '" always "Combining '"
  "' and '" always "' and '"
  tokenB possible symbolic=(tok->next->next)@38
  "' yields an invalid token." always "' yields an invalid token."
Line 1681
  "Unexpected newline" always "Unexpected newline"
Line 1685
  "Combining '\\" always "Combining '\\"
  "' and '" always "' and '"
  strAB possible {size=5@66,size=9@68}
  ( always !<=-1
  "' yields universal character '\\" always "' yields universal character '\\"
  strAB possible {size=5@66,size=9@68}
  "'. This is undefined behavior according to C standard chapter 5.1.1.2, paragraph 4." always "'. This is undefined behavior according to C standard chapter 5.1.1.2, paragraph 4."
Line 1690
  , always {!<=-1,!>=2}
  replaced always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 1691
  str possible {"1"@168,"0"@168,""@244,"##"@254}
Line 1692
  replaced {!<=-1,!>=2,1@119}
Line 1693
  tok always size=0
Line 1694
  expandedFromToken possible 0
Line 1695
  tok always size=0
  expandedFromToken always !0
  this always !0
Line 1696
  tok always size=0
Line 1699
  ( always {!<=-1,!>=2}
Line 1701
  variadic always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1702
  variadicOpt always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1703
  = always 0
  nullptr always 0
Line 1704
  = always 0
  nullptr always 0
Line 1705
  ! always {!<=-1,!>=2}
Line 1706
  = always 0
  = always 0
  nullptr always 0
Line 1708
  return always {!<=-1,!>=2}
  false always 0
Line 1712
  ( always {!<=-1,!>=2}
Line 1714
  nameTokDef always !0
Line 1715
  ( always {!<=-1,!>=2}
  argtok possible symbolic=(nameTokDef->next->next)
  && always {!<=-1,!>=2}
  argtok possible symbolic=(nameTokDef->next->next)
  != always {!<=-1,!>=2}
  ')' always 41
Line 1716
  == always {!<=-1,!>=2}
  "..." always "..."
  && always {!<=-1,!>=2}
Line 1717
  && always {!<=-1,!>=2}
  . always !0
  == always {!<=-1,!>=2}
  ')' always 41
Line 1718
  variadic always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1719
  ! always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  name always {!<=-1,!>=2}
Line 1720
  "__VA_ARGS__" always "__VA_ARGS__"
Line 1721
  = always !0
  . always !0
Line 1724
  . always !41
  != always {!<=-1,!>=2}
  ',' always 44
Line 1728
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  argtok possible symbolic=(nameTokDef->next->next)
Line 1729
  = possible 0
  ? possible 0
  argtok always !0
  : possible 0
  argtok possible 0
Line 1730
  = always 0
  nullptr always 0
Line 1731
  return always {!<=-1,!>=2}
  false always 0
Line 1733
  = possible 0
  ? possible 0
  argtok always !0
  : always 0
  nullptr always 0
Line 1736
  nameTokDef always !0
Line 1739
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  valueToken possible 0
  nameTokDef always !0
Line 1740
  = always 0
  nullptr always 0
Line 1741
  = possible 0
  valueToken possible 0
Line 1742
  ( always {!<=-1,!>=2}
  endToken possible 0
  nameTokDef always !0
Line 1743
  variadic always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "__VA_OPT__" always "__VA_OPT__"
Line 1744
  variadicOpt always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1748
  variadicOpt always {!<=-1,!>=2}
Line 1751
  && always {!<=-1,!>=2}
  tok always !0
  != always {!<=-1,!>=2}
Line 1752
  == always {!<=-1,!>=2}
  "__VA_OPT__" always "__VA_OPT__"
Line 1753
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  '(' always 40
Line 1754
  "In definition of '" always "In definition of '"
  nameTokDef always !0
  "': Missing opening parenthesis for __VA_OPT__" always "': Missing opening parenthesis for __VA_OPT__"
Line 1756
  = always 1
  1 always 1
Line 1757
  && always {!<=-1,!>=2}
  tok always !0
  != always {!<=-1,!>=2}
Line 1758
  tok always {!symbolic=(endToken),!0}
  . possible 41
  == {!<=-1,!>=2,0}
  '(' always 40
Line 1760
  tok always {!symbolic=(endToken),!0}
  . always !40
  == always {!<=-1,!>=2}
  ')' always 41
Line 1762
  tok always {!symbolic=(endToken),!0}
  == always {!<=-1,!>=2}
  "__VA_OPT__" always "__VA_OPT__"
Line 1763
  tok always {!symbolic=(endToken),!0}
  "In definition of '" always "In definition of '"
  nameTokDef always !0
  "': __VA_OPT__ cannot be nested" always "': __VA_OPT__ cannot be nested"
Line 1764
  == always {!<=-1,!>=2}
  0 always 0
Line 1765
  tok always !0
Line 1768
  tok always !0
Line 1769
  tok always !0
Line 1771
  != always {!<=-1,!>=2}
  0 always 0
Line 1773
  "In definition of '" always "In definition of '"
  "': Missing closing parenthesis for __VA_OPT__" always "': Missing closing parenthesis for __VA_OPT__"
Line 1785
  return always {!<=-1,!>=2}
  true always 1
Line 1788
  ( always !<=-1
Line 1789
  par always !<=-1
  par always !<=-1
  = always 0
  0 always 0
Line 1790
  par {!<=-1,0}
  < always {!<=-1,!>=2}
  ( always !<=-1
Line 1791
  == always {!<=-1,!>=2}
  par {!<=-1,<=symbolic=(args.size()-1),!>=symbolic=(args.size())}
Line 1792
  return always !<=-1
  par always {!<=-1,!>=symbolic=(args.size())}
Line 1793
  par always {!<=-1,!>=symbolic=(args.size())}
  ++ always {!<=-1,!>=symbolic=(args.size())}
Line 1795
  return always !<=-1
  ~ always 4294967295
  0U always 0
Line 1798
  calledInDefine always {!<=-1,!>=2}
Line 1799
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  . always !0
  != always {!<=-1,!>=2}
  '(' always 40
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1800
  ( always size=0
Line 1803
  parametertokens always size=0
Line 1804
  par always !<=-1
  par always !<=-1
  = always 0
  0U always 0
Line 1805
  calledInDefine {!<=-1,!>=2,0}
  ? always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  : always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  nullptr always 0
Line 1806
  . possible {41,44}
  == {!<=-1,!>=2,0}
  '(' always 40
Line 1807
  ++ always !<=0
  par always !<=-1
Line 1808
  . {44,!40}
  == {!<=-1,!>=2,0}
  ')' always 41
Line 1809
  par always !<=-1
  == always {!<=-1,!>=2}
  0U always 0
Line 1813
  -- always {!<=-1,!>=4294967296}
  par always !<=0
Line 1814
  par always !<=-1
  == always {!<=-1,!>=2}
  0U always 0
  && always {!<=-1,!>=2}
  . always {!40,!41}
  == always {!<=-1,!>=2}
  ',' always 44
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  variadic always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always !<=-1
  < always {!<=-1,!>=2}
  ( always !<=-1
Line 1826
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  lpar always !0
  != always {!<=-1,!>=2}
  '(' always 40
Line 1827
  nullptr always 0
Line 1828
  par always !<=-1
  par always !<=-1
  = always 0
  0 always 0
Line 1829
  = always !0
  lpar always !0
Line 1830
  ( always {!<=-1,!>=2}
  lpar {symbolic=(tok),!0}
  tok inconclusive symbolic=(lpar)
Line 1831
  tok inconclusive symbolic=(lpar)
  . possible {35,40,41}
  == {!<=-1,!>=2,1,0}
  '#' always 35
  && {!<=-1,!>=2,0}
  tok inconclusive symbolic=(lpar)
  tok inconclusive symbolic=(lpar)
  && {!<=-1,!>=2,0}
  tok inconclusive symbolic=(lpar)
  == always {!<=-1,!>=2}
  '#' always 35
  && {!<=-1,!>=2,0}
  ( always {!<=-1,!>=2}
  tok inconclusive symbolic=(lpar)
  tok inconclusive symbolic=(lpar)
Line 1833
  false always 0
Line 1834
  . possible {40,41}
  == {!<=-1,!>=2,0}
  '#' always 35
  && {!<=-1,!>=2,0}
  && {!<=-1,!>=2,0}
  != always {!<=-1,!>=2}
  '#' always 35
Line 1837
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1839
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  par always !<=-1
  > always {!<=-1,!>=2}
  0 always 0
  || always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  "(" always "("
Line 1843
  . possible 41
  == {!<=-1,!>=2,0}
  '(' always 40
Line 1844
  ++ always !<=0
  par always !<=-1
Line 1845
  . always !40
  == always {!<=-1,!>=2}
  ')' always 41
Line 1846
  -- {!<=-1,!>=4294967296,0}
  par {!<=-1,1}
Line 1847
  par always !<=-1
  == always {!<=-1,!>=2}
  0U always 0
Line 1854
  lpar always !0
Line 1855
  ( always {!<=-1,!>=2}
  lpar always !0
  : always 0
  nullptr always 0
Line 1859
  expandedmacros possible size=0@71
Line 1865
  usageList possible lifetime[Object]=(loc)
Line 1867
  ( possible {size=8,size=11}
  == {!<=-1,!>=2,0}
  "__FILE__" always "__FILE__"
Line 1868
  output possible {lifetime[Address]=(temp)@137,lifetime[Address]=(temp)@151,lifetime[Address]=(output2)@71,lifetime[Address]=(output2)@73}
  '\"' always 34
  '\"' always 34
Line 1871
  ( possible size=11
  == {!<=-1,!>=2,0}
  "__LINE__" always "__LINE__"
Line 1872
  . always !<=-1
  line always !<=-1
Line 1875
  == always {!<=-1,!>=2}
  "__COUNTER__" always "__COUNTER__"
Line 1876
  ( always !<=-1
  - always !<=-1
  1U always 1
Line 1880
  calledInDefine always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  . always !<=-1
  fileIndex always !<=-1
  != always {!<=-1,!>=2}
  . always !<=-1
  fileIndex always !<=-1
  || always {!<=-1,!>=2}
Line 1881
  . always !<=-1
  line always !<=-1
  < always {!<=-1,!>=2}
  . always !<=-1
  line always !<=-1
Line 1883
  calledInDefine always {!<=-1,!>=2}
Line 1885
  ( always {!<=-1,!>=2}
Line 1887
  && always {!<=-1,!>=2}
  . always !0
  != always {!<=-1,!>=2}
  '(' always 40
Line 1889
  . always !0
Line 1893
  variadic always {!<=-1,!>=2}
Line 1894
  ( always !<=-1
  < always {!<=-1,!>=2}
  ( always !<=-1
Line 1898
  ( always !<=-1
  != always {!<=-1,!>=2}
  ( always !<=-1
  + always !<=-1
  ( always {!<=-1,!>=2}
  ? always !<=-1
  2U always 2
  : always 1
  1U always 1
Line 1906
  ! {!<=-1,!>=2,0}
  parametertokens1 possible size=0
  ( {!<=-1,!>=2,1}
Line 1907
  counter always {!<=-1,!>=2}
  counter always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1908
  parametertokens1 always !size=0
  0 always 0
  != always {!<=-1,!>=2}
  parametertokens1 always !size=0
Line 1909
  == always {!<=-1,!>=2}
  "__COUNTER__" always "__COUNTER__"
Line 1910
  counter always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1915
  m possible {symbolic=(macros.end()),end=0}
  = possible lifetime[Iterator]=(macros)
  ( possible lifetime[Iterator]=(macros)
  "__COUNTER__" always "__COUNTER__"
Line 1917
  ! {!<=-1,!>=2,1,0}
  counter {!<=-1,!>=2,0,1}
  || {!<=-1,!>=2,1}
  m {lifetime[Iterator]=(macros),symbolic=(macros.find("__COUNTER__"))}
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(macros),end=0}
Line 1918
  parametertokens1 always !size=0
Line 1920
  m {lifetime[Iterator]=(macros),symbolic=(macros.find("__COUNTER__")),!symbolic=(macros.end()),!end=0}
Line 1921
  par always !<=-1
  par always !<=-1
  = always 0
  0 always 0
Line 1922
  0 always 0
  && always {!<=-1,!>=2}
  par {!<=-1,0}
  < always {!<=-1,!>=2}
  ( always !<=-1
Line 1923
  tok possible symbolic=(parametertokens1[par])
  == always {!<=-1,!>=2}
  "__COUNTER__" always "__COUNTER__"
Line 1924
  ( always !<=-1
Line 1927
  tok possible symbolic=(parametertokens1[par])
Line 1928
  == always {!<=-1,!>=2}
  par always !<=-1
Line 1930
  par always !<=-1
  ++ always !<=-1
Line 1942
  variadicOpt always {!<=-1,!>=2}
Line 1943
  ( always !<=-1
  > always {!<=-1,!>=2}
  ( always !<=-1
  && always {!<=-1,!>=2}
  [ possible lifetime[Lambda]=(optExpandValue)
  ( {!<=-1,<=symbolic=(parametertokens2.size()-1),!>=symbolic=(parametertokens2.size())}
  - always !<=-1
  1 always 1
  != always {!<=-1,!>=2}
  ')' always 41
Line 1944
  valueToken2 always Uninit
Line 1946
  valueToken2 always Uninit
Line 1947
  endToken2 always Uninit
  = always 0
  nullptr always 0
Line 1949
  valueToken2 always Uninit
Line 1950
  endToken2 always Uninit
Line 1954
  = possible {symbolic=(optExpandValue->cfront()),symbolic=(optNoExpandValue->cfront()),symbolic=(valueToken)}
  valueToken2 possible {symbolic=(optExpandValue->cfront()),symbolic=(optNoExpandValue->cfront()),symbolic=(valueToken)}
  tok inconclusive {symbolic=(optExpandValue->cfront()),symbolic=(optNoExpandValue->cfront()),symbolic=(valueToken)}
  != {!<=-1,!>=2,0}
  endToken2 possible {symbolic=(endToken),symbolic=(tok),0}
Line 1955
  != always {!<=-1,!>=2}
  '#' always 35
Line 1957
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  . always !0
  == always {!<=-1,!>=2}
  '#' always 35
  && always {!<=-1,!>=2}
  . always !0
  && always {!<=-1,!>=2}
  . always !0
  == always {!<=-1,!>=2}
  '#' always 35
Line 1958
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  . always !0
  . always !0
Line 1960
  variadic always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ',' always 44
  && always {!<=-1,!>=2}
  . always !0
  . always !0
  == always {!<=-1,!>=2}
Line 1961
  ( always {!<=-1,!>=2}
Line 1963
  . always !0
  . always !0
Line 1964
  == always {!<=-1,!>=2}
Line 1969
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  & {lifetime[Address]=(new_output),!0}
Line 1970
  ( always {!<=-1,!>=2}
Line 1971
  ( always {!<=-1,!>=2}
Line 1972
  "" always ""
  ( always {!<=-1,!>=2}
Line 1975
  ( always {!<=-1,!>=2}
Line 1983
  = always 1
  1 always 1
Line 1985
  ( always {!<=-1,!>=2}
  hashToken possible symbolic=(tok->next)
  && always {!<=-1,!>=2}
  hashToken possible symbolic=(tok->next)
  == always {!<=-1,!>=2}
  '#' always 35
Line 1989
  == always {!<=-1,!>=2}
  4 always 4
  && always {!<=-1,!>=2}
  . always !<=-1
  col always !<=-1
  + always !<=0
  1 always 1
  == always {!<=-1,!>=2}
  . always !<=-1
  col always !<=-1
Line 1991
  "##" always "##"
  ( always {!<=-1,!>=2}
Line 1996
  >= always {!<=-1,!>=2}
  2 always 2
  && always {!<=-1,!>=2}
  . always !<=-1
  col always !<=-1
  + always !<=0
  1 always 1
  < always {!<=-1,!>=2}
  . always !<=-1
  col always !<=-1
Line 2002
  = possible symbolic=(hashToken)
  . possible symbolic=(hashToken)
Line 2003
  tok possible symbolic=(hashToken)
  == always {!<=-1,!>=2}
Line 2004
  tok always symbolic=(endToken2)
Line 2007
  tok always !symbolic=(endToken2)
  == always {!<=-1,!>=2}
  '#' always 35
Line 2009
  tok always !symbolic=(endToken2)
Line 2012
  tok always !symbolic=(endToken2)
Line 2016
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2022
  ! {!<=-1,!>=2,0}
  parametertokens1 possible size=0
  ( {!<=-1,!>=2,1}
Line 2023
  parametertokens1 always !size=0
Line 2025
  ( always {!<=-1,!>=2}
Line 2029
  ! always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  . always {!<=-1,!>=2}
  name always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  . always !0
  == always {!<=-1,!>=2}
  '(' always 40
Line 2031
  . possible 0
Line 2034
  ! always {!<=-1,!>=2}
Line 2039
  it possible {symbolic=(macros.end()),end=0}
  = possible lifetime[Iterator]=(macros)
  ( possible lifetime[Iterator]=(macros)
Line 2040
  it {lifetime[Iterator]=(macros),symbolic=(macros.find(temp.cback()->str()))}
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(macros),end=0}
  || always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(expandedmacros)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(expandedmacros),end=0}
Line 2045
  it {lifetime[Iterator]=(macros),symbolic=(macros.find(temp.cback()->str())),!end=0}
Line 2046
  ! always {!<=-1,!>=2}
  calledMacro always symbolic=(it->second)
  ( always {!<=-1,!>=2}
Line 2054
  & {lifetime[Address]=(temp2),!0}
Line 2055
  ! always {!<=-1,!>=2}
Line 2060
  tok2 always !0
Line 2065
  ! always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  name always {!<=-1,!>=2}
Line 2066
  true always 1
Line 2073
  ( always {!<=-1,!>=2}
  & {lifetime[Address]=(temp),!0}
Line 2074
  == always {!<=-1,!>=2}
  "__VA_ARGS__" always "__VA_ARGS__"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
  "," always ","
  && always {!<=-1,!>=2}
Line 2075
  && always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
  ")" always ")"
Line 2082
  it possible {symbolic=(macros.end()),end=0}
  = possible lifetime[Iterator]=(macros)
  ( possible lifetime[Iterator]=(macros)
Line 2083
  it {lifetime[Iterator]=(macros),symbolic=(macros.find(tok->str()))}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(macros),end=0}
  && always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(expandedmacros)
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(expandedmacros),end=0}
Line 2087
  it {lifetime[Iterator]=(macros),symbolic=(macros.find(tok->str())),!symbolic=(macros.end()),!end=0}
Line 2088
  ! always {!<=-1,!>=2}
  calledMacro always symbolic=(it->second)
  ( always {!<=-1,!>=2}
Line 2090
  calledMacro always symbolic=(it->second)
  & {lifetime[Address]=(temp),!0}
Line 2091
  expandedmacros2 always !size=0
Line 2093
  ! always {!<=-1,!>=2}
Line 2094
  true always 1
Line 2099
  = always 0
  nullptr always 0
Line 2100
  == always {!<=-1,!>=2}
  '(' always 40
Line 2101
  & {lifetime[Address]=(tokens),!0}
Line 2102
  & {lifetime[Address]=(tokens),!0}
Line 2104
  && always {!<=-1,!>=2}
  . always !0
  == always {!<=-1,!>=2}
  '(' always 40
Line 2107
  ! always {!<=-1,!>=2}
  tok2 possible symbolic=(tok->next)
Line 2108
  true always 1
Line 2112
  & {lifetime[Address]=(temp),!0}
Line 2113
  tok2 always !0
Line 2116
  == always {!<=-1,!>=2}
Line 2118
  = possible 0
  tok2 always symbolic=(tok->next)
  ? possible 0
  tok2 {symbolic=(tok->next),!0}
  : always 0
  nullptr always 0
Line 2119
  = possible 0
  tok3 {symbolic=(tok2?tok2->next:nullptr),0}
  ? possible 0
  tok3 {symbolic=(tok2?tok2->next:nullptr),!0}
  : always 0
  nullptr always 0
Line 2120
  = always 0
  nullptr always 0
Line 2121
  = always 0
  nullptr always 0
Line 2122
  ( always {!<=-1,!>=2}
  tok4 {symbolic=(tok3?tok3->next:nullptr),0}
  && always {!<=-1,!>=2}
  tok2 always symbolic=(tok->next)
  == always {!<=-1,!>=2}
  '(' always 40
  && always {!<=-1,!>=2}
  tok3 always symbolic=(tok2?tok2->next:nullptr)
  . always {!<=-1,!>=2}
  name always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  tok4 always symbolic=(tok3?tok3->next:nullptr)
  == always {!<=-1,!>=2}
  ')' always 41
Line 2123
  = always symbolic=(tok2?tok2->next:nullptr)
  tok3 always symbolic=(tok2?tok2->next:nullptr)
Line 2124
  = always symbolic=(tok3?tok3->next:nullptr)
  tok4 always symbolic=(tok3?tok3->next:nullptr)
Line 2125
  ( always {!<=-1,!>=2}
  tok2 always symbolic=(tok->next)
  && always {!<=-1,!>=2}
  tok2 always symbolic=(tok->next)
  . always {!<=-1,!>=2}
  name always {!<=-1,!>=2}
Line 2126
  = always symbolic=(tok->next)
  = always symbolic=(tok->next)
  tok2 always symbolic=(tok->next)
Line 2128
  defToken possible {symbolic=(tok3),symbolic=(tok2?tok2->next:nullptr),symbolic=(tok->next)}
Line 2129
  defToken always !0
Line 2130
  defToken always !0
  && always {!<=-1,!>=2}
  defToken always !0
  . always !0
  == always {!<=-1,!>=2}
  '#' always 35
  && always {!<=-1,!>=2}
  defToken always !0
  . always !0
  && always {!<=-1,!>=2}
  defToken always !0
  . always !0
  == always {!<=-1,!>=2}
  '#' always 35
  && always {!<=-1,!>=2}
  defToken always !0
  . always !0
  && always {!<=-1,!>=2}
  defToken always !0
  . always !0
  . always {!<=-1,!>=2}
  name always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  defToken always !0
  defToken always !0
  . always !0
Line 2132
  ( always {!<=-1,!>=2}
  & {lifetime[Address]=(temp),!0}
  defToken always !0
Line 2134
  ( always {!<=-1,!>=2}
  & {lifetime[Address]=(temp),!0}
  defToken always !0
  . always !0
  . always !0
  . always !0
Line 2135
  ( always !0
  : always ""
  "" always ""
Line 2137
  defToken always !0
  . always !0
  . always !0
  . always !0
Line 2138
  = always !0
  defToken always !0
  . always !0
  . always !0
  . always !0
Line 2140
  def {!<=-1,!>=2,0}
  = always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(macros)
  macroName possible symbolic=(defToken->str())
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(macros),end=0}
Line 2141
  def always {!<=-1,!>=2}
  ? possible {"1","0"}
  "1" always "1"
  : always "0"
  "0" always "0"
  true always 1
Line 2146
  true always 1
Line 2150
  ( always {!<=-1,!>=2}
Line 2151
  ! always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  name always {!<=-1,!>=2}
Line 2152
  return always {!<=-1,!>=2}
  false always 0
Line 2154
  argnr {!<=-1,>=symbolic=(args.size()),<=symbolic=(args.size()-1)}
  = always !<=-1
  ( always !<=-1
Line 2155
  argnr {symbolic=(getArgNum(tok->str())),!<=-1}
  >= always {!<=-1,!>=2}
  ( always !<=-1
Line 2156
  return always {!<=-1,!>=2}
  false always 0
Line 2159
  variadic always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  argnr {symbolic=(getArgNum(tok->str())),!<=-1,!>=symbolic=(args.size())}
  + always !<=0
  1U always 1
  >= always {!<=-1,!>=2}
  ( always !<=-1
Line 2160
  return always {!<=-1,!>=2}
  true always 1
Line 2162
  argnr {!<=-1,!>=symbolic=(args.size()),<=symbolic=(parametertokens.size()-2)}
  != always {!<=-1,!>=2}
  argnr {!<=-1,!>=symbolic=(args.size()),<=symbolic=(parametertokens.size()-2)}
  + always !<=0
  1U always 1
Line 2165
  return always {!<=-1,!>=2}
  true always 1
Line 2168
  ( always {!<=-1,!>=2}
Line 2169
  ! always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  name always {!<=-1,!>=2}
Line 2170
  return always {!<=-1,!>=2}
  false always 0
Line 2171
  argnr {!<=-1,>=symbolic=(args.size()),<=symbolic=(args.size()-1)}
  = always !<=-1
  ( always !<=-1
Line 2172
  argnr {symbolic=(getArgNum(tok->str())),!<=-1}
  >= always {!<=-1,!>=2}
  ( always !<=-1
Line 2173
  return always {!<=-1,!>=2}
  false always 0
Line 2174
  variadic always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  argnr {symbolic=(getArgNum(tok->str())),!<=-1,!>=symbolic=(args.size())}
  + always !<=0
  1U always 1
  >= always {!<=-1,!>=2}
  ( always !<=-1
Line 2175
  return always {!<=-1,!>=2}
  true always 1
Line 2176
  [ possible lifetime[Lambda]=(if(it!=macros.end()&&!partok->isExpandedFrom(&it->second)&&(partok->str()==name()||expandedmacros.find(partok->str())==expandedmacros.end())))
  argnr {!<=-1,!>=symbolic=(args.size()),<=symbolic=(parametertokens.size()-2)}
  != always {!<=-1,!>=2}
  argnr {!<=-1,<=symbolic=(parametertokens.size()-2)}
  + always !<=0
  1U always 1
Line 2177
  it possible {lifetime[Iterator]=(macros),symbolic=(macros.end()),end=0}
  = possible lifetime[Iterator]=(macros)
  ( possible lifetime[Iterator]=(macros)
Line 2178
  it {lifetime[Iterator]=(macros),symbolic=(macros.find(partok->str()))}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(macros),end=0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  & {lifetime[Object]=(macros),!0}
  it {lifetime[Iterator]=(macros),symbolic=(macros.find(partok->str())),!symbolic=(macros.end()),!end=0}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(expandedmacros)
  ( always !symbolic=(name())
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(expandedmacros),end=0}
Line 2181
  it possible lifetime[Iterator]=(macros)
Line 2183
  ( always {!<=-1,!>=2}
Line 2188
  . always {!<=-1,!>=2}
  whitespaceahead always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 2189
  . always {!<=-1,!>=2}
  whitespaceahead always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2190
  return always {!<=-1,!>=2}
  true always 1
Line 2205
  & {lifetime[Address]=(tokenListHash),!0}
  macros2 always size=0
Line 2207
  '\"' always 34
Line 2211
  && always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  whitespaceahead always {!<=-1,!>=2}
Line 2212
  ' ' always 32
Line 2214
  '\"' always 34
Line 2215
  ( always {!<=-1,!>=2}
Line 2231
  , always 1
  expandResult always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2232
  output possible lifetime[Address]=(output2)@79
Line 2233
  ! always {!<=-1,!>=2}
Line 2234
  "Missing first argument" always "Missing first argument"
Line 2235
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2238
  canBeConcatenatedWithEqual {!<=-1,!>=2,0}
  = always {!<=-1,!>=2}
  A always !0
  ( always {!<=-1,!>=2}
  "+-*/%&|^" always "+-*/%&|^"
  || always {!<=-1,!>=2}
  A always !0
  == always {!<=-1,!>=2}
  "<<" always "<<"
  || always {!<=-1,!>=2}
  A always !0
  == always {!<=-1,!>=2}
  ">>" always ">>"
Line 2239
  canBeConcatenatedStringOrChar {!<=-1,!>=2,0}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  A always !0
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  A always !0
Line 2240
  unexpectedA {!<=-1,!>=2,0}
  = always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  A always !0
  . always {!<=-1,!>=2}
  name always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  A always !0
  . always {!<=-1,!>=2}
  number always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  A always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  canBeConcatenatedWithEqual always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  canBeConcatenatedStringOrChar {symbolic=(isStringLiteral_(A->str())||isCharLiteral_(A->str())),!<=-1,!>=2}
Line 2243
  ! {!<=-1,!>=2,1}
  B always symbolic=(tok->next->next)
  . {!<=-1,!>=2,0}
  name always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  B always symbolic=(tok->next->next)
  . always {!<=-1,!>=2}
  number always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  B always symbolic=(tok->next->next)
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  B always symbolic=(tok->next->next)
  ( always {!<=-1,!>=2}
  "#=" always "#="
Line 2244
  B always symbolic=(tok->next->next)
Line 2246
  canBeConcatenatedWithEqual always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  B always symbolic=(tok->next->next)
  != always {!<=-1,!>=2}
  '=' always 61
  || always {!<=-1,!>=2}
Line 2247
  ! always {!<=-1,!>=2}
  canBeConcatenatedWithEqual always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  B always symbolic=(tok->next->next)
  == always {!<=-1,!>=2}
  '=' always 61
Line 2248
  B always symbolic=(tok->next->next)
Line 2251
  canBeConcatenatedStringOrChar {!<=-1,!>=2,0}
  && {!<=-1,!>=2,0}
  . always {!<=-1,!>=2}
  number always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  name always {!<=-1,!>=2}
Line 2257
  canBeConcatenatedStringOrChar {!<=-1,!>=2,0}
Line 2258
  unexpectedA always {!<=-1,!>=2}
Line 2263
  ( always {!<=-1,!>=2}
  & {lifetime[Address]=(tokensB),!0}
Line 2274
  varargs {!<=-1,!>=2,0}
  = always {!<=-1,!>=2}
  variadic always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  args always !size=0
  args always !size=0
  ( always !<=0
  - always !<=-1
  1U always 1
Line 2276
  ( always {!<=-1,!>=2}
  & {lifetime[Address]=(tokensB),!0}
Line 2277
  ( always {!<=-1,!>=2}
Line 2279
  varargs {symbolic=(variadic&&!args.empty()&&B->str()==args[args.size()-1U]),!<=-1,!>=2,0}
  && {!<=-1,!>=2,0}
  == always {!<=-1,!>=2}
  ',' always 44
Line 2280
  = always ","
  "," always ","
Line 2281
  varargs {symbolic=(variadic&&!args.empty()&&B->str()==args[args.size()-1U]),!<=-1,!>=2,0}
  && {!<=-1,!>=2,0}
  unexpectedA always {!<=-1,!>=2}
Line 2288
  unexpectedA always {!<=-1,!>=2}
Line 2294
  && always {!<=-1,!>=2}
  . always !0
  == always {!<=-1,!>=2}
  "\\" always "\\"
Line 2295
  strAB possible size=5
  [ possible 85
  0 always 0
  == {!<=-1,!>=2,0}
  'u' always 117
  && {!<=-1,!>=2,0}
  ( always !<=-1
  == always {!<=-1,!>=2}
  5 always 5
Line 2296
  strAB always size=5
Line 2297
  strAB possible size=9
  0 always 0
  == always {!<=-1,!>=2}
  'U' always 85
  && always {!<=-1,!>=2}
  ( always !<=-1
  == always {!<=-1,!>=2}
  9 always 9
Line 2298
  strAB always size=9
Line 2301
  varargs {symbolic=(variadic&&!args.empty()&&B->str()==args[args.size()-1U]),!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "," always ","
Line 2303
  != always {!<=-1,!>=2}
  "," always ","
  && always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(macros)
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(macros),end=0}
Line 2308
  ( always {!<=-1,!>=2}
  nextTok always symbolic=(B->next)
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  '#' always 35
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  '#' always 35
Line 2311
  & {lifetime[Address]=(output2),!0}
Line 2319
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  '(' always 40
Line 2320
  it possible {symbolic=(macros.end()),end=0}
  = possible lifetime[Iterator]=(macros)
  ( possible lifetime[Iterator]=(macros)
Line 2321
  it {lifetime[Iterator]=(macros),symbolic=(macros.find(strAB))}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(macros),end=0}
  && always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(expandedmacros)
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(expandedmacros),end=0}
  && always {!<=-1,!>=2}
  it {lifetime[Iterator]=(macros),!symbolic=(macros.end()),!end=0}
Line 2322
  & {lifetime[Address]=(tokens),!0}
Line 2324
  tok2 always !0
Line 2327
  expandResult always {!<=-1,!>=2}
Line 2337
  nextTok possible symbolic=(B->next)
Line 2340
  ( always {!<=-1,!>=2}
Line 2342
  = {lifetime[Iterator]=(expandedmacros),start=0}
  ( {lifetime[Iterator]=(expandedmacros),start=0}
Line 2343
  it {lifetime[Iterator]=(expandedmacros),symbolic=(expandedmacros.begin()),start=0}
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(expandedmacros),end=0}
Line 2344
  return always {!<=-1,!>=2}
  false always 0
Line 2345
  ++ {!symbolic=(expandedmacros.end()+1),symbolic=(expandedmacros.begin()+1)}
  it {lifetime[Iterator]=(expandedmacros),symbolic=(expandedmacros.begin()),!symbolic=(expandedmacros.end()),!end=0,start=0}
Line 2346
  return always {!<=-1,!>=2}
  it {lifetime[Iterator]=(expandedmacros),symbolic=(expandedmacros.begin()+1),!symbolic=(expandedmacros.end()+1)}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(expandedmacros),end=0}
Line 2371
  variadic always {!<=-1,!>=2}
Line 2374
  variadicOpt always {!<=-1,!>=2}
Line 2381
  valueDefinedInCode_ always {!<=-1,!>=2}
Line 2428
  ( always {!<=-1,!>=2}
Line 2430
  return always {!<=-1,!>=2}
  path possible symbolic=(*it)@45509
  ( always !<=-1
  > always {!<=-1,!>=2}
  1U always 1
  && always {!<=-1,!>=2}
  path {>=size=2,!<=size=1,symbolic=(*it)@45509}
  0 always 0
  == always {!<=-1,!>=2}
  '/' always 47
Line 2440
  ( always {!<=-1,!>=2}
Line 2441
  path always size=0
Line 2443
  :: always !<=-1
  pos always !<=-1
Line 2446
  path always !size=0
  ( {lifetime[Iterator]=(path),!size=0,start=0}
  path always !size=0
  ( {lifetime[Iterator]=(path),!size=0,end=0}
  '\\' always 92
  '/' always 47
Line 2448
  unc {!<=-1,!>=2,0}
  path always !size=0
  0 always 0
  2 always 2
  "//" always "//"
  == always {!<=-1,!>=2}
  0 always 0
Line 2451
  pos always !<=-1
  = always 0
  0 always 0
Line 2452
  pos always !<=-1
  = always !<=-1
  ( always !<=-1
  "//" always "//"
  pos {!<=-1,0}
  != always {!<=-1,!>=2}
Line 2453
  pos always !<=-1
  1 always 1
Line 2457
  pos always !<=-1
  = always 0
  0 always 0
Line 2458
  pos always !<=-1
  = always !<=-1
  ( always !<=-1
  "./" always "./"
  pos {!<=-1,0}
  != always {!<=-1,!>=2}
Line 2459
  pos always !<=-1
  == always {!<=-1,!>=2}
  0 always 0
  || always {!<=-1,!>=2}
  pos always !<=0
  - always !<=-1
  1U always 1
  == always {!<=-1,!>=2}
  '/' always 47
Line 2460
  pos {!<=-1,0}
  2 always 2
Line 2462
  pos always !<=0
  += always !<=-1
  2 always 2
Line 2466
  ( always {!<=-1,!>=2}
  "/." always "/."
Line 2467
  ( always !<=-1
  - always !<=-1
  1 always 1
Line 2470
  pos always !<=-1
  = always 1
  1 always 1
Line 2471
  pos always !<=-1
  = always !<=-1
  ( always !<=-1
  "/.." always "/.."
  pos {symbolic=((pos1==0)?1:(pos1-1)),!<=-1,1}
  != always {!<=-1,!>=2}
Line 2473
  pos always !<=-1
  + always !<=2
  3 always 3
  < always {!<=-1,!>=2}
  ( always !<=-1
  && always {!<=-1,!>=2}
  pos {!<=-1,<=symbolic=(path.size()-4),!>=symbolic=(path.size()-3)}
  + always !<=2
  3 always 3
  != always {!<=-1,!>=2}
  '/' always 47
Line 2474
  ++ {!<=0,<=symbolic=(path.size()-3),!>=symbolic=(path.size()-2)}
  pos {!<=-1,<=symbolic=(path.size()-4),!>=symbolic=(path.size()-3)}
Line 2478
  :: always !<=-1
  pos1 always !<=-1
  pos1 always !<=-1
  = always !<=-1
  ( always !<=-1
  '/' always 47
  pos {!<=-1,>=symbolic=(path.size()-3)}
  - always !<=-1
  1U always 1
Line 2479
  pos1 always !<=-1
  == always {!<=-1,!>=2}
Line 2480
  pos1 always !<=-1
  = always 0
  0 always 0
Line 2482
  pos1 always !<=-1
  += always !<=-1
  1U always 1
Line 2484
  pos1 {!<=-1,0}
  pos always !<=-1
  - always !<=-1
  pos1 {!<=-1,0}
Line 2485
  == always {!<=-1,!>=2}
  ".." always ".."
Line 2487
  ++ always !<=0
  pos always !<=-1
Line 2490
  pos1 always !<=-1
  pos always !<=-1
  - always !<=-1
  pos1 always !<=-1
  + always !<=3
  4 always 4
Line 2491
  ( always {!<=-1,!>=2}
Line 2492
  = always "."
  "." always "."
Line 2494
  pos always !<=-1
  = {1,!<=-1}
  pos1 always !<=-1
  == always {!<=-1,!>=2}
  0 always 0
  ? {1,!<=-1}
  1 always 1
  : always 1
  pos1 always !<=0
  - always !<=-1
  1 always 1
Line 2502
  unc always {!<=-1,!>=2}
Line 2503
  '/' always 47
Line 2512
  = possible symbolic=(tok2)
  . possible symbolic=(tok2)
Line 2513
  != always {!<=-1,!>=2}
  "sizeof" always "sizeof"
Line 2516
  ! {!<=-1,!>=2,1}
  tok1 {symbolic=(tok->next),0}
Line 2517
  "missing sizeof argument" always "missing sizeof argument"
Line 2519
  tok1 {symbolic=(tok->next),!0}
Line 2520
  ! {!<=-1,!>=2,1}
  tok2 {symbolic=(tok1->next),0}
Line 2521
  "missing sizeof argument" always "missing sizeof argument"
Line 2523
  tok1 always !0
  == always {!<=-1,!>=2}
  '(' always 40
Line 2524
  = always symbolic=(tok2)
  tok1 always !0
  . always symbolic=(tok2)
Line 2525
  tok2 possible symbolic=(tok1)
  != always {!<=-1,!>=2}
  ')' always 41
Line 2527
  ! always {!<=-1,!>=2}
Line 2528
  "invalid sizeof expression" always "invalid sizeof expression"
Line 2534
  != {!<=-1,!>=2,0}
  tok2 possible symbolic=(typeToken)
Line 2535
  ( possible {size=6,size=1}
  == {!<=-1,!>=2,0}
  "unsigned" always "unsigned"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "signed" always "signed"
  && always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  name always {!<=-1,!>=2}
Line 2537
  == always {!<=-1,!>=2}
  "*" always "*"
  && always {!<=-1,!>=2}
  ( always !<=-1
  '*' always 42
  != always {!<=-1,!>=2}
Line 2539
  ! {!<=-1,!>=2,0}
  type possible size=0
  ( {!<=-1,!>=2,1}
Line 2540
  ' ' always 32
Line 2544
  it possible {symbolic=(sizeOfType.end()),end=0}
  = possible lifetime[Iterator]=(sizeOfType)
  ( possible lifetime[Iterator]=(sizeOfType)
  type possible size=0
Line 2545
  it {lifetime[Iterator]=(sizeOfType),symbolic=(sizeOfType.find(type))}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(sizeOfType),end=0}
Line 2546
  it {lifetime[Iterator]=(sizeOfType),!end=0}
Line 2551
  != always {!<=-1,!>=2}
Line 2556
  ( always {!<=-1,!>=2}
Line 2559
  return always {!<=-1,!>=2}
  ! {!<=-1,!>=2,0}
  std_ver {symbolic=(simplecpp::getCppStdString(dui.std)),size=0}
  ( {!<=-1,!>=2,1}
  && {!<=-1,!>=2,0}
  std_ver {symbolic=(simplecpp::getCppStdString(dui.std)),!size=0}
  >= always {!<=-1,!>=2}
  "201703L" always "201703L"
Line 2562
  ( always {!<=-1,!>=2}
Line 2564
  return always {!<=-1,!>=2}
  ( always !<=-1
  "gnu" always "gnu"
  0 always 0
  != always {!<=-1,!>=2}
Line 2567
  , always 1
  withTrailingSlash always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2569
  lastSlash always !<=-1
  = always !<=-1
  path possible ""@7113
  ( always !<=-1
  "\\/" always "\\/"
Line 2570
  lastSlash {symbolic=(path.find_last_of("\\/")),!<=-1}
  == always {!<=-1,!>=2}
Line 2571
  "" always ""
Line 2573
  0 always 0
  lastSlash {symbolic=(path.find_last_of("\\/")),!<=-1}
  + always !<=-1
  withTrailingSlash {!<=-1,!>=2,1}
  ? {1,0,!<=-1}
  1U always 1
  : always 0
  0U always 0
Line 2579
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2582
  = possible symbolic=(tok2)
  . possible symbolic=(tok2)
Line 2583
  != always {!<=-1,!>=2}
Line 2586
  ! {!<=-1,!>=2,1}
  tok1 {symbolic=(tok->next),0}
Line 2587
  "missing __has_include argument" always "missing __has_include argument"
Line 2589
  tok1 {symbolic=(tok->next),!0}
Line 2590
  ! {!<=-1,!>=2,1}
  tok2 {symbolic=(tok1->next),0}
Line 2591
  "missing __has_include argument" always "missing __has_include argument"
Line 2593
  tok1 always !0
  == always {!<=-1,!>=2}
  '(' always 40
Line 2594
  = always symbolic=(tok2)
  tok1 always !0
  . always symbolic=(tok2)
Line 2595
  tok2 possible symbolic=(tok1)
  != always {!<=-1,!>=2}
  ')' always 41
Line 2597
  ! always {!<=-1,!>=2}
Line 2598
  "invalid __has_include expression" always "invalid __has_include expression"
Line 2604
  systemheader {!<=-1,!>=2,0}
  = always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  tok1 always !0
  == always {!<=-1,!>=2}
  '<' always 60
Line 2606
  systemheader {symbolic=(tok1&&tok1->op=='<'),!<=-1,!>=2}
Line 2608
  ! {!<=-1,!>=2,1}
  tok3 {symbolic=(tok1->next),0}
Line 2609
  "missing __has_include closing angular bracket" always "missing __has_include closing angular bracket"
Line 2611
  tok3 possible symbolic=(tok1->next)
  != always {!<=-1,!>=2}
  '>' always 62
Line 2613
  ! always {!<=-1,!>=2}
Line 2614
  "invalid __has_include expression" always "invalid __has_include expression"
Line 2618
  != {!<=-1,!>=2,0}
  tok3 possible symbolic=(headerToken)
Line 2621
  1U always 1
  ( always !<=-1
  - always !<=-1
  2U always 2
Line 2624
  sourcefile possible symbolic=(tok->location.file())
  systemheader {symbolic=(tok1&&tok1->op=='<'),!<=-1,!>=2,1,0}
Line 2625
  ( always {!<=-1,!>=2}
  "0" always "0"
  : always "1"
  "1" always "1"
Line 2628
  != always {!<=-1,!>=2}
Line 2633
  altopData always !0
  8 always 8
  "and" always "and"
  "or" always "or"
  "bitand" always "bitand"
  "bitor" always "bitor"
  "compl" always "compl"
  "not" always "not"
  "not_eq" always "not_eq"
  "xor" always "xor"
Line 2634
  & always !0
  altopData {{,!0}
  0 always 0
  & always !0
  altopData {{,!0}
  8 always 8
Line 2638
  . always {!<=-1,!>=2}
  name always {!<=-1,!>=2}
Line 2639
  ( possible lifetime[Iterator]=(altop)
  ( possible {size=3,size=5}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(altop),end=0}
Line 2640
  alt always {!<=-1,!>=2}
Line 2641
  ( possible size=5
  == {!<=-1,!>=2,0}
  "not" always "not"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "compl" always "compl"
Line 2642
  alt always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( possible {size=3,size=5}
Line 2644
  alt always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2646
  alt always {!<=-1,!>=2}
Line 2649
  && always {!<=-1,!>=2}
  . always !0
  == always {!<=-1,!>=2}
  "(" always "("
Line 2650
  "undefined function-like macro invocation: " always "undefined function-like macro invocation: "
  "( ... )" always "( ... )"
Line 2651
  "0" always "0"
Line 2664
  ( always !<=-1
Line 2666
  pos always !<=-1
  , always 0
Line 2667
  = always 0
  0 always 0
  , always 1
Line 2668
  = always 1
  1 always 1
  , always !<=-1
Line 2669
  maxlen always !<=-1
  = always !<=-1
Line 2672
  pos always !<=-1
  maxlen {!<=-1,3@241,symbolic=(escape=='u'?4:8)@243,4@243,8@243}
Line 2673
  = {lifetime[Object]=(sub),!0}
  ( {lifetime[Object]=(sub),!0}
Line 2675
  value always !<=-1
  = always !<=-1
  ( always !<=-1
  start {lifetime[Object]=(sub),symbolic=(sub.c_str()),!0}
  & {lifetime[Address]=(end),!0,Uninit*}
  end always Uninit
  base possible {8@241,16@242,0}
Line 2676
  pos always !<=-1
  += always !<=-1
  start {lifetime[Object]=(sub),symbolic=(sub.c_str()),!0}
Line 2677
  start {lifetime[Object]=(sub),symbolic=(sub.c_str()),!0}
  < always {!<=-1,!>=2}
  minlen possible {1@241,symbolic=(escape=='u'?4:8)@243,4@243,8@243}
Line 2678
  "expected digit" always "expected digit"
Line 2679
  return always !<=-1
  value always !<=-1
Line 2713
  narrow {!<=-1,!>=2,0}
  narrow always {!<=-1,!>=2}
  = always 0
  false always 0
Line 2714
  utf8 {!<=-1,!>=2,0}
  utf8 always {!<=-1,!>=2}
  = always 0
  false always 0
Line 2715
  utf16 {!<=-1,!>=2,0}
  utf16 always {!<=-1,!>=2}
  = always 0
  false always 0
Line 2717
  pos always !<=-1
Line 2719
  ! {!<=-1,!>=2,0}
  str possible size=0
  ( {!<=-1,!>=2,1}
  && {!<=-1,!>=2,0}
  str always !size=0
  0 always 0
  == always {!<=-1,!>=2}
  '\'' always 39
Line 2720
  narrow always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2721
  pos always !<=-1
  = always 1
  1 always 1
Line 2722
  str possible size=0
  ( {!<=-1,0}
  >= {!<=-1,!>=2,0}
  2 always 2
  && {!<=-1,!>=2,0}
  str {>=size=2,!<=size=1}
  0 always 0
  == always {!<=-1,!>=2}
  'u' always 117
  && {!<=-1,!>=2,0}
  str {>=size=2,!<=size=1}
  1 always 1
  == always {!<=-1,!>=2}
  '\'' always 39
Line 2723
  utf16 always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2724
  pos always !<=-1
  = always 2
  2 always 2
Line 2725
  str possible {size=0,<=size=1}
  ( {!<=-1,0,<=1}
  >= {!<=-1,!>=2,0}
  3 always 3
  && {!<=-1,!>=2,0}
  str {>=size=3,!<=size=2}
  0 always 0
  == always {!<=-1,!>=2}
  'u' always 117
  && {!<=-1,!>=2,0}
  str {>=size=3,!<=size=2}
  1 always 1
  == always {!<=-1,!>=2}
  '8' always 56
  && {!<=-1,!>=2,0}
  2 always 2
  == always {!<=-1,!>=2}
  '\'' always 39
Line 2726
  utf8 always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2727
  pos always !<=-1
  = always 3
  3 always 3
Line 2728
  str possible {size=0,<=size=2}
  ( {!<=-1,0,<=2}
  >= {!<=-1,!>=2,0,<=1}
  2 always 2
  && {!<=-1,!>=2,0}
  str {<=size=2,!<=size=1}
  0 always 0
  == always {!<=-1,!>=2}
  'L' always 76
  || always {!<=-1,!>=2}
  str always !<=size=1
  0 always 0
  == always {!<=-1,!>=2}
  'U' always 85
  && {!<=-1,!>=2,0}
  str {>=size=2,!<=size=1}
  1 always 1
  == always {!<=-1,!>=2}
  '\'' always 39
Line 2729
  pos always !<=-1
  = always 2
  2 always 2
Line 2731
  "expected a character literal" always "expected a character literal"
Line 2733
  multivalue always !<=-1
  multivalue always !<=-1
  = always 0
  0 always 0
Line 2735
  nbytes always !<=-1
  nbytes always !<=-1
  = always 0
  0 always 0
Line 2737
  pos {!<=-1,1,2,3}
  + {!<=0,2,3,4}
  1 always 1
  < {!<=-1,!>=2,>=0}
  str possible >=size=2
  ( {!<=-1,>=2}
Line 2738
  [ possible 10
  pos {!<=-1,<=symbolic=(str.size()-2),!>=symbolic=(str.size()-1)}
  == {!<=-1,!>=2,0}
  '\'' always 39
  || always {!<=-1,!>=2}
  pos always {!<=-1,!>=symbolic=(str.size()-1)}
  == always {!<=-1,!>=2}
  '\n' always 10
Line 2739
  "raw single quotes and newlines not allowed in character literals" always "raw single quotes and newlines not allowed in character literals"
Line 2741
  nbytes always !<=-1
  >= always {!<=-1,!>=2}
  1 always 1
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  narrow always {!<=-1,!>=2}
Line 2742
  "multiple characters only supported in narrow character literals" always "multiple characters only supported in narrow character literals"
Line 2744
  value always !<=-1
Line 2746
  [ always {!39,!10}
  pos {!<=-1,>=symbolic=(str.size()-2),<=symbolic=(str.size()-3)}
  == always {!<=-1,!>=2}
  '\\' always 92
Line 2747
  pos {!<=-1,>=symbolic=(str.size()-2),<=symbolic=(str.size()-3)}
  ++ {!<=-1,>=symbolic=(str.size()-2),<=symbolic=(str.size()-3)}
Line 2748
  pos {!<=-1,>=symbolic=(str.size()-1),<=symbolic=(str.size()-2)}
  ++ {!<=-1,>=symbolic=(str.size()-1),<=symbolic=(str.size()-2)}
Line 2750
  pos always !<=-1
  >= always {!<=-1,!>=2}
  ( always !<=-1
Line 2751
  "unexpected end of character literal" always "unexpected end of character literal"
Line 2755
  '%' always 37
Line 2756
  '(' always 40
Line 2757
  '[' always 91
Line 2758
  '{' always 123
Line 2760
  '\'' always 39
Line 2761
  '"' always 34
Line 2762
  '?' always 63
Line 2763
  '\\' always 92
Line 2764
  value always !<=-1
  = always !<=-1
  ( always !<=-1
Line 2767
  'a' always 97
Line 2768
  value always !<=-1
  = always 7
  ( always 7
  '\a' always 7
Line 2770
  'b' always 98
Line 2771
  value always !<=-1
  = always 8
  ( always 8
  '\b' always 8
Line 2773
  'f' always 102
Line 2774
  value always !<=-1
  = always 12
  ( always 12
  '\f' always 12
Line 2776
  'n' always 110
Line 2777
  value always !<=-1
  = always 10
  ( always 10
  '\n' always 10
Line 2779
  'r' always 114
Line 2780
  value always !<=-1
  = always 13
  ( always 13
  '\r' always 13
Line 2782
  't' always 116
Line 2783
  value always !<=-1
  = always 9
  ( always 9
  '\t' always 9
Line 2785
  'v' always 118
Line 2786
  value always !<=-1
  = always 11
  ( always 11
  '\v' always 11
Line 2790
  'e' always 101
Line 2791
  'E' always 69
Line 2792
  value always !<=-1
  = always 27
  ( always 27
  '\x1b' always 27
Line 2795
  '0' always 48
Line 2796
  '1' always 49
Line 2797
  '2' always 50
Line 2798
  '3' always 51
Line 2799
  '4' always 52
Line 2800
  '5' always 53
Line 2801
  '6' always 54
Line 2802
  '7' always 55
Line 2804
  value always !<=-1
  = always !<=-1
  ( always !<=-1
  -- always !<=-1
  pos always !<=-1
  8 always 8
  1 always 1
  3 always 3
Line 2807
  'x' always 120
Line 2809
  value always !<=-1
  = always !<=-1
  ( always !<=-1
  pos always !<=-1
  16 always 16
Line 2812
  'u' always 117
Line 2813
  'U' always 85
Line 2815
  ndigits always !<=-1
  = {4,8,!<=-1}
  == always {!<=-1,!>=2}
  'u' always 117
  ? possible {4,8}
  4 always 4
  : always 8
  8 always 8
Line 2816
  value always !<=-1
  = always !<=-1
  ( always !<=-1
  pos always !<=-1
  16 always 16
  ndigits {symbolic=(escape=='u'?4:8),!<=-1,4,8}
  ndigits {symbolic=(escape=='u'?4:8),!<=-1,4,8}
Line 2820
  narrow always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  utf8 always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  value always !<=-1
  > always {!<=-1,!>=2}
  0x7f always 127
  || always {!<=-1,!>=2}
  utf16 always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  value always !<=-1
  > always {!<=-1,!>=2}
  0xffff always 65535
  || always {!<=-1,!>=2}
  value always !<=-1
  > always {!<=-1,!>=2}
  0x10ffff always 1114111
Line 2821
  "code point too large" always "code point too large"
Line 2823
  value {!<=-1,!>=1114112,<=1114111}
  >= {!<=-1,!>=2,<=1}
  0xd800 always 55296
  && {!<=-1,!>=2,0}
  value {!>=1114112,<=1114111,>=55296,!<=55295}
  <= {!<=-1,!>=2,<=0,>=1}
  0xdfff always 57343
Line 2824
  "surrogate code points not allowed in universal character names" always "surrogate code points not allowed in universal character names"
Line 2830
  "invalid escape sequence" always "invalid escape sequence"
Line 2833
  value always !<=-1
  = always !<=-1
  ( always !<=-1
  pos always !<=-1
  ++ always !<=-1
Line 2835
  ! always {!<=-1,!>=2}
  narrow always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  value always !<=-1
  >= always {!<=-1,!>=2}
  0x80 always 128
Line 2841
  value {>=128,!<=127}
  >= {!<=-1,!>=2,>=0}
  0xf5 always 245
Line 2842
  "assumed UTF-8 encoded source, but sequence is invalid" always "assumed UTF-8 encoded source, but sequence is invalid"
Line 2843
  value {>=128,!<=127,!>=245,<=244}
  >= {!<=-1,!>=2,>=0,<=1}
  0xf0 always 240
Line 2844
  = always 3
  3 always 3
Line 2845
  value {>=128,!<=127,!>=240,<=239}
  >= {!<=-1,!>=2,>=0,<=1}
  0xe0 always 224
Line 2846
  = always 2
  2 always 2
Line 2847
  value {>=128,!<=127,!>=224,<=223}
  >= {!<=-1,!>=2,>=0,<=1}
  0xc2 always 194
Line 2848
  = always 1
  1 always 1
Line 2850
  "assumed UTF-8 encoded source, but sequence is invalid" always "assumed UTF-8 encoded source, but sequence is invalid"
Line 2852
  value always !<=-1
  &= always !<=-1
  1 always 1
  << possible {8,16,32}
  6 always 6
  - possible {3,4,5}
  additional_bytes possible {3,2,1}
  - possible {7,15,31}
  1 always 1
Line 2854
  additional_bytes possible {3,2,1}
  -- possible {3,2,1}
Line 2855
  pos always !<=-1
  + always !<=0
  1 always 1
  >= always {!<=-1,!>=2}
  ( always !<=-1
Line 2856
  "assumed UTF-8 encoded source, but character literal ends unexpectedly" always "assumed UTF-8 encoded source, but character literal ends unexpectedly"
Line 2858
  c always !<=-1
  = always !<=-1
  pos {!<=-1,!>=symbolic=(str.size()-1),<=symbolic=(str.size()-2)}
  ++ {!<=-1,!>=symbolic=(str.size()-1),<=symbolic=(str.size()-2)}
Line 2860
  c always !<=-1
  6 always 6
  != always {!<=-1,!>=2}
  2 always 2
Line 2861
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  value always !<=-1
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  1 always 1
  && always {!<=-1,!>=2}
  c always !<=-1
  < always {!<=-1,!>=2}
  0xa0 always 160
Line 2862
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  value always !<=-1
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  2 always 2
  && always {!<=-1,!>=2}
  c always !<=-1
  < always {!<=-1,!>=2}
  0x90 always 144
Line 2863
  "assumed UTF-8 encoded source, but sequence is invalid" always "assumed UTF-8 encoded source, but sequence is invalid"
Line 2865
  value always !<=-1
  = always !<=-1
  value always !<=-1
  << always !<=-1
  6 always 6
  | always !<=-1
  c always !<=-1
  1 always 1
  << always 128
  7 always 7
  - always 127
  1 always 1
Line 2868
  value always !<=-1
  >= always {!<=-1,!>=2}
  0xd800 always 55296
  && always {!<=-1,!>=2}
  value {>=55296,!<=55295}
  <= {!<=-1,!>=2,>=1}
  0xdfff always 57343
Line 2869
  "assumed UTF-8 encoded source, but sequence is invalid" always "assumed UTF-8 encoded source, but sequence is invalid"
Line 2871
  utf8 always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  value always !<=-1
  > always {!<=-1,!>=2}
  0x7f always 127
  || always {!<=-1,!>=2}
  utf16 always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  value always !<=-1
  > always {!<=-1,!>=2}
  0xffff always 65535
  || always {!<=-1,!>=2}
  value always !<=-1
  > always {!<=-1,!>=2}
  0x10ffff always 1114111
Line 2872
  "code point too large" always "code point too large"
Line 2876
  narrow always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  utf8 always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  value always !<=-1
  > always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  utf16 always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  value always !<=-1
  >> always !<=-1
  16 always 16
  || always {!<=-1,!>=2}
  value always !<=-1
  >> always !<=-1
  32 always 32
Line 2877
  "numeric escape sequence too large" always "numeric escape sequence too large"
Line 2879
  multivalue always !<=-1
  <<= always !<=-1
  8 always 8
Line 2880
  multivalue always !<=-1
  |= always !<=-1
  value always !<=-1
Line 2881
  nbytes always !<=-1
  ++ always !<=-1
Line 2884
  pos {!<=-1,<=symbolic=(str.size()-2),>=symbolic=(str.size()-1),2,3}
  + {!<=0,3,4}
  1 always 1
  != always {!<=-1,!>=2}
  ( {!<=-1,>=symbolic=(pos+1+1),<=symbolic=(pos+1)}
  || always {!<=-1,!>=2}
  pos {!<=-1,symbolic=(str.size()-1)}
  != always {!<=-1,!>=2}
  '\'' always 39
Line 2885
  "missing closing quote in character literal" always "missing closing quote in character literal"
Line 2887
  ! {!<=-1,!>=2,0}
  nbytes {!<=-1,1}
Line 2888
  "empty character literal" always "empty character literal"
Line 2891
  narrow {!<=-1,!>=2,0}
  && {!<=-1,!>=2,0}
  nbytes always !<=0
  == always {!<=-1,!>=2}
  1 always 1
Line 2892
  multivalue always !<=-1
Line 2895
  narrow {!<=-1,!>=2,0}
Line 2896
  multivalue always !<=-1
Line 2900
  multivalue always !<=-1
Line 2906
  ( always !<=-1
  == always {!<=-1,!>=2}
  1U always 1
Line 2908
  ( always !size=1
  0 always 0
  2 always 2
  "0x" always "0x"
  == always {!<=-1,!>=2}
  0 always 0
Line 2909
  ( always !<=-1
Line 2910
  ! always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  number always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !<=-1
  '\'' always 39
  != always {!<=-1,!>=2}
Line 2919
  tok always symbolic=(d)
Line 2920
  . always {!<=-1,!>=2}
  comment always {!<=-1,!>=2}
Line 2934
  ( possible symbolic=(expr.cback())
  && always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( {!0,symbolic=(expr.cback())}
  . always {!<=-1,!>=2}
  number always {!<=-1,!>=2}
  ( {symbolic=(expr.cback()),!0}
  : always 0
  0LL always 0
Line 2939
  line {!<=-1,symbolic=(tok->location.line)}
  = always !<=-1
  . always !<=-1
  line always !<=-1
Line 2940
  file {!<=-1,symbolic=(tok->location.fileIndex)}
  = always !<=-1
  . always !<=-1
  fileIndex always !<=-1
Line 2941
  && always {!<=-1,!>=2}
  tok always !0
  . {symbolic=(line),!<=-1}
  line always !<=-1
  == {!<=-1,!>=2,1}
  line {symbolic=(tok->location.line),!<=-1}
  && always {!<=-1,!>=2}
  tok always !0
  . {symbolic=(file),!<=-1}
  fileIndex always !<=-1
  == {!<=-1,!>=2,1}
  file {symbolic=(tok->location.fileIndex),!<=-1}
Line 2942
  tok always !0
Line 2943
  tok possible 0
Line 2982
  ( {lifetime[Object]=(path),!0}
Line 2983
  ( always {!<=-1,!>=2}
Line 2988
  "" always ""
Line 2991
  , always {!<=-1,!>=2}
  systemheader always {!<=-1,!>=2}
Line 2993
  ( always {!<=-1,!>=2}
Line 2997
  ! always {!<=-1,!>=2}
  systemheader always {!<=-1,!>=2}
Line 2999
  ! {!<=-1,!>=2,0}
  path possible size=0
  ( {!<=-1,!>=2,1}
Line 3000
  path always !size=0
Line 3006
  "/" always "/"
Line 3007
  ! {!<=-1,!>=2,0}
  path possible size=0
  ( {!<=-1,!>=2,1}
Line 3008
  path always !size=0
Line 3010
  "" always ""
Line 3018
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  path always symbolic=(name_it->first)
Line 3019
  nullptr always 0
  false always 0
Line 3021
  id_it possible {symbolic=(mIdMap.end()),end=0}
  = possible lifetime[Iterator]=(mIdMap)
  ( possible lifetime[Iterator]=(mIdMap)
Line 3022
  id_it {lifetime[Iterator]=(mIdMap),symbolic=(mIdMap.find(fileId))}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mIdMap),end=0}
Line 3023
  id_it {lifetime[Iterator]=(mIdMap),symbolic=(mIdMap.find(fileId)),!symbolic=(mIdMap.end()),!end=0}
Line 3024
  id_it {lifetime[Iterator]=(mIdMap),symbolic=(mIdMap.find(fileId)),!symbolic=(mIdMap.end()),!end=0}
  . always symbolic=(name_it->second)
  false always 0
Line 3030
  . always {!<=-1,!>=2}
  removeComments always {!<=-1,!>=2}
Line 3031
  data always size=0
Line 3033
  = inconclusive size=0
  data inconclusive size=0
Line 3034
  data {symbolic=(name_it->second),size=0}
Line 3035
  data inconclusive {symbolic=(name_it->second),size=0}
Line 3037
  data inconclusive {symbolic=(name_it->second),size=0}
  true always 1
Line 3040
  , always {!<=-1,!>=2}
  systemheader always {!<=-1,!>=2}
Line 3042
  ( always {!<=-1,!>=2}
  header possible symbolic=(*it)@177
Line 3043
  nullptr always 0
Line 3047
  != always {!<=-1,!>=2}
  nullptr always 0
Line 3051
  false always 0
Line 3054
  nullptr always 0
  false always 0
Line 3057
  ! {!<=-1,!>=2,1@27}
  systemheader {!<=-1,!>=2,0@27,symbolic=(htok->str()[0]=='<')@193}
Line 3058
  sourcefile possible ""@27
  nullptr always 0
Line 3062
  != always {!<=-1,!>=2}
  nullptr always 0
Line 3065
  != always {!<=-1,!>=2}
  nullptr always 0
Line 3066
  false always 0
Line 3071
  "/" always "/"
  nullptr always 0
Line 3075
  != always {!<=-1,!>=2}
  nullptr always 0
Line 3078
  != always {!<=-1,!>=2}
  nullptr always 0
Line 3079
  false always 0
Line 3083
  nullptr always 0
  false always 0
Line 3086
  ( always {!<=-1,!>=2}
Line 3102
  path possible symbolic=(name_it->first)@205
  ( {lifetime[Object]=(path),!0}
  & {lifetime[Address]=(statbuf),!0}
  != always {!<=-1,!>=2}
  0 always 0
Line 3103
  return always {!<=-1,!>=2}
  false always 0
Line 3108
  return always {!<=-1,!>=2}
  true always 1
Line 3124
  = {lifetime[Iterator]=(dui.includes),lifetime[Object]=(dui),start=0}
  ( {lifetime[Iterator]=(dui.includes),lifetime[Object]=(dui),start=0}
  it possible {lifetime[Iterator]=(dui.includes),lifetime[Object]=(dui),start=0}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(dui.includes),lifetime[Object]=(dui),end=0}
Line 3125
  it {lifetime[Iterator]=(dui.includes),lifetime[Object]=(dui),!symbolic=(dui.includes.end()),!end=0}
Line 3127
  "" always ""
  filename always symbolic=(*it)
  false always 0
  outputList possible 0
Line 3128
  loaded {!<=-1,!>=2,0}
  = always {!<=-1,!>=2}
Line 3131
  filedata always symbolic=(loadResult.first)
  == always {!<=-1,!>=2}
  nullptr always 0
Line 3134
  = always 7
  :: always 7
  EXPLICIT_INCLUDE_NOT_FOUND always 7
Line 3135
  = possible lifetime[SubObject]=(filenames)
  ( possible lifetime[SubObject]=(filenames)
Line 3136
  err possible lifetime[SubObject]=(filenames)
  "Can not open include file '" always "Can not open include file '"
  "' that is explicitly included." always "' that is explicitly included."
Line 3137
  outputList always !0
Line 3142
  ! always {!<=-1,!>=2}
  loaded {symbolic=(loadResult.second),!<=-1,!>=2}
Line 3145
  ! always {!<=-1,!>=2}
  filedata always !0
Line 3148
  . always {!<=-1,!>=2}
  removeComments always {!<=-1,!>=2}
Line 3154
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  = possible 0
  ? possible 0
  : always 0
  nullptr always 0
Line 3155
  == always {!<=-1,!>=2}
  nullptr always 0
Line 3160
  != always {!<=-1,!>=2}
  '#' always 35
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 3164
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  rawtok always !0
  != always {!<=-1,!>=2}
Line 3167
  rawtok always !0
Line 3169
  rawtok always !0
Line 3170
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  rawtok always !0
  htok always symbolic=(rawtok->nextSkipComments())
Line 3173
  systemheader always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  htok always symbolic=(rawtok->nextSkipComments())
  0 always 0
  == always {!<=-1,!>=2}
  '<' always 60
Line 3174
  htok always symbolic=(rawtok->nextSkipComments())
  1U always 1
  htok always symbolic=(rawtok->nextSkipComments())
  ( always !<=-1
  - always !<=-1
  2U always 2
Line 3176
  systemheader {symbolic=(htok->str()[0]=='<'),!<=-1,!>=2}
Line 3177
  ! always {!<=-1,!>=2}
Line 3180
  . always {!<=-1,!>=2}
  removeComments always {!<=-1,!>=2}
Line 3181
  filedata always !0
Line 3183
  filedata always !0
Line 3184
  filedata always !0
Line 3190
  ( always {!<=-1,!>=2}
Line 3192
  tok1 possible {lifetime[Address]=(inctok)@61,lifetime[Address]=(tmp)@131,lifetime[Address]=(rawtok)@153}
Line 3193
  it possible {symbolic=(macros.end()),end=0}
  = possible lifetime[Iterator]=(macros)
  ( possible lifetime[Iterator]=(macros)
  tok always symbolic=(*tok1)
Line 3194
  it {lifetime[Iterator]=(macros),symbolic=(macros.find(tok->str()))}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(macros),end=0}
Line 3197
  tok1 possible {lifetime[Address]=(inctok)@61,lifetime[Address]=(tmp)@131,lifetime[Address]=(rawtok)@153}
  it {lifetime[Iterator]=(macros),!end=0}
  & {lifetime[Address]=(value),!0}
  tok always symbolic=(*tok1)
Line 3201
  = always 4
  :: always 4
  SYNTAX_ERROR always 4
Line 3203
  "failed to expand \'" always "failed to expand \'"
  "\', " always "\', "
Line 3204
  outputList always !0
Line 3206
  return always {!<=-1,!>=2}
  false always 0
Line 3210
  ! always {!<=-1,!>=2}
  tok always symbolic=(*tok1)
  . always {!<=-1,!>=2}
  comment always {!<=-1,!>=2}
Line 3212
  tok1 possible {lifetime[Address]=(inctok)@61,lifetime[Address]=(tmp)@131,lifetime[Address]=(rawtok)@153}
  tok possible symbolic=(*tok1)
Line 3214
  return always {!<=-1,!>=2}
  true always 1
Line 3220
  & {lifetime[Address]=(t),!0,Uninit*}
  t always Uninit
Line 3223
  & {lifetime[Address]=(t),!0}
  & {lifetime[Address]=(ltime),!0}
Line 3231
  buf always !0
  12 always 12
  = always "??? ?? ????"
  "??? ?? ????" always "??? ?? ????"
Line 3232
  ( always !<=-1
  buf always !0
  sizeof always 12
  ( always 12
  buf always !0
  "%b %d %Y" always "%b %d %Y"
  timep possible lifetime[Address]=(ltime)@16
Line 3233
  "\"" always "\""
  buf always !0
  "\"" always "\""
Line 3238
  buf always !0
  9 always 9
  = always "??:??:??"
  "??:??:??" always "??:??:??"
Line 3239
  ( always !<=-1
  buf always !0
  sizeof always 9
  ( always 9
  buf always !0
  "%T" always "%T"
  timep possible lifetime[Address]=(ltime)@18
Line 3240
  "\"" always "\""
  buf always !0
  "\"" always "\""
Line 3251
  "char" always "char"
  ( always 1
Line 3252
  sizeOfType always !size=0
  "short" always "short"
  ( always 2
Line 3253
  sizeOfType always {!size=1,!size=0}
  "short int" always "short int"
  sizeOfType always {!size=2,!size=1}
  [ always !<=-1
  "short" always "short"
Line 3254
  sizeOfType always !size=0
  "int" always "int"
  ( always 4
Line 3255
  sizeOfType always {!size=1,!size=0}
  "long" always "long"
  ( always 8
Line 3256
  sizeOfType always {!size=2,!size=1,!size=0}
  "long int" always "long int"
  sizeOfType always {!size=3,!size=2,!size=1}
  [ always !<=-1
  "long" always "long"
Line 3257
  sizeOfType always !size=0
  "long long" always "long long"
  ( always 8
Line 3258
  sizeOfType always {!size=1,!size=0}
  "float" always "float"
  ( always 4
Line 3259
  sizeOfType always {!size=2,!size=1,!size=0}
  "double" always "double"
  ( always 8
Line 3260
  sizeOfType always {!size=3,!size=2,!size=1,!size=0}
  "long double" always "long double"
  ( always 16
Line 3261
  sizeOfType always {!size=4,!size=3,!size=2,!size=1,!size=0}
  "char *" always "char *"
  ( always 8
Line 3262
  sizeOfType always {!size=5,!size=4,!size=3,!size=2,!size=1,!size=0}
  "short *" always "short *"
  ( always 8
Line 3263
  sizeOfType always {!size=6,!size=5,!size=4,!size=3,!size=2,!size=1,!size=0}
  "short int *" always "short int *"
  sizeOfType always {!size=7,!size=6,!size=5,!size=4,!size=3,!size=2,!size=1}
  [ always !<=-1
  "short *" always "short *"
Line 3264
  sizeOfType always !size=0
  "int *" always "int *"
  ( always 8
Line 3265
  sizeOfType always {!size=1,!size=0}
  "long *" always "long *"
  ( always 8
Line 3266
  sizeOfType always {!size=2,!size=1,!size=0}
  "long int *" always "long int *"
  sizeOfType always {!size=3,!size=2,!size=1}
  [ always !<=-1
  "long *" always "long *"
Line 3267
  sizeOfType always !size=0
  "long long *" always "long long *"
  ( always 8
Line 3268
  sizeOfType always {!size=1,!size=0}
  "float *" always "float *"
  ( always 8
Line 3269
  sizeOfType always {!size=2,!size=1,!size=0}
  "double *" always "double *"
  ( always 8
Line 3270
  sizeOfType always {!size=3,!size=2,!size=1,!size=0}
  "long double *" always "long double *"
  ( always 8
Line 3275
  hasInclude always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 3277
  strictAnsiDefined always {!<=-1,!>=2}
  strictAnsiDefined always {!<=-1,!>=2}
  = always 0
  false always 0
Line 3278
  = {lifetime[Iterator]=(dui.defines),lifetime[Object]=(dui),start=0}
  ( {lifetime[Iterator]=(dui.defines),lifetime[Object]=(dui),start=0}
  it possible {lifetime[Iterator]=(dui.defines),lifetime[Object]=(dui),start=0}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(dui.defines),lifetime[Object]=(dui),end=0}
Line 3279
  it {lifetime[Iterator]=(dui.defines),lifetime[Object]=(dui),!symbolic=(dui.defines.end()),!end=0}
Line 3280
  eq always !<=-1
  = always !<=-1
  macrostr always symbolic=(*it)
  ( always !<=-1
  '=' always 61
Line 3281
  par always !<=-1
  = always !<=-1
  macrostr always symbolic=(*it)
  ( always !<=-1
  '(' always 40
Line 3282
  macrostr always symbolic=(*it)
  0 always 0
  eq always !<=-1
  par always !<=-1
Line 3283
  == always {!<=-1,!>=2}
  "__STRICT_ANSI__" always "__STRICT_ANSI__"
Line 3284
  strictAnsiDefined always {!<=-1,!>=2}
  = always 1
  true always 1
Line 3285
  ( possible {lifetime[Iterator]=(dui.undefined),lifetime[Object]=(dui)}
  macroname possible size=15
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(dui.undefined),lifetime[Object]=(dui),end=0}
Line 3287
  macrostr always symbolic=(*it)
  0 always 0
  eq always !<=-1
Line 3288
  eq always !<=-1
  == always {!<=-1,!>=2}
  "1" always "1"
  eq always !<=-1
  + always !<=0
  1 always 1
Line 3293
  strictAnsiUndefined {!<=-1,!>=2,0}
  = always {!<=-1,!>=2}
  ( possible {lifetime[Iterator]=(dui.undefined),lifetime[Object]=(dui)}
  "__STRICT_ANSI__" always "__STRICT_ANSI__"
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(dui.undefined),lifetime[Object]=(dui),end=0}
Line 3294
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  strictAnsiDefined always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  strictAnsiUndefined {symbolic=(dui.undefined.find("__STRICT_ANSI__")!=dui.undefined.cend()),!<=-1,!>=2}
Line 3295
  "__STRICT_ANSI__" always "__STRICT_ANSI__"
  "__STRICT_ANSI__" always "__STRICT_ANSI__"
  "1" always "1"
Line 3297
  "__FILE__" always "__FILE__"
  "__FILE__" always "__FILE__"
  "__FILE__" always "__FILE__"
Line 3298
  macros always !size=0
  "__LINE__" always "__LINE__"
  "__LINE__" always "__LINE__"
  "__LINE__" always "__LINE__"
Line 3299
  macros always {!size=1,!size=0}
  "__COUNTER__" always "__COUNTER__"
  "__COUNTER__" always "__COUNTER__"
  "__COUNTER__" always "__COUNTER__"
Line 3302
  macros always {!size=2,!size=1,!size=0}
  "__DATE__" always "__DATE__"
  "__DATE__" always "__DATE__"
  & {lifetime[Address]=(ltime),!0}
Line 3303
  macros always {!size=3,!size=2,!size=1,!size=0}
  "__TIME__" always "__TIME__"
  "__TIME__" always "__TIME__"
  & {lifetime[Address]=(ltime),!0}
Line 3305
  ! {!<=-1,!>=2,0}
  . possible size=0
  ( {!<=-1,!>=2,1}
Line 3306
  c_std possible -1
  . always !size=0
Line 3307
  c_std always symbolic=(simplecpp::getCStd(dui.std))
  != always {!<=-1,!>=2}
  CUnknown always -1
Line 3308
  c_std {symbolic=(simplecpp::getCStd(dui.std)),!-1}
Line 3309
  ! {!<=-1,!>=2,0}
  std_def possible size=0
  ( {!<=-1,!>=2,1}
Line 3310
  macros always {!size=4,!size=3,!size=2,!size=1,!size=0}
  "__STDC_VERSION__" always "__STDC_VERSION__"
  "__STDC_VERSION__" always "__STDC_VERSION__"
  std_def always !size=0
Line 3312
  cpp_std possible -1
  . always !size=0
Line 3313
  cpp_std always symbolic=(simplecpp::getCppStd(dui.std))
  == always {!<=-1,!>=2}
  CPPUnknown always -1
Line 3316
  = always 9
  :: always 9
  DUI_ERROR always 9
Line 3317
  "unknown standard specified: '" always "unknown standard specified: '"
  . always !size=0
  "'" always "'"
Line 3318
  outputList always !0
Line 3320
  output always NonMovedVariable
Line 3323
  cpp_std {symbolic=(simplecpp::getCppStd(dui.std)),!-1}
Line 3324
  ! {!<=-1,!>=2,0}
  std_def possible size=0
  ( {!<=-1,!>=2,1}
Line 3325
  macros always {!size=4,!size=3,!size=2,!size=1,!size=0}
  "__cplusplus" always "__cplusplus"
  "__cplusplus" always "__cplusplus"
  std_def always !size=0
Line 3332
  True always 0
  ElseIsTrue always 1
  AlwaysFalse always 2
Line 3335
  ifstates always size=0
  True always 0
Line 3341
  includetokenstack always size=0
Line 3342
  = {lifetime[Iterator]=(dui.includes),lifetime[Object]=(dui),start=0}
  ( {lifetime[Iterator]=(dui.includes),lifetime[Object]=(dui),start=0}
  it possible {lifetime[Iterator]=(dui.includes),lifetime[Object]=(dui),start=0}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(dui.includes),lifetime[Object]=(dui),end=0}
  it possible {lifetime[Iterator]=(dui.includes),lifetime[Object]=(dui)}
Line 3343
  "" always ""
  it {lifetime[Iterator]=(dui.includes),lifetime[Object]=(dui),!symbolic=(dui.includes.end()),!end=0}
  false always 0
Line 3344
  != always {!<=-1,!>=2}
  nullptr always 0
  && always {!<=-1,!>=2}
  filedata always !0
  != always {!<=-1,!>=2}
  nullptr always 0
Line 3345
  filedata always !0
  ( always !0
Line 3350
  = always 0
  nullptr always 0
  rawtok possible 0
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 3351
  == always {!<=-1,!>=2}
  nullptr always 0
Line 3357
  == always {!<=-1,!>=2}
  '#' always 35
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 3358
  ! always {!<=-1,!>=2}
Line 3363
  ! always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  name always {!<=-1,!>=2}
Line 3368
  ( always !<=-1
  <= always {!<=-1,!>=2}
  1U always 1
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always !symbolic=(ELIF)
  == always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!symbolic=(ELIF),!symbolic=(ELSE)}
  == always {!<=-1,!>=2}
Line 3371
  = always 4
  :: always 4
  SYNTAX_ERROR always 4
Line 3373
  "#" always "#"
  " without #if" always " without #if"
Line 3374
  outputList always !0
Line 3376
  output always NonMovedVariable
Line 3380
  ifstates possible >=size=2
  ( possible {0,2,1}
  == {!<=-1,!>=2,1,0}
  True always 0
  && {!<=-1,!>=2,0}
  == always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always !symbolic=(ERROR)
  == always {!<=-1,!>=2}
Line 3383
  == always {!<=-1,!>=2}
  :: always 0
  ERROR always 0
  : always 1
  :: always 1
  WARNING always 1
Line 3385
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
Line 3386
  ! {!<=-1,!>=2,0}
  . possible size=0
  ( {!<=-1,!>=2,1}
  && {!<=-1,!>=2,0}
  ( always {!<=-1,!>=2}
  0 always 0
Line 3387
  ' ' always 32
Line 3390
  '#' always 35
  ' ' always 32
Line 3391
  outputList always !0
Line 3393
  == always {!<=-1,!>=2}
Line 3394
  output always NonMovedVariable
Line 3399
  ( possible {symbolic=(INCLUDE),symbolic=(IF),symbolic=(IFDEF),symbolic=(IFNDEF),symbolic=(ELIF),symbolic=(ELSE),symbolic=(ENDIF),symbolic=(UNDEF),symbolic=(PRAGMA)}
  == always {!<=-1,!>=2}
Line 3400
  != always {!<=-1,!>=2}
  True always 0
Line 3404
  ( possible {lifetime[Iterator]=(dui.undefined),lifetime[Object]=(dui)}
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(dui.undefined),lifetime[Object]=(dui),end=0}
Line 3405
  it possible {symbolic=(macros.end()),end=0}
  = possible lifetime[Iterator]=(macros)
  ( possible lifetime[Iterator]=(macros)
Line 3406
  it {lifetime[Iterator]=(macros),symbolic=(macros.find(macro.name()))}
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(macros),end=0}
Line 3409
  it {lifetime[Iterator]=(macros),symbolic=(macros.find(macro.name())),!symbolic=(macros.end()),!end=0}
Line 3414
  = always 4
  :: always 4
  SYNTAX_ERROR always 4
Line 3416
  = always "Failed to parse #define"
  "Failed to parse #define" always "Failed to parse #define"
Line 3417
  outputList always !0
Line 3419
  output always NonMovedVariable
Line 3424
  = always 4
  :: always 4
  SYNTAX_ERROR always 4
Line 3426
  "Failed to parse #define, " always "Failed to parse #define, "
Line 3427
  outputList always !0
Line 3429
  output always NonMovedVariable
Line 3432
  ( possible {2,1,0}
  == {!<=-1,!>=2,0,1}
  True always 0
  && {!<=-1,!>=2,0}
  ( always !symbolic=(DEFINE)
  == always {!<=-1,!>=2}
Line 3434
  ( always {!<=-1,!>=2}
Line 3435
  ! always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  comment always {!<=-1,!>=2}
Line 3439
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  name always {!<=-1,!>=2}
Line 3441
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  & {lifetime[Address]=(inctok),!0}
  inctok always symbolic=(inc1.cfront())
Line 3442
  output always NonMovedVariable
Line 3449
  ! {!<=-1,!>=2,1}
  ( {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  '<' always 60
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  '>' always 62
Line 3456
  inc2 always NonMovedVariable
Line 3457
  inc2 always NonMovedVariable
  hdr possible size=0
Line 3458
  = always 60
  '<' always 60
Line 3461
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always !<=-1
  <= always {!<=-1,!>=2}
  2U always 2
Line 3464
  = always 4
  :: always 4
  SYNTAX_ERROR always 4
Line 3466
  = always "No header in #include"
  "No header in #include" always "No header in #include"
Line 3467
  outputList always !0
Line 3469
  output always NonMovedVariable
Line 3475
  systemheader always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  inctok always symbolic=(inc2.cfront())
  0 always 0
  == always {!<=-1,!>=2}
  '<' always 60
Line 3476
  inctok always symbolic=(inc2.cfront())
  1U always 1
  inctok always symbolic=(inc2.cfront())
  ( always !<=-1
  - always !<=-1
  2U always 2
Line 3477
  systemheader {symbolic=(inctok->str()[0]=='<'),!<=-1,!>=2}
  outputList possible 0
Line 3478
  == always {!<=-1,!>=2}
  nullptr always 0
Line 3481
  = always 2
  :: always 2
  MISSING_HEADER always 2
Line 3483
  "Header not found: " always "Header not found: "
  inctok always symbolic=(inc2.cfront())
Line 3484
  outputList always !0
Line 3486
  ( always !<=-1
  >= always {!<=-1,!>=2}
  400 always 400
Line 3489
  = always 3
  :: always 3
  INCLUDE_NESTED_TOO_DEEPLY always 3
Line 3491
  = always "#include nested too deeply"
  "#include nested too deeply" always "#include nested too deeply"
Line 3492
  outputList always !0
Line 3494
  ( possible lifetime[Iterator]=(pragmaOnce)
  filedata always !0
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(pragmaOnce),end=0}
Line 3495
  includetokenstack always !>=size=400
Line 3496
  filedata always !0
Line 3499
  ( {symbolic=(IFDEF),symbolic=(IFNDEF),symbolic=(ELIF),symbolic=(ELSE),symbolic=(ENDIF),symbolic=(UNDEF),symbolic=(PRAGMA),!symbolic=(DEFINE)}
  == always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!symbolic=(DEFINE),!symbolic=(IF)}
  == always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!symbolic=(DEFINE),!symbolic=(IF),!symbolic=(IFDEF)}
  == always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!symbolic=(DEFINE),!symbolic=(IFDEF),!symbolic=(IFNDEF)}
  == always {!<=-1,!>=2}
Line 3500
  ! always {!<=-1,!>=2}
Line 3503
  = always 4
  :: always 4
  SYNTAX_ERROR always 4
Line 3505
  "Syntax error in #" always "Syntax error in #"
Line 3506
  outputList always !0
Line 3508
  output always NonMovedVariable
Line 3512
  conditionIsTrue always {!<=-1,!>=2}
Line 3513
  ( possible {1,0}
  == {!<=-1,!>=2,0}
  AlwaysFalse always 2
  || {!<=-1,!>=2,0}
  ( {0,1,!2}
  == {!<=-1,!>=2,0,1}
  ElseIsTrue always 1
  && {!<=-1,!>=2,0}
  != always {!<=-1,!>=2}
Line 3514
  conditionIsTrue always {!<=-1,!>=2}
  = always 0
  false always 0
Line 3515
  ( possible symbolic=(IFNDEF)
  == always {!<=-1,!>=2}
Line 3516
  conditionIsTrue always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(macros)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(macros),end=0}
  || always {!<=-1,!>=2}
  hasInclude always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 3518
  ( always !symbolic=(IFDEF)
  == always {!<=-1,!>=2}
Line 3519
  conditionIsTrue always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(macros)
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(macros),end=0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  hasInclude always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 3523
  && always {!<=-1,!>=2}
  tok always !0
  ( always {!<=-1,!>=2}
  tok possible symbolic=(tmp->previous)
Line 3524
  ! always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  name always {!<=-1,!>=2}
Line 3529
  == always {!<=-1,!>=2}
Line 3531
  par {!<=-1,!>=2,0}
  = always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  tok always !0
  == always {!<=-1,!>=2}
  '(' always 40
Line 3532
  par {symbolic=(tok&&tok->op=='('),!<=-1,!>=2,0}
Line 3536
  ( possible lifetime[Iterator]=(macros)
  tok always !0
  ( possible symbolic=(HAS_INCLUDE)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(macros),end=0}
Line 3537
  "1" always "1"
  tok always !0
Line 3538
  hasInclude always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  tok always !0
  == always {!<=-1,!>=2}
Line 3539
  "1" always "1"
  tok always !0
Line 3541
  "0" always "0"
  tok always !0
Line 3543
  par {!<=-1,!>=2,0}
Line 3544
  = possible 0
  ? possible 0
  tok always !0
  : always 0
  nullptr always 0
Line 3545
  ! {!<=-1,!>=2,1}
  tok possible 0
  || {!<=-1,!>=2,1}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
  || {!<=-1,!>=2,1}
  par always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  tok always !0
  != always {!<=-1,!>=2}
  ')' always 41
Line 3548
  = always 4
  :: always 4
  SYNTAX_ERROR always 4
Line 3550
  "failed to evaluate " always "failed to evaluate "
  == always {!<=-1,!>=2}
  "#if" always "#if"
  : always "#elif"
  "#elif" always "#elif"
  " condition" always " condition"
Line 3551
  outputList always !0
Line 3553
  output always NonMovedVariable
Line 3559
  hasInclude always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 3561
  par {!<=-1,!>=2,0}
  = always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  tok always !0
  == always {!<=-1,!>=2}
  '(' always 40
Line 3562
  par {symbolic=(tok&&tok->op=='('),!<=-1,!>=2,0}
Line 3564
  closingAngularBracket {!<=-1,!>=2,0}
  closingAngularBracket always {!<=-1,!>=2}
  = always 0
  false always 0
Line 3567
  systemheader {!<=-1,!>=2,0}
  = always {!<=-1,!>=2}
  tok always 1
  && always {!<=-1,!>=2}
  tok always !0
  == always {!<=-1,!>=2}
  '<' always 60
Line 3570
  systemheader {symbolic=(tok&&tok->op=='<'),!<=-1,!>=2}
Line 3571
  && always {!<=-1,!>=2}
  tok always !0
  != always {!<=-1,!>=2}
  '>' always 62
Line 3572
  tok always !0
Line 3573
  tok possible 0
  && {!<=-1,!>=2,0}
  tok always !0
  == always {!<=-1,!>=2}
  '>' always 62
Line 3574
  closingAngularBracket always {!<=-1,!>=2}
  = always 1
  true always 1
Line 3576
  tok always !0
  1U always 1
  tok always !0
  ( always !<=-1
  - always !<=-1
  2U always 2
Line 3577
  closingAngularBracket always {!<=-1,!>=2}
  = always 1
  true always 1
Line 3580
  sourcefile always {symbolic=(rawtok->location.file()),symbolic=(sourcefile)}
  systemheader {symbolic=(tok&&tok->op=='<'),!<=-1,!>=2,1,0}
Line 3581
  ( always {!<=-1,!>=2}
  "0" always "0"
  : always "1"
  "1" always "1"
Line 3583
  par {!<=-1,!>=2,0}
Line 3584
  = possible 0
  ? possible 0
  tok always !0
  : always 0
  nullptr always 0
Line 3585
  ! {!<=-1,!>=2,1}
  tok possible 0
  || {!<=-1,!>=2,1}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
  || {!<=-1,!>=2,1}
  par always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  tok always !0
  != always {!<=-1,!>=2}
  ')' always 41
  || {!<=-1,!>=2,1}
  ! always {!<=-1,!>=2}
  closingAngularBracket always {!<=-1,!>=2}
Line 3588
  = always 4
  :: always 4
  SYNTAX_ERROR always 4
Line 3590
  "failed to evaluate " always "failed to evaluate "
  == always {!<=-1,!>=2}
  "#if" always "#if"
  : always "#elif"
  "#elif" always "#elif"
  " condition" always " condition"
Line 3591
  outputList always !0
Line 3593
  output always NonMovedVariable
Line 3602
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  & {lifetime[Address]=(tmp),!0}
  tmp {symbolic=(tok),0}
Line 3603
  output always NonMovedVariable
Line 3606
  ! always {!<=-1,!>=2}
Line 3608
  tmp always !0
Line 3614
  ( always {!<=-1,!>=2}
  "" always ""
  : always " "
  " " always " "
Line 3616
  conditionIsTrue always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  0 always 0
Line 3617
  ifCond always !0
  E possible size=0
Line 3620
  conditionIsTrue always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  0 always 0
Line 3625
  = always 4
  :: always 4
  SYNTAX_ERROR always 4
Line 3627
  "failed to evaluate " always "failed to evaluate "
  == always {!<=-1,!>=2}
  "#if" always "#if"
  : always "#elif"
  "#elif" always "#elif"
  " condition" always " condition"
Line 3628
  && always {!<=-1,!>=2}
  ( always !0
Line 3629
  ", " always ", "
Line 3630
  outputList always !0
Line 3632
  output always NonMovedVariable
Line 3637
  != always {!<=-1,!>=2}
Line 3639
  != always {!<=-1,!>=2}
  True always 0
Line 3640
  AlwaysFalse always 2
Line 3642
  conditionIsTrue always {!<=-1,!>=2}
  ? possible {0,1}
  True always 0
  : always 1
  ElseIsTrue always 1
Line 3644
  ( possible 1
  == {!<=-1,!>=2,0}
  True always 0
Line 3645
  = always 2
  AlwaysFalse always 2
Line 3648
  ( always !0
  == always {!<=-1,!>=2}
  ElseIsTrue always 1
  && always {!<=-1,!>=2}
  conditionIsTrue always {!<=-1,!>=2}
Line 3649
  = always 0
  True always 0
Line 3653
  ( {symbolic=(ENDIF),symbolic=(UNDEF),symbolic=(PRAGMA),!symbolic=(DEFINE),!symbolic=(IF),!symbolic=(IFDEF),!symbolic=(IFNDEF),!symbolic=(ELIF)}
  == always {!<=-1,!>=2}
Line 3654
  == always {!<=-1,!>=2}
  ElseIsTrue always 1
  True always 0
  : always 2
  AlwaysFalse always 2
Line 3657
  ( {symbolic=(UNDEF),symbolic=(PRAGMA),!symbolic=(DEFINE),!symbolic=(IF),!symbolic=(IFDEF),!symbolic=(IFNDEF),!symbolic=(ELIF),!symbolic=(ELSE)}
  == always {!<=-1,!>=2}
Line 3661
  ( {symbolic=(PRAGMA),!symbolic=(DEFINE),!symbolic=(IF),!symbolic=(IFDEF),!symbolic=(IFNDEF),!symbolic=(ELIF),!symbolic=(ELSE),!symbolic=(ENDIF)}
  == always {!<=-1,!>=2}
Line 3662
  == always {!<=-1,!>=2}
  True always 0
Line 3664
  ( always {!<=-1,!>=2}
  tok possible symbolic=(rawtok->next)
  && always {!<=-1,!>=2}
  tok possible symbolic=(rawtok->next)
  . always {!<=-1,!>=2}
  comment always {!<=-1,!>=2}
Line 3666
  ( always {!<=-1,!>=2}
  tok possible symbolic=(rawtok->next)
Line 3669
  == always {!<=-1,!>=2}
  True always 0
  && always {!<=-1,!>=2}
  ( always {!symbolic=(DEFINE),!symbolic=(IF),!symbolic=(IFDEF),!symbolic=(IFNDEF),!symbolic=(ELIF),!symbolic=(ELSE),!symbolic=(ENDIF),!symbolic=(UNDEF)}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  . always !0
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 3672
  ( possible {symbolic=((ifstates.top()==ElseIsTrue)?True:AlwaysFalse),2,0}
  != {!<=-1,!>=2,1,0}
  True always 0
  && {!<=-1,!>=2,0}
Line 3673
  . always !0
Line 3679
  != always {!<=-1,!>=2}
  True always 0
Line 3685
  hash {!<=-1,!>=2,0}
  hash always {!<=-1,!>=2}
  = always 0
  false always 0
  hashhash {!<=-1,!>=2,0}
  hashhash always {!<=-1,!>=2}
  = always 0
  false always 0
Line 3686
  == always {!<=-1,!>=2}
  '#' always 35
  && always {!<=-1,!>=2}
Line 3687
  != always {!<=-1,!>=2}
  '#' always 35
Line 3688
  hash always {!<=-1,!>=2}
  = always 1
  true always 1
Line 3690
  ( always {!<=-1,!>=2}
Line 3691
  hashhash always {!<=-1,!>=2}
  = always 1
  true always 1
Line 3699
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  & {lifetime[Address]=(rawtok),!0}
Line 3700
  output always NonMovedVariable
Line 3704
  hash {!<=-1,!>=2,0}
  || always {!<=-1,!>=2}
  hashhash always {!<=-1,!>=2}
Line 3708
  hash always {!<=-1,!>=2}
Line 3709
  '\"' always 34
  '\"' always 34
Line 3720
  = {lifetime[Iterator]=(macros),start=0}
  ( {lifetime[Iterator]=(macros),start=0}
  macroIt possible {lifetime[Iterator]=(macros),start=0}
  != {!<=-1,!>=2,0}
  ( {lifetime[Iterator]=(macros),symbolic=(macroIt),end=0}
  macroIt possible lifetime[Iterator]=(macros)
Line 3721
  macroIt {lifetime[Iterator]=(macros),!symbolic=(macros.end()),!end=0}
Line 3722
  macro always symbolic=(macroIt->second)
Line 3723
  macro always symbolic=(macroIt->second)
Line 3724
  usage always symbolic=(macro.usage())
  ( possible lifetime[Iterator]=(usage)
  ( {lifetime[Iterator]=(usage),end=0}
  temp always symbolic=(maybeUsedMacros[macro.name()])
  ( {lifetime[Iterator]=(maybeUsedMacros[macro.name()]),lifetime[Object]=(maybeUsedMacros),start=0}
  temp always symbolic=(maybeUsedMacros[macro.name()])
  ( {lifetime[Iterator]=(maybeUsedMacros[macro.name()]),lifetime[Object]=(maybeUsedMacros),end=0}
Line 3725
  = {lifetime[Iterator]=(usage),start=0}
  ( {lifetime[Iterator]=(usage),start=0}
  usageIt possible {lifetime[Iterator]=(usage),start=0}
  != {!<=-1,!>=2,0}
  ( {lifetime[Iterator]=(usage),symbolic=(usageIt),end=0}
  usageIt possible lifetime[Iterator]=(usage)
Line 3726
  usageIt {lifetime[Iterator]=(usage),!symbolic=(usage.end()),!end=0}
  macro always symbolic=(macroIt->second)
  ( always {!<=-1,!>=2}
Line 3727
  macro always symbolic=(macroIt->second)
Line 3728
  macro always symbolic=(macroIt->second)
Line 3729
  usageIt {lifetime[Iterator]=(usage),!symbolic=(usage.end()),!end=0}
Line 3730
  macroUsage always !0
Line 3738
  cache always NonMovedVariable
Line 3743
  std possible {size=3,size=12,size=14,size=5}
  == {!<=-1,!>=2,0}
  "c90" always "c90"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "c89" always "c89"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "iso9899:1990" always "iso9899:1990"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "iso9899:199409" always "iso9899:199409"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "gnu90" always "gnu90"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "gnu89" always "gnu89"
Line 3744
  C89 always 0
Line 3745
  std possible {size=3,size=12,size=5}
  == {!<=-1,!>=2,0}
  "c99" always "c99"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "c9x" always "c9x"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "iso9899:1999" always "iso9899:1999"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "iso9899:199x" always "iso9899:199x"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "gnu99" always "gnu99"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "gnu9x" always "gnu9x"
Line 3746
  C99 always 1
Line 3747
  std possible {size=3,size=12,size=5}
  == {!<=-1,!>=2,0}
  "c11" always "c11"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "c1x" always "c1x"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "iso9899:2011" always "iso9899:2011"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "gnu11" always "gnu11"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "gnu1x" always "gnu1x"
Line 3748
  C11 always 2
Line 3749
  std possible {size=3,size=12,size=5}
  == {!<=-1,!>=2,0}
  "c17" always "c17"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "c18" always "c18"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "iso9899:2017" always "iso9899:2017"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "iso9899:2018" always "iso9899:2018"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "gnu17" always "gnu17"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "gnu18" always "gnu18"
Line 3750
  C17 always 3
Line 3751
  std possible {size=5,size=3}
  == {!<=-1,!>=2,0}
  "c23" always "c23"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "gnu23" always "gnu23"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "c2x" always "c2x"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "gnu2x" always "gnu2x"
Line 3752
  C23 always 4
Line 3753
  CUnknown always -1
Line 3758
  std possible symbolic=(simplecpp::getCStd(dui.std))@20
Line 3759
  C89 always 0
Line 3761
  "" always ""
Line 3762
  C99 always 1
Line 3763
  "199901L" always "199901L"
Line 3764
  C11 always 2
Line 3765
  "201112L" always "201112L"
Line 3766
  C17 always 3
Line 3767
  "201710L" always "201710L"
Line 3768
  C23 always 4
Line 3773
  "202311L" always "202311L"
Line 3774
  CUnknown always -1
Line 3775
  "" always ""
Line 3777
  "" always ""
Line 3787
  std possible {size=5,size=7}
  == {!<=-1,!>=2,0}
  "c++98" always "c++98"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "c++03" always "c++03"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "gnu++98" always "gnu++98"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "gnu++03" always "gnu++03"
Line 3788
  CPP03 always 0
Line 3789
  std possible {size=7,size=5}
  == {!<=-1,!>=2,0}
  "c++11" always "c++11"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "gnu++11" always "gnu++11"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "c++0x" always "c++0x"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "gnu++0x" always "gnu++0x"
Line 3790
  CPP11 always 1
Line 3791
  std possible {size=5,size=7}
  == {!<=-1,!>=2,0}
  "c++14" always "c++14"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "c++1y" always "c++1y"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "gnu++14" always "gnu++14"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "gnu++1y" always "gnu++1y"
Line 3792
  CPP14 always 2
Line 3793
  std possible {size=5,size=7}
  == {!<=-1,!>=2,0}
  "c++17" always "c++17"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "c++1z" always "c++1z"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "gnu++17" always "gnu++17"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "gnu++1z" always "gnu++1z"
Line 3794
  CPP17 always 3
Line 3795
  std possible {size=5,size=7}
  == {!<=-1,!>=2,0}
  "c++20" always "c++20"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "c++2a" always "c++2a"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "gnu++20" always "gnu++20"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "gnu++2a" always "gnu++2a"
Line 3796
  CPP20 always 4
Line 3797
  std possible {size=5,size=7}
  == {!<=-1,!>=2,0}
  "c++23" always "c++23"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "c++2b" always "c++2b"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "gnu++23" always "gnu++23"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "gnu++2b" always "gnu++2b"
Line 3798
  CPP23 always 5
Line 3799
  std possible {size=5,size=7}
  == {!<=-1,!>=2,0}
  "c++26" always "c++26"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "c++2c" always "c++2c"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "gnu++26" always "gnu++26"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "gnu++2c" always "gnu++2c"
Line 3800
  CPP26 always 6
Line 3801
  CPPUnknown always -1
Line 3806
  std possible symbolic=(simplecpp::getCppStd(dui.std))@24
Line 3807
  CPP03 always 0
Line 3808
  "199711L" always "199711L"
Line 3809
  CPP11 always 1
Line 3810
  "201103L" always "201103L"
Line 3811
  CPP14 always 2
Line 3812
  "201402L" always "201402L"
Line 3813
  CPP17 always 3
Line 3814
  "201703L" always "201703L"
Line 3815
  CPP20 always 4
Line 3817
  "202002L" always "202002L"
Line 3818
  CPP23 always 5
Line 3823
  "202302L" always "202302L"
Line 3824
  CPP26 always 6
Line 3826
  "202400L" always "202400L"
Line 3827
  CPPUnknown always -1
Line 3828
  "" always ""
Line 3830
  "" always ""
